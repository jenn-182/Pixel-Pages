{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport apiService from '../services/api';\nexport const useFocusTimer = username => {\n  _s();\n  const [activeSession, setActiveSession] = useState(null);\n  const [timeRemaining, setTimeRemaining] = useState(0);\n  const [isRunning, setIsRunning] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [currentPhase, setCurrentPhase] = useState('work'); // 'work', 'break', 'long_break'\n  const [currentCycle, setCurrentCycle] = useState(1);\n  const [startTime, setStartTime] = useState(null);\n  const [totalTimeSpent, setTotalTimeSpent] = useState(0);\n  const intervalRef = useRef(null);\n  const startTimeRef = useRef(null);\n\n  // Start a focus session\n  const startSession = useCallback(async session => {\n    if (!session || !username) return;\n    try {\n      setActiveSession(session);\n      setTimeRemaining(session.workDuration * 60); // Convert minutes to seconds\n      setCurrentPhase('work');\n      setCurrentCycle(1);\n      setTotalTimeSpent(0);\n      setIsRunning(true);\n      setIsPaused(false);\n      setStartTime(new Date());\n      startTimeRef.current = new Date();\n\n      // Start the timer\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          if (prev <= 1) {\n            // Time's up, handle phase completion\n            handlePhaseComplete();\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n    } catch (err) {\n      console.error('Error starting session:', err);\n    }\n  }, [username]);\n\n  // Pause/Resume timer\n  const togglePause = useCallback(() => {\n    if (!activeSession) return;\n    if (isRunning && !isPaused) {\n      // Pause\n      clearInterval(intervalRef.current);\n      setIsPaused(true);\n    } else if (isRunning && isPaused) {\n      // Resume\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          if (prev <= 1) {\n            handlePhaseComplete();\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      setIsPaused(false);\n    }\n  }, [activeSession, isRunning, isPaused]);\n\n  // Stop session and save progress\n  const stopSession = useCallback(async () => {\n    if (!activeSession || !username) return;\n    try {\n      clearInterval(intervalRef.current);\n\n      // Calculate time spent in this phase\n      const phaseStartTime = startTimeRef.current || startTime;\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      if (timeSpentMinutes > 0) {\n        // Save the entry to backend\n        await apiService.createFocusEntry({\n          sessionId: activeSession.id,\n          ownerUsername: username,\n          timeSpent: timeSpentMinutes,\n          date: new Date().toISOString().split('T')[0],\n          startTime: phaseStartTime.toISOString(),\n          endTime: endTime.toISOString(),\n          completed: false,\n          // Manually stopped\n          phase: currentPhase,\n          cycleNumber: currentCycle,\n          notes: `Session stopped manually (${timeSpentMinutes} minutes)`\n        });\n      }\n\n      // Reset timer state\n      resetTimer();\n    } catch (err) {\n      console.error('Error stopping session:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle]);\n\n  // Handle phase completion (work -> break -> work, etc.)\n  const handlePhaseComplete = useCallback(async () => {\n    if (!activeSession || !username) return;\n    try {\n      const phaseStartTime = startTimeRef.current || startTime;\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n\n      // Save completed phase to backend\n      await apiService.createFocusEntry({\n        sessionId: activeSession.id,\n        ownerUsername: username,\n        timeSpent: timeSpentMinutes,\n        date: new Date().toISOString().split('T')[0],\n        startTime: phaseStartTime.toISOString(),\n        endTime: endTime.toISOString(),\n        completed: true,\n        phase: currentPhase,\n        cycleNumber: currentCycle\n      });\n\n      // Update total time\n      setTotalTimeSpent(prev => prev + timeSpentMinutes);\n\n      // Determine next phase\n      let nextPhase = currentPhase;\n      let nextCycle = currentCycle;\n      let nextDuration = 0;\n      if (currentPhase === 'work') {\n        if (currentCycle >= activeSession.cycles) {\n          // Session complete\n          clearInterval(intervalRef.current);\n          setIsRunning(false);\n          resetTimer();\n          return;\n        } else {\n          // Go to break\n          nextPhase = currentCycle % 4 === 0 ? 'long_break' : 'break';\n          nextDuration = nextPhase === 'long_break' ? 15 : activeSession.breakDuration;\n        }\n      } else {\n        // Break finished, go to work\n        nextPhase = 'work';\n        nextCycle = currentCycle + 1;\n        nextDuration = activeSession.workDuration;\n      }\n\n      // Update state for next phase\n      setCurrentPhase(nextPhase);\n      setCurrentCycle(nextCycle);\n      setTimeRemaining(nextDuration * 60);\n      setStartTime(new Date());\n      startTimeRef.current = new Date();\n    } catch (err) {\n      console.error('Error handling phase complete:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle]);\n\n  // Reset timer state\n  const resetTimer = useCallback(() => {\n    clearInterval(intervalRef.current);\n    setActiveSession(null);\n    setTimeRemaining(0);\n    setIsRunning(false);\n    setIsPaused(false);\n    setCurrentPhase('work');\n    setCurrentCycle(1);\n    setStartTime(null);\n    setTotalTimeSpent(0);\n    startTimeRef.current = null;\n  }, []);\n\n  // Format time display\n  const formatTime = useCallback(seconds => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n  return {\n    activeSession,\n    timeRemaining,\n    isRunning,\n    isPaused,\n    currentPhase,\n    currentCycle,\n    totalTimeSpent,\n    startSession,\n    stopSession,\n    togglePause,\n    resetTimer,\n    formatTime: (seconds = timeRemaining) => formatTime(seconds),\n    progress: activeSession ? (activeSession.workDuration * 60 - timeRemaining) / (activeSession.workDuration * 60) * 100 : 0\n  };\n};\n\n// Add default export for backward compatibility\n_s(useFocusTimer, \"GFRU1EYCrS+oFqTJmMhJNOisP88=\");\nexport default useFocusTimer;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","apiService","useFocusTimer","username","_s","activeSession","setActiveSession","timeRemaining","setTimeRemaining","isRunning","setIsRunning","isPaused","setIsPaused","currentPhase","setCurrentPhase","currentCycle","setCurrentCycle","startTime","setStartTime","totalTimeSpent","setTotalTimeSpent","intervalRef","startTimeRef","startSession","session","workDuration","Date","current","setInterval","prev","handlePhaseComplete","err","console","error","togglePause","clearInterval","stopSession","phaseStartTime","endTime","timeSpentMinutes","Math","round","createFocusEntry","sessionId","id","ownerUsername","timeSpent","date","toISOString","split","completed","phase","cycleNumber","notes","resetTimer","nextPhase","nextCycle","nextDuration","cycles","breakDuration","formatTime","seconds","mins","floor","secs","toString","padStart","progress"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/hooks/useFocusTimer.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport apiService from '../services/api';\n\nexport const useFocusTimer = (username) => {\n  const [activeSession, setActiveSession] = useState(null);\n  const [timeRemaining, setTimeRemaining] = useState(0);\n  const [isRunning, setIsRunning] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [currentPhase, setCurrentPhase] = useState('work'); // 'work', 'break', 'long_break'\n  const [currentCycle, setCurrentCycle] = useState(1);\n  const [startTime, setStartTime] = useState(null);\n  const [totalTimeSpent, setTotalTimeSpent] = useState(0);\n  \n  const intervalRef = useRef(null);\n  const startTimeRef = useRef(null);\n\n  // Start a focus session\n  const startSession = useCallback(async (session) => {\n    if (!session || !username) return;\n    \n    try {\n      setActiveSession(session);\n      setTimeRemaining(session.workDuration * 60); // Convert minutes to seconds\n      setCurrentPhase('work');\n      setCurrentCycle(1);\n      setTotalTimeSpent(0);\n      setIsRunning(true);\n      setIsPaused(false);\n      setStartTime(new Date());\n      startTimeRef.current = new Date();\n      \n      // Start the timer\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          if (prev <= 1) {\n            // Time's up, handle phase completion\n            handlePhaseComplete();\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      \n    } catch (err) {\n      console.error('Error starting session:', err);\n    }\n  }, [username]);\n\n  // Pause/Resume timer\n  const togglePause = useCallback(() => {\n    if (!activeSession) return;\n    \n    if (isRunning && !isPaused) {\n      // Pause\n      clearInterval(intervalRef.current);\n      setIsPaused(true);\n    } else if (isRunning && isPaused) {\n      // Resume\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          if (prev <= 1) {\n            handlePhaseComplete();\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      setIsPaused(false);\n    }\n  }, [activeSession, isRunning, isPaused]);\n\n  // Stop session and save progress\n  const stopSession = useCallback(async () => {\n    if (!activeSession || !username) return;\n    \n    try {\n      clearInterval(intervalRef.current);\n      \n      // Calculate time spent in this phase\n      const phaseStartTime = startTimeRef.current || startTime;\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      \n      if (timeSpentMinutes > 0) {\n        // Save the entry to backend\n        await apiService.createFocusEntry({\n          sessionId: activeSession.id,\n          ownerUsername: username,\n          timeSpent: timeSpentMinutes,\n          date: new Date().toISOString().split('T')[0],\n          startTime: phaseStartTime.toISOString(),\n          endTime: endTime.toISOString(),\n          completed: false, // Manually stopped\n          phase: currentPhase,\n          cycleNumber: currentCycle,\n          notes: `Session stopped manually (${timeSpentMinutes} minutes)`\n        });\n      }\n      \n      // Reset timer state\n      resetTimer();\n      \n    } catch (err) {\n      console.error('Error stopping session:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle]);\n\n  // Handle phase completion (work -> break -> work, etc.)\n  const handlePhaseComplete = useCallback(async () => {\n    if (!activeSession || !username) return;\n    \n    try {\n      const phaseStartTime = startTimeRef.current || startTime;\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      \n      // Save completed phase to backend\n      await apiService.createFocusEntry({\n        sessionId: activeSession.id,\n        ownerUsername: username,\n        timeSpent: timeSpentMinutes,\n        date: new Date().toISOString().split('T')[0],\n        startTime: phaseStartTime.toISOString(),\n        endTime: endTime.toISOString(),\n        completed: true,\n        phase: currentPhase,\n        cycleNumber: currentCycle\n      });\n      \n      // Update total time\n      setTotalTimeSpent(prev => prev + timeSpentMinutes);\n      \n      // Determine next phase\n      let nextPhase = currentPhase;\n      let nextCycle = currentCycle;\n      let nextDuration = 0;\n      \n      if (currentPhase === 'work') {\n        if (currentCycle >= activeSession.cycles) {\n          // Session complete\n          clearInterval(intervalRef.current);\n          setIsRunning(false);\n          resetTimer();\n          return;\n        } else {\n          // Go to break\n          nextPhase = currentCycle % 4 === 0 ? 'long_break' : 'break';\n          nextDuration = nextPhase === 'long_break' ? 15 : activeSession.breakDuration;\n        }\n      } else {\n        // Break finished, go to work\n        nextPhase = 'work';\n        nextCycle = currentCycle + 1;\n        nextDuration = activeSession.workDuration;\n      }\n      \n      // Update state for next phase\n      setCurrentPhase(nextPhase);\n      setCurrentCycle(nextCycle);\n      setTimeRemaining(nextDuration * 60);\n      setStartTime(new Date());\n      startTimeRef.current = new Date();\n      \n    } catch (err) {\n      console.error('Error handling phase complete:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle]);\n\n  // Reset timer state\n  const resetTimer = useCallback(() => {\n    clearInterval(intervalRef.current);\n    setActiveSession(null);\n    setTimeRemaining(0);\n    setIsRunning(false);\n    setIsPaused(false);\n    setCurrentPhase('work');\n    setCurrentCycle(1);\n    setStartTime(null);\n    setTotalTimeSpent(0);\n    startTimeRef.current = null;\n  }, []);\n\n  // Format time display\n  const formatTime = useCallback((seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    activeSession,\n    timeRemaining,\n    isRunning,\n    isPaused,\n    currentPhase,\n    currentCycle,\n    totalTimeSpent,\n    startSession,\n    stopSession,\n    togglePause,\n    resetTimer,\n    formatTime: (seconds = timeRemaining) => formatTime(seconds),\n    progress: activeSession ? \n      (((activeSession.workDuration * 60) - timeRemaining) / (activeSession.workDuration * 60)) * 100 : 0\n  };\n};\n\n// Add default export for backward compatibility\nexport default useFocusTimer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}