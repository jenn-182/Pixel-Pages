{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nconst useFocusSessions = () => {\n  _s();\n  const [sessions, setSessions] = useState([]);\n  const [loading, setLoading] = useState(true);\n\n  // For now, we'll use localStorage since we don't have backend endpoints yet\n  const STORAGE_KEY = 'pixelPages_focusSessions';\n  const LOGS_STORAGE_KEY = 'pixelPages_focusLogs';\n\n  // Load sessions from localStorage\n  const loadSessions = () => {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEY);\n      if (stored) {\n        setSessions(JSON.parse(stored));\n      }\n    } catch (error) {\n      console.error('Error loading focus sessions:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Save sessions to localStorage\n  const saveSessions = newSessions => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(newSessions));\n    } catch (error) {\n      console.error('Error saving focus sessions:', error);\n    }\n  };\n\n  // Create new session category\n  const createSession = async sessionData => {\n    try {\n      const newSession = {\n        id: Date.now().toString(),\n        name: sessionData.name,\n        description: sessionData.description || '',\n        colorCode: sessionData.colorCode || '#8B5CF6',\n        tag: sessionData.tag || '',\n        workDuration: sessionData.workDuration || 25,\n        breakDuration: sessionData.breakDuration || 5,\n        longBreakDuration: sessionData.longBreakDuration || 15,\n        cycles: sessionData.cycles || 1,\n        createdAt: new Date().toISOString(),\n        totalTimeLogged: 0\n      };\n      const updatedSessions = [...sessions, newSession];\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return newSession;\n    } catch (error) {\n      console.error('Error creating session:', error);\n      throw error;\n    }\n  };\n\n  // Update session category\n  const updateSession = async (sessionId, sessionData) => {\n    try {\n      const updatedSessions = sessions.map(session => session.id === sessionId ? {\n        ...session,\n        ...sessionData,\n        updatedAt: new Date().toISOString()\n      } : session);\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return updatedSessions.find(s => s.id === sessionId);\n    } catch (error) {\n      console.error('Error updating session:', error);\n      throw error;\n    }\n  };\n\n  // Delete session category\n  const deleteSession = async sessionId => {\n    try {\n      const updatedSessions = sessions.filter(s => s.id !== sessionId);\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n\n      // Also remove related logs\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      const updatedLogs = logs.filter(log => log.sessionId !== sessionId);\n      localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(updatedLogs));\n    } catch (error) {\n      console.error('Error deleting session:', error);\n      throw error;\n    }\n  };\n\n  // Log completed focus time\n  const logFocusTime = async (sessionId, timeSpent, date = new Date()) => {\n    try {\n      const logEntry = {\n        id: Date.now().toString(),\n        sessionId,\n        timeSpent,\n        // in minutes\n        date: date.toISOString(),\n        completed: true,\n        createdAt: new Date().toISOString()\n      };\n\n      // Save to logs\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      const updatedLogs = [...logs, logEntry];\n      localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(updatedLogs));\n\n      // Update session's total time\n      const updatedSessions = sessions.map(session => session.id === sessionId ? {\n        ...session,\n        totalTimeLogged: (session.totalTimeLogged || 0) + timeSpent\n      } : session);\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return logEntry;\n    } catch (error) {\n      console.error('Error logging focus time:', error);\n      throw error;\n    }\n  };\n\n  // Get focus logs for a session\n  const getSessionLogs = sessionId => {\n    try {\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      return logs.filter(log => log.sessionId === sessionId);\n    } catch (error) {\n      console.error('Error getting session logs:', error);\n      return [];\n    }\n  };\n\n  // Get all focus logs\n  const getAllLogs = () => {\n    try {\n      return JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n    } catch (error) {\n      console.error('Error getting all logs:', error);\n      return [];\n    }\n  };\n  useEffect(() => {\n    loadSessions();\n  }, []);\n  return {\n    sessions,\n    loading,\n    createSession,\n    updateSession,\n    deleteSession,\n    logFocusTime,\n    getSessionLogs,\n    getAllLogs,\n    refetch: loadSessions\n  };\n};\n_s(useFocusSessions, \"TgG2i7AZommEFr3q/aeiXxYueSg=\");\nexport default useFocusSessions;","map":{"version":3,"names":["useState","useEffect","useFocusSessions","_s","sessions","setSessions","loading","setLoading","STORAGE_KEY","LOGS_STORAGE_KEY","loadSessions","stored","localStorage","getItem","JSON","parse","error","console","saveSessions","newSessions","setItem","stringify","createSession","sessionData","newSession","id","Date","now","toString","name","description","colorCode","tag","workDuration","breakDuration","longBreakDuration","cycles","createdAt","toISOString","totalTimeLogged","updatedSessions","updateSession","sessionId","map","session","updatedAt","find","s","deleteSession","filter","logs","updatedLogs","log","logFocusTime","timeSpent","date","logEntry","completed","getSessionLogs","getAllLogs","refetch"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/hooks/useFocusSessions.js"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nconst useFocusSessions = () => {\n  const [sessions, setSessions] = useState([]);\n  const [loading, setLoading] = useState(true);\n\n  // For now, we'll use localStorage since we don't have backend endpoints yet\n  const STORAGE_KEY = 'pixelPages_focusSessions';\n  const LOGS_STORAGE_KEY = 'pixelPages_focusLogs';\n\n  // Load sessions from localStorage\n  const loadSessions = () => {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEY);\n      if (stored) {\n        setSessions(JSON.parse(stored));\n      }\n    } catch (error) {\n      console.error('Error loading focus sessions:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Save sessions to localStorage\n  const saveSessions = (newSessions) => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(newSessions));\n    } catch (error) {\n      console.error('Error saving focus sessions:', error);\n    }\n  };\n\n  // Create new session category\n  const createSession = async (sessionData) => {\n    try {\n      const newSession = {\n        id: Date.now().toString(),\n        name: sessionData.name,\n        description: sessionData.description || '',\n        colorCode: sessionData.colorCode || '#8B5CF6',\n        tag: sessionData.tag || '',\n        workDuration: sessionData.workDuration || 25,\n        breakDuration: sessionData.breakDuration || 5,\n        longBreakDuration: sessionData.longBreakDuration || 15,\n        cycles: sessionData.cycles || 1,\n        createdAt: new Date().toISOString(),\n        totalTimeLogged: 0\n      };\n\n      const updatedSessions = [...sessions, newSession];\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return newSession;\n    } catch (error) {\n      console.error('Error creating session:', error);\n      throw error;\n    }\n  };\n\n  // Update session category\n  const updateSession = async (sessionId, sessionData) => {\n    try {\n      const updatedSessions = sessions.map(session => \n        session.id === sessionId \n          ? { ...session, ...sessionData, updatedAt: new Date().toISOString() }\n          : session\n      );\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return updatedSessions.find(s => s.id === sessionId);\n    } catch (error) {\n      console.error('Error updating session:', error);\n      throw error;\n    }\n  };\n\n  // Delete session category\n  const deleteSession = async (sessionId) => {\n    try {\n      const updatedSessions = sessions.filter(s => s.id !== sessionId);\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      \n      // Also remove related logs\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      const updatedLogs = logs.filter(log => log.sessionId !== sessionId);\n      localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(updatedLogs));\n    } catch (error) {\n      console.error('Error deleting session:', error);\n      throw error;\n    }\n  };\n\n  // Log completed focus time\n  const logFocusTime = async (sessionId, timeSpent, date = new Date()) => {\n    try {\n      const logEntry = {\n        id: Date.now().toString(),\n        sessionId,\n        timeSpent, // in minutes\n        date: date.toISOString(),\n        completed: true,\n        createdAt: new Date().toISOString()\n      };\n\n      // Save to logs\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      const updatedLogs = [...logs, logEntry];\n      localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(updatedLogs));\n\n      // Update session's total time\n      const updatedSessions = sessions.map(session => \n        session.id === sessionId \n          ? { ...session, totalTimeLogged: (session.totalTimeLogged || 0) + timeSpent }\n          : session\n      );\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n\n      return logEntry;\n    } catch (error) {\n      console.error('Error logging focus time:', error);\n      throw error;\n    }\n  };\n\n  // Get focus logs for a session\n  const getSessionLogs = (sessionId) => {\n    try {\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      return logs.filter(log => log.sessionId === sessionId);\n    } catch (error) {\n      console.error('Error getting session logs:', error);\n      return [];\n    }\n  };\n\n  // Get all focus logs\n  const getAllLogs = () => {\n    try {\n      return JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n    } catch (error) {\n      console.error('Error getting all logs:', error);\n      return [];\n    }\n  };\n\n  useEffect(() => {\n    loadSessions();\n  }, []);\n\n  return {\n    sessions,\n    loading,\n    createSession,\n    updateSession,\n    deleteSession,\n    logFocusTime,\n    getSessionLogs,\n    getAllLogs,\n    refetch: loadSessions\n  };\n};\n\nexport default useFocusSessions;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}