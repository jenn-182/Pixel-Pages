{"ast":null,"code":"import { allAchievements, tierInfo } from '../data/achievements';\nclass AchievementService {\n  constructor() {\n    this.unlockedAchievements = this.loadUnlockedAchievements();\n    this.listeners = [];\n  }\n\n  // Load unlocked achievements from localStorage\n  loadUnlockedAchievements() {\n    const saved = localStorage.getItem('unlockedAchievements');\n    return saved ? JSON.parse(saved) : [];\n  }\n\n  // Save unlocked achievements to localStorage\n  saveUnlockedAchievements() {\n    localStorage.setItem('unlockedAchievements', JSON.stringify(this.unlockedAchievements));\n  }\n\n  // Add event listener for achievement unlocks\n  addEventListener(callback) {\n    this.listeners.push(callback);\n  }\n\n  // Remove event listener\n  removeEventListener(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  // Notify listeners of achievement unlock\n  notifyListeners(achievement) {\n    this.listeners.forEach(callback => callback(achievement));\n  }\n\n  // Check if achievement is unlocked\n  isUnlocked(achievementId) {\n    return this.unlockedAchievements.some(a => a.id === achievementId);\n  }\n\n  // Unlock achievement\n  unlockAchievement(achievementId) {\n    if (this.isUnlocked(achievementId)) return false;\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement) return false;\n    const unlockedAchievement = {\n      ...achievement,\n      unlockedAt: new Date().toISOString()\n    };\n    this.unlockedAchievements.push(unlockedAchievement);\n    this.saveUnlockedAchievements();\n\n    // Trigger achievement notification\n    this.triggerAchievementNotification(achievement);\n    this.notifyListeners(achievement);\n\n    // Track when achievements are unlocked\n    this.trackAchievementUnlock(achievementId);\n    return true;\n  }\n\n  // Track when achievements are unlocked\n  trackAchievementUnlock(achievementId) {\n    const unlockedAchievements = this.getUnlockedAchievements();\n    if (!unlockedAchievements.includes(achievementId)) {\n      const newUnlocked = [...unlockedAchievements, achievementId];\n\n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData.unlockedAchievements = newUnlocked;\n      achievementData.unlockDates = {\n        ...achievementData.unlockDates,\n        [achievementId]: new Date().toISOString()\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n    }\n  }\n\n  // Check achievements based on user stats\n  checkAchievements(userStats) {\n    const newlyUnlocked = [];\n    allAchievements.forEach(achievement => {\n      if (!this.isUnlocked(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        }\n      }\n    });\n    return newlyUnlocked;\n  }\n\n  // Enhanced requirement checking\n  meetsRequirement(requirement, userStats) {\n    var _userStats$sessionsBy;\n    switch (requirement.type) {\n      // Note achievements\n      case 'note_count':\n        return (userStats.totalNotes || 0) >= requirement.target;\n      case 'word_count':\n        return (userStats.totalWords || 0) >= requirement.target;\n      case 'unique_tags':\n        return (userStats.uniqueTags || 0) >= requirement.target;\n      case 'daily_notes':\n        return (userStats.notesToday || 0) >= requirement.target;\n      case 'weekend_notes':\n        return (userStats.weekendNotes || 0) >= requirement.target;\n      case 'weekly_notes':\n        return (userStats.notesThisWeek || 0) >= requirement.target;\n      case 'single_note_words':\n        return (userStats.maxWordsInNote || 0) >= requirement.target;\n      case 'single_note_tags':\n        return (userStats.maxTagsInNote || 0) >= requirement.target;\n      case 'streak':\n        return (userStats.noteStreak || 0) >= requirement.target;\n      case 'note_edits':\n        return (userStats.totalEdits || 0) >= requirement.target;\n      case 'single_note_edits':\n        return (userStats.maxEditsOnNote || 0) >= requirement.target;\n\n      // Task achievements\n      case 'task_count':\n        return (userStats.totalTasks || 0) >= requirement.target;\n      case 'daily_tasks':\n        return (userStats.tasksToday || 0) >= requirement.target;\n      case 'weekly_tasks':\n        return (userStats.tasksThisWeek || 0) >= requirement.target;\n      case 'monthly_tasks':\n        return (userStats.tasksThisMonth || 0) >= requirement.target;\n      case 'high_priority_tasks':\n        return (userStats.highPriorityTasks || 0) >= requirement.target;\n      case 'urgent_tasks':\n        return (userStats.urgentTasks || 0) >= requirement.target;\n      case 'early_completions':\n        return (userStats.earlyCompletions || 0) >= requirement.target;\n      case 'completion_streak':\n        return (userStats.taskStreak || 0) >= requirement.target;\n      case 'task_categories':\n        return (userStats.taskCategories || 0) >= requirement.target;\n      case 'task_creation':\n        return (userStats.tasksCreated || 0) >= requirement.target;\n      case 'active_tasks':\n        return (userStats.activeTasks || 0) >= requirement.target;\n      case 'completion_rate':\n        const completionRate = userStats.totalTasks > 0 ? (userStats.completedTasks || 0) / userStats.totalTasks : 0;\n        return completionRate >= requirement.target;\n\n      // Focus achievements\n      case 'session_count':\n        return (userStats.totalSessions || 0) >= requirement.target;\n      case 'total_time':\n        return (userStats.totalFocusTime || 0) >= requirement.target;\n      case 'single_session_duration':\n        return (userStats.maxSessionDuration || 0) >= requirement.target;\n      case 'session_duration_range':\n        const rangeSessions = userStats.sessionsByDuration || {};\n        let rangeCount = 0;\n        for (let duration = requirement.minDuration; duration <= requirement.maxDuration; duration++) {\n          rangeCount += rangeSessions[duration] || 0;\n        }\n        return rangeCount >= requirement.target;\n      case 'pomodoro_count':\n        const pomodoroSessions = ((_userStats$sessionsBy = userStats.sessionsByDuration) === null || _userStats$sessionsBy === void 0 ? void 0 : _userStats$sessionsBy[25]) || 0;\n        return pomodoroSessions >= requirement.target;\n      case 'daily_streak':\n        return (userStats.focusStreak || 0) >= requirement.target;\n      case 'category_sessions':\n        const categorySessions = userStats.categorySessions || {};\n        return (categorySessions[requirement.category] || 0) >= requirement.target;\n      case 'category_time':\n        const categoryTime = userStats.categoryTime || {};\n        return Math.max(...Object.values(categoryTime)) >= requirement.target;\n      case 'all_categories_time':\n        const allCategoryTime = userStats.categoryTime || {};\n        return Object.values(allCategoryTime).every(time => time >= requirement.target);\n      case 'unique_categories':\n        const uniqueCategories = Object.keys(userStats.categorySessions || {}).length;\n        return uniqueCategories >= requirement.target;\n      case 'break_session':\n        const breakSessions = userStats.breakSessions || 0;\n        return breakSessions >= requirement.target;\n      case 'long_sessions':\n        const longSessions = userStats.sessionsOver90Min || 0;\n        return longSessions >= requirement.target;\n      case 'time_variety':\n        const sessionTimes = Object.keys(userStats.sessionsByTime || {}).length;\n        return sessionTimes >= requirement.target;\n\n      // Combo achievements\n      case 'daily_combo':\n        const dailyActivities = userStats.dailyActivities || [];\n        return requirement.activities.every(activity => dailyActivities.includes(activity));\n      case 'weekly_combo':\n        const weeklyActivities = userStats.weeklyActivities || [];\n        return requirement.activities.every(activity => weeklyActivities.includes(activity));\n      case 'combo_streak':\n        return (userStats.comboStreak || 0) >= requirement.target;\n      case 'activity_consistency':\n        return (userStats.activityStreak || 0) >= requirement.target;\n      case 'daily_activity_count':\n        return (userStats.activitiesToday || 0) >= requirement.target;\n      case 'monthly_activity_count':\n        return (userStats.activitiesThisMonth || 0) >= requirement.target;\n\n      // Meta achievements\n      case 'player_level':\n        return (userStats.level || 1) >= requirement.target;\n      case 'total_xp':\n        return (userStats.totalXP || 0) >= requirement.target;\n      case 'achievement_count':\n        return this.unlockedAchievements.length >= requirement.target;\n      case 'completion_percentage':\n        return this.unlockedAchievements.length / allAchievements.length >= requirement.target;\n      case 'tier_completion':\n        const tierAchievements = allAchievements.filter(a => a.tier === requirement.tier);\n        const unlockedInTier = this.unlockedAchievements.filter(a => a.tier === requirement.tier);\n        return unlockedInTier.length / tierAchievements.length >= requirement.target;\n\n      // Time-based achievements\n      case 'time_range':\n        const now = new Date();\n        const hour = now.getHours();\n        if (requirement.startHour > requirement.endHour) {\n          // Crosses midnight\n          return hour >= requirement.startHour || hour < requirement.endHour;\n        }\n        return hour >= requirement.startHour && hour < requirement.endHour;\n      case 'time_before':\n        return new Date().getHours() < requirement.hour;\n      case 'time_after':\n        return new Date().getHours() >= requirement.hour;\n      case 'weekend_activity':\n        const dayOfWeek = new Date().getDay();\n        return (dayOfWeek === 0 || dayOfWeek === 6) && (userStats.weekendActivities || 0) >= requirement.target;\n      case 'speed_writing':\n        return (userStats.fastestWordsPer5Min || 0) >= requirement.words;\n      default:\n        console.warn(`Unknown requirement type: ${requirement.type}`);\n        return false;\n    }\n  }\n\n  // Trigger achievement notification with enhanced styling\n  triggerAchievementNotification(achievement) {\n    const tier = tierInfo[achievement.tier];\n    console.log(`🎉 ${tier.emoji} ${achievement.name} UNLOCKED! (+${achievement.xpReward} XP)`);\n\n    // Dispatch custom event for UI components\n    window.dispatchEvent(new CustomEvent('achievementUnlocked', {\n      detail: {\n        achievement,\n        tier,\n        timestamp: new Date().toISOString()\n      }\n    }));\n\n    // Play achievement sound (if available)\n    this.playAchievementSound(achievement.tier);\n  }\n\n  // Play achievement sound based on tier\n  playAchievementSound(tier) {\n    try {\n      const audio = new Audio(`/sounds/achievement_${tier}.mp3`);\n      audio.volume = 0.3;\n      audio.play().catch(() => {\n        console.log(`Sound not found for tier: ${tier}`);\n      });\n    } catch (error) {\n      console.error('Error playing achievement sound:', error);\n    }\n  }\n\n  // Get achievement progress\n  getAchievementProgress(achievementId, userStats) {\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement || this.isUnlocked(achievementId)) return 1;\n    const req = achievement.requirement;\n    let current = 0;\n    let target = req.target || 1;\n    switch (req.type) {\n      case 'note_count':\n        current = userStats.totalNotes || 0;\n        break;\n      case 'word_count':\n        current = userStats.totalWords || 0;\n        break;\n      case 'task_count':\n        current = userStats.totalTasks || 0;\n        break;\n      case 'session_count':\n        current = userStats.totalSessions || 0;\n        break;\n      case 'total_time':\n        current = userStats.totalFocusTime || 0;\n        break;\n      case 'unique_tags':\n        current = userStats.uniqueTags || 0;\n        break;\n      case 'streak':\n      case 'completion_streak':\n      case 'daily_streak':\n        current = userStats[req.type === 'streak' ? 'noteStreak' : req.type === 'completion_streak' ? 'taskStreak' : 'focusStreak'] || 0;\n        break;\n      default:\n        return 0;\n    }\n    return Math.min(current / target, 1);\n  }\n\n  // Get user's next achievements to unlock\n  getNextAchievements(userStats, limit = 5) {\n    return allAchievements.filter(achievement => !this.isUnlocked(achievement.id)).map(achievement => ({\n      ...achievement,\n      progress: this.getAchievementProgress(achievement.id, userStats)\n    })).sort((a, b) => b.progress - a.progress).slice(0, limit);\n  }\n\n  // Get recently unlocked achievements\n  getRecentlyUnlocked(days = 7) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    return this.unlockedAchievements.filter(achievement => new Date(achievement.unlockedAt) >= cutoffDate).sort((a, b) => new Date(b.unlockedAt) - new Date(a.unlockedAt));\n  }\n\n  // Get stats summary\n  getStats() {\n    const total = allAchievements.length;\n    const unlocked = this.unlockedAchievements.length;\n    const byTier = {\n      common: this.unlockedAchievements.filter(a => a.tier === 'common').length,\n      uncommon: this.unlockedAchievements.filter(a => a.tier === 'uncommon').length,\n      rare: this.unlockedAchievements.filter(a => a.tier === 'rare').length,\n      legendary: this.unlockedAchievements.filter(a => a.tier === 'legendary').length\n    };\n    const totalXP = this.unlockedAchievements.reduce((sum, achievement) => sum + achievement.xpReward, 0);\n    return {\n      total,\n      unlocked,\n      percentage: Math.round(unlocked / total * 100),\n      byTier,\n      totalXP,\n      recentUnlocks: this.getRecentlyUnlocked(7).length\n    };\n  }\n\n  // Reset all achievements (for testing)\n  resetAchievements() {\n    this.unlockedAchievements = [];\n    this.saveUnlockedAchievements();\n    console.log('🔄 All achievements reset!');\n  }\n\n  // Manually unlock achievement (for testing)\n  forceUnlock(achievementId) {\n    return this.unlockAchievement(achievementId);\n  }\n\n  // Get achievement with unlock date\n  getAchievementWithUnlockDate(achievement) {\n    const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n    const unlockDates = achievementData.unlockDates || {};\n    return {\n      ...achievement,\n      unlockedAt: unlockDates[achievement.id] || null\n    };\n  }\n\n  // Get unlocked achievements\n  getUnlockedAchievements() {\n    return this.unlockedAchievements.map(a => a.id);\n  }\n}\nexport const achievementService = new AchievementService();\nexport default achievementService;","map":{"version":3,"names":["allAchievements","tierInfo","AchievementService","constructor","unlockedAchievements","loadUnlockedAchievements","listeners","saved","localStorage","getItem","JSON","parse","saveUnlockedAchievements","setItem","stringify","addEventListener","callback","push","removeEventListener","filter","listener","notifyListeners","achievement","forEach","isUnlocked","achievementId","some","a","id","unlockAchievement","find","unlockedAchievement","unlockedAt","Date","toISOString","triggerAchievementNotification","trackAchievementUnlock","getUnlockedAchievements","includes","newUnlocked","achievementData","unlockDates","checkAchievements","userStats","newlyUnlocked","meetsRequirement","requirement","_userStats$sessionsBy","type","totalNotes","target","totalWords","uniqueTags","notesToday","weekendNotes","notesThisWeek","maxWordsInNote","maxTagsInNote","noteStreak","totalEdits","maxEditsOnNote","totalTasks","tasksToday","tasksThisWeek","tasksThisMonth","highPriorityTasks","urgentTasks","earlyCompletions","taskStreak","taskCategories","tasksCreated","activeTasks","completionRate","completedTasks","totalSessions","totalFocusTime","maxSessionDuration","rangeSessions","sessionsByDuration","rangeCount","duration","minDuration","maxDuration","pomodoroSessions","focusStreak","categorySessions","category","categoryTime","Math","max","Object","values","allCategoryTime","every","time","uniqueCategories","keys","length","breakSessions","longSessions","sessionsOver90Min","sessionTimes","sessionsByTime","dailyActivities","activities","activity","weeklyActivities","comboStreak","activityStreak","activitiesToday","activitiesThisMonth","level","totalXP","tierAchievements","tier","unlockedInTier","now","hour","getHours","startHour","endHour","dayOfWeek","getDay","weekendActivities","fastestWordsPer5Min","words","console","warn","log","emoji","name","xpReward","window","dispatchEvent","CustomEvent","detail","timestamp","playAchievementSound","audio","Audio","volume","play","catch","error","getAchievementProgress","req","current","min","getNextAchievements","limit","map","progress","sort","b","slice","getRecentlyUnlocked","days","cutoffDate","setDate","getDate","getStats","total","unlocked","byTier","common","uncommon","rare","legendary","reduce","sum","percentage","round","recentUnlocks","resetAchievements","forceUnlock","getAchievementWithUnlockDate","achievementService"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/services/achievementService.js"],"sourcesContent":["import { allAchievements, tierInfo } from '../data/achievements';\n\nclass AchievementService {\n  constructor() {\n    this.unlockedAchievements = this.loadUnlockedAchievements();\n    this.listeners = [];\n  }\n\n  // Load unlocked achievements from localStorage\n  loadUnlockedAchievements() {\n    const saved = localStorage.getItem('unlockedAchievements');\n    return saved ? JSON.parse(saved) : [];\n  }\n\n  // Save unlocked achievements to localStorage\n  saveUnlockedAchievements() {\n    localStorage.setItem('unlockedAchievements', JSON.stringify(this.unlockedAchievements));\n  }\n\n  // Add event listener for achievement unlocks\n  addEventListener(callback) {\n    this.listeners.push(callback);\n  }\n\n  // Remove event listener\n  removeEventListener(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  // Notify listeners of achievement unlock\n  notifyListeners(achievement) {\n    this.listeners.forEach(callback => callback(achievement));\n  }\n\n  // Check if achievement is unlocked\n  isUnlocked(achievementId) {\n    return this.unlockedAchievements.some(a => a.id === achievementId);\n  }\n\n  // Unlock achievement\n  unlockAchievement(achievementId) {\n    if (this.isUnlocked(achievementId)) return false;\n    \n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement) return false;\n\n    const unlockedAchievement = {\n      ...achievement,\n      unlockedAt: new Date().toISOString()\n    };\n\n    this.unlockedAchievements.push(unlockedAchievement);\n    this.saveUnlockedAchievements();\n    \n    // Trigger achievement notification\n    this.triggerAchievementNotification(achievement);\n    this.notifyListeners(achievement);\n    \n    // Track when achievements are unlocked\n    this.trackAchievementUnlock(achievementId);\n    \n    return true;\n  }\n\n  // Track when achievements are unlocked\n  trackAchievementUnlock(achievementId) {\n    const unlockedAchievements = this.getUnlockedAchievements();\n    \n    if (!unlockedAchievements.includes(achievementId)) {\n      const newUnlocked = [...unlockedAchievements, achievementId];\n      \n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData.unlockedAchievements = newUnlocked;\n      achievementData.unlockDates = {\n        ...achievementData.unlockDates,\n        [achievementId]: new Date().toISOString()\n      };\n      \n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n    }\n  }\n\n  // Check achievements based on user stats\n  checkAchievements(userStats) {\n    const newlyUnlocked = [];\n\n    allAchievements.forEach(achievement => {\n      if (!this.isUnlocked(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        }\n      }\n    });\n\n    return newlyUnlocked;\n  }\n\n  // Enhanced requirement checking\n  meetsRequirement(requirement, userStats) {\n    switch (requirement.type) {\n      // Note achievements\n      case 'note_count':\n        return (userStats.totalNotes || 0) >= requirement.target;\n      \n      case 'word_count':\n        return (userStats.totalWords || 0) >= requirement.target;\n      \n      case 'unique_tags':\n        return (userStats.uniqueTags || 0) >= requirement.target;\n      \n      case 'daily_notes':\n        return (userStats.notesToday || 0) >= requirement.target;\n      \n      case 'weekend_notes':\n        return (userStats.weekendNotes || 0) >= requirement.target;\n      \n      case 'weekly_notes':\n        return (userStats.notesThisWeek || 0) >= requirement.target;\n      \n      case 'single_note_words':\n        return (userStats.maxWordsInNote || 0) >= requirement.target;\n      \n      case 'single_note_tags':\n        return (userStats.maxTagsInNote || 0) >= requirement.target;\n      \n      case 'streak':\n        return (userStats.noteStreak || 0) >= requirement.target;\n      \n      case 'note_edits':\n        return (userStats.totalEdits || 0) >= requirement.target;\n      \n      case 'single_note_edits':\n        return (userStats.maxEditsOnNote || 0) >= requirement.target;\n      \n      // Task achievements\n      case 'task_count':\n        return (userStats.totalTasks || 0) >= requirement.target;\n      \n      case 'daily_tasks':\n        return (userStats.tasksToday || 0) >= requirement.target;\n      \n      case 'weekly_tasks':\n        return (userStats.tasksThisWeek || 0) >= requirement.target;\n      \n      case 'monthly_tasks':\n        return (userStats.tasksThisMonth || 0) >= requirement.target;\n      \n      case 'high_priority_tasks':\n        return (userStats.highPriorityTasks || 0) >= requirement.target;\n      \n      case 'urgent_tasks':\n        return (userStats.urgentTasks || 0) >= requirement.target;\n      \n      case 'early_completions':\n        return (userStats.earlyCompletions || 0) >= requirement.target;\n      \n      case 'completion_streak':\n        return (userStats.taskStreak || 0) >= requirement.target;\n      \n      case 'task_categories':\n        return (userStats.taskCategories || 0) >= requirement.target;\n      \n      case 'task_creation':\n        return (userStats.tasksCreated || 0) >= requirement.target;\n      \n      case 'active_tasks':\n        return (userStats.activeTasks || 0) >= requirement.target;\n      \n      case 'completion_rate':\n        const completionRate = userStats.totalTasks > 0 ? \n          (userStats.completedTasks || 0) / userStats.totalTasks : 0;\n        return completionRate >= requirement.target;\n      \n      // Focus achievements\n      case 'session_count':\n        return (userStats.totalSessions || 0) >= requirement.target;\n      \n      case 'total_time':\n        return (userStats.totalFocusTime || 0) >= requirement.target;\n      \n      case 'single_session_duration':\n        return (userStats.maxSessionDuration || 0) >= requirement.target;\n      \n      case 'session_duration_range':\n        const rangeSessions = userStats.sessionsByDuration || {};\n        let rangeCount = 0;\n        for (let duration = requirement.minDuration; duration <= requirement.maxDuration; duration++) {\n          rangeCount += rangeSessions[duration] || 0;\n        }\n        return rangeCount >= requirement.target;\n      \n      case 'pomodoro_count':\n        const pomodoroSessions = userStats.sessionsByDuration?.[25] || 0;\n        return pomodoroSessions >= requirement.target;\n      \n      case 'daily_streak':\n        return (userStats.focusStreak || 0) >= requirement.target;\n      \n      case 'category_sessions':\n        const categorySessions = userStats.categorySessions || {};\n        return (categorySessions[requirement.category] || 0) >= requirement.target;\n      \n      case 'category_time':\n        const categoryTime = userStats.categoryTime || {};\n        return Math.max(...Object.values(categoryTime)) >= requirement.target;\n      \n      case 'all_categories_time':\n        const allCategoryTime = userStats.categoryTime || {};\n        return Object.values(allCategoryTime).every(time => time >= requirement.target);\n      \n      case 'unique_categories':\n        const uniqueCategories = Object.keys(userStats.categorySessions || {}).length;\n        return uniqueCategories >= requirement.target;\n      \n      case 'break_session':\n        const breakSessions = userStats.breakSessions || 0;\n        return breakSessions >= requirement.target;\n      \n      case 'long_sessions':\n        const longSessions = userStats.sessionsOver90Min || 0;\n        return longSessions >= requirement.target;\n      \n      case 'time_variety':\n        const sessionTimes = Object.keys(userStats.sessionsByTime || {}).length;\n        return sessionTimes >= requirement.target;\n      \n      // Combo achievements\n      case 'daily_combo':\n        const dailyActivities = userStats.dailyActivities || [];\n        return requirement.activities.every(activity => dailyActivities.includes(activity));\n      \n      case 'weekly_combo':\n        const weeklyActivities = userStats.weeklyActivities || [];\n        return requirement.activities.every(activity => weeklyActivities.includes(activity));\n      \n      case 'combo_streak':\n        return (userStats.comboStreak || 0) >= requirement.target;\n      \n      case 'activity_consistency':\n        return (userStats.activityStreak || 0) >= requirement.target;\n      \n      case 'daily_activity_count':\n        return (userStats.activitiesToday || 0) >= requirement.target;\n      \n      case 'monthly_activity_count':\n        return (userStats.activitiesThisMonth || 0) >= requirement.target;\n      \n      // Meta achievements\n      case 'player_level':\n        return (userStats.level || 1) >= requirement.target;\n      \n      case 'total_xp':\n        return (userStats.totalXP || 0) >= requirement.target;\n      \n      case 'achievement_count':\n        return this.unlockedAchievements.length >= requirement.target;\n      \n      case 'completion_percentage':\n        return (this.unlockedAchievements.length / allAchievements.length) >= requirement.target;\n      \n      case 'tier_completion':\n        const tierAchievements = allAchievements.filter(a => a.tier === requirement.tier);\n        const unlockedInTier = this.unlockedAchievements.filter(a => a.tier === requirement.tier);\n        return (unlockedInTier.length / tierAchievements.length) >= requirement.target;\n      \n      // Time-based achievements\n      case 'time_range':\n        const now = new Date();\n        const hour = now.getHours();\n        if (requirement.startHour > requirement.endHour) {\n          // Crosses midnight\n          return hour >= requirement.startHour || hour < requirement.endHour;\n        }\n        return hour >= requirement.startHour && hour < requirement.endHour;\n      \n      case 'time_before':\n        return new Date().getHours() < requirement.hour;\n      \n      case 'time_after':\n        return new Date().getHours() >= requirement.hour;\n      \n      case 'weekend_activity':\n        const dayOfWeek = new Date().getDay();\n        return (dayOfWeek === 0 || dayOfWeek === 6) && (userStats.weekendActivities || 0) >= requirement.target;\n      \n      case 'speed_writing':\n        return (userStats.fastestWordsPer5Min || 0) >= requirement.words;\n      \n      default:\n        console.warn(`Unknown requirement type: ${requirement.type}`);\n        return false;\n    }\n  }\n\n  // Trigger achievement notification with enhanced styling\n  triggerAchievementNotification(achievement) {\n    const tier = tierInfo[achievement.tier];\n    \n    console.log(`🎉 ${tier.emoji} ${achievement.name} UNLOCKED! (+${achievement.xpReward} XP)`);\n    \n    // Dispatch custom event for UI components\n    window.dispatchEvent(new CustomEvent('achievementUnlocked', {\n      detail: {\n        achievement,\n        tier,\n        timestamp: new Date().toISOString()\n      }\n    }));\n\n    // Play achievement sound (if available)\n    this.playAchievementSound(achievement.tier);\n  }\n\n  // Play achievement sound based on tier\n  playAchievementSound(tier) {\n    try {\n      const audio = new Audio(`/sounds/achievement_${tier}.mp3`);\n      audio.volume = 0.3;\n      audio.play().catch(() => {\n        console.log(`Sound not found for tier: ${tier}`);\n      });\n    } catch (error) {\n      console.error('Error playing achievement sound:', error);\n    }\n  }\n\n  // Get achievement progress\n  getAchievementProgress(achievementId, userStats) {\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement || this.isUnlocked(achievementId)) return 1;\n\n    const req = achievement.requirement;\n    let current = 0;\n    let target = req.target || 1;\n\n    switch (req.type) {\n      case 'note_count':\n        current = userStats.totalNotes || 0;\n        break;\n      case 'word_count':\n        current = userStats.totalWords || 0;\n        break;\n      case 'task_count':\n        current = userStats.totalTasks || 0;\n        break;\n      case 'session_count':\n        current = userStats.totalSessions || 0;\n        break;\n      case 'total_time':\n        current = userStats.totalFocusTime || 0;\n        break;\n      case 'unique_tags':\n        current = userStats.uniqueTags || 0;\n        break;\n      case 'streak':\n      case 'completion_streak':\n      case 'daily_streak':\n        current = userStats[req.type === 'streak' ? 'noteStreak' : \n                            req.type === 'completion_streak' ? 'taskStreak' : 'focusStreak'] || 0;\n        break;\n      default:\n        return 0;\n    }\n\n    return Math.min(current / target, 1);\n  }\n\n  // Get user's next achievements to unlock\n  getNextAchievements(userStats, limit = 5) {\n    return allAchievements\n      .filter(achievement => !this.isUnlocked(achievement.id))\n      .map(achievement => ({\n        ...achievement,\n        progress: this.getAchievementProgress(achievement.id, userStats)\n      }))\n      .sort((a, b) => b.progress - a.progress)\n      .slice(0, limit);\n  }\n\n  // Get recently unlocked achievements\n  getRecentlyUnlocked(days = 7) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    \n    return this.unlockedAchievements\n      .filter(achievement => new Date(achievement.unlockedAt) >= cutoffDate)\n      .sort((a, b) => new Date(b.unlockedAt) - new Date(a.unlockedAt));\n  }\n\n  // Get stats summary\n  getStats() {\n    const total = allAchievements.length;\n    const unlocked = this.unlockedAchievements.length;\n    const byTier = {\n      common: this.unlockedAchievements.filter(a => a.tier === 'common').length,\n      uncommon: this.unlockedAchievements.filter(a => a.tier === 'uncommon').length,\n      rare: this.unlockedAchievements.filter(a => a.tier === 'rare').length,\n      legendary: this.unlockedAchievements.filter(a => a.tier === 'legendary').length\n    };\n\n    const totalXP = this.unlockedAchievements.reduce((sum, achievement) => sum + achievement.xpReward, 0);\n\n    return {\n      total,\n      unlocked,\n      percentage: Math.round((unlocked / total) * 100),\n      byTier,\n      totalXP,\n      recentUnlocks: this.getRecentlyUnlocked(7).length\n    };\n  }\n\n  // Reset all achievements (for testing)\n  resetAchievements() {\n    this.unlockedAchievements = [];\n    this.saveUnlockedAchievements();\n    console.log('🔄 All achievements reset!');\n  }\n\n  // Manually unlock achievement (for testing)\n  forceUnlock(achievementId) {\n    return this.unlockAchievement(achievementId);\n  }\n\n  // Get achievement with unlock date\n  getAchievementWithUnlockDate(achievement) {\n    const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n    const unlockDates = achievementData.unlockDates || {};\n    \n    return {\n      ...achievement,\n      unlockedAt: unlockDates[achievement.id] || null\n    };\n  }\n\n  // Get unlocked achievements\n  getUnlockedAchievements() {\n    return this.unlockedAchievements.map(a => a.id);\n  }\n}\n\nexport const achievementService = new AchievementService();\nexport default achievementService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}