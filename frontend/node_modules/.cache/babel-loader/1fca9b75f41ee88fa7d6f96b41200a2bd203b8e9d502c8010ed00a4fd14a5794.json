{"ast":null,"code":"import { allAchievements, tierInfo } from '../data/achievements';\nclass AchievementService {\n  constructor() {\n    this.unlockedAchievements = this.loadUnlockedAchievements();\n    this.listeners = [];\n  }\n\n  // Load unlocked achievements from localStorage\n  loadUnlockedAchievements() {\n    const saved = localStorage.getItem('unlockedAchievements');\n    return saved ? JSON.parse(saved) : [];\n  }\n\n  // Save unlocked achievements to localStorage\n  saveUnlockedAchievements() {\n    localStorage.setItem('unlockedAchievements', JSON.stringify(this.unlockedAchievements));\n  }\n\n  // Add event listener for achievement unlocks\n  addEventListener(callback) {\n    this.listeners.push(callback);\n  }\n\n  // Remove event listener\n  removeEventListener(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  // Notify listeners of achievement unlock\n  notifyListeners(achievement) {\n    this.listeners.forEach(callback => callback(achievement));\n  }\n\n  // Check if achievement is unlocked\n  isUnlocked(achievementId) {\n    return this.unlockedAchievements.some(a => a.id === achievementId);\n  }\n\n  // Unlock achievement\n  unlockAchievement(achievementId) {\n    if (this.isUnlocked(achievementId)) return false;\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement) return false;\n    const unlockedAchievement = {\n      ...achievement,\n      unlockedAt: new Date().toISOString()\n    };\n    this.unlockedAchievements.push(unlockedAchievement);\n    this.saveUnlockedAchievements();\n\n    // âœ… Sync with backend immediately\n    this.syncAchievementWithBackend(achievementId);\n\n    // Trigger achievement notification\n    this.triggerAchievementNotification(achievement);\n    this.notifyListeners(achievement);\n\n    // Track when achievements are unlocked\n    this.trackAchievementUnlock(achievementId);\n    return true;\n  }\n\n  // Sync achievement with backend\n  async syncAchievementWithBackend(achievementId) {\n    try {\n      const response = await fetch('http://localhost:8080/api/player/achievements/unlock', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          username: 'Jroc_182',\n          // Changed from 'user'\n          achievementId: achievementId\n        })\n      });\n      if (response.ok) {\n        console.log(`âœ… Synced ${achievementId} with backend`);\n      } else {\n        console.warn(`âš ï¸ Failed to sync ${achievementId} with backend`);\n      }\n    } catch (error) {\n      console.error(`âŒ Error syncing ${achievementId}:`, error);\n    }\n  }\n\n  // Track when achievements are unlocked\n  trackAchievementUnlock(achievementId) {\n    const unlockedAchievements = this.getUnlockedAchievements();\n\n    // âœ… FIX: Only store achievement IDs, not full objects\n    const unlockedIds = unlockedAchievements.map(a => a.id || a);\n    if (!unlockedIds.includes(achievementId)) {\n      const newUnlockedIds = [...unlockedIds, achievementId]; // âœ… Store ID only\n\n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData.unlockDates = {\n        ...achievementData.unlockDates,\n        [achievementId]: new Date().toISOString()\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlockedIds)); // âœ… Store IDs only\n    }\n  }\n\n  // Check achievements based on user stats\n  checkAchievements(userStats) {\n    const newlyUnlocked = [];\n    allAchievements.forEach(achievement => {\n      if (!this.isUnlocked(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        }\n      }\n    });\n    return newlyUnlocked;\n  }\n\n  // Enhanced requirement checking\n  meetsRequirement(requirement, userStats) {\n    switch (requirement.type) {\n      // Focus/Session requirements (existing)\n      case 'session_count':\n        return (userStats.totalSessions || 0) >= requirement.target;\n      case 'total_time':\n        return (userStats.totalFocusTime || userStats.totalFocusMinutes || 0) >= requirement.target;\n      case 'max_session':\n        return (userStats.maxSessionDuration || 0) >= requirement.target;\n      case 'category_focus':\n        const categoryTime = userStats.categoryTime || {};\n        return (categoryTime[requirement.category] || 0) >= requirement.target;\n      case 'all_categories_time':\n        const allCategoryTime = userStats.categoryTime || {};\n        const totalTimeAllCategories = Object.values(allCategoryTime).reduce((sum, time) => sum + time, 0);\n        return totalTimeAllCategories >= requirement.target;\n      case 'unique_categories':\n        return (userStats.uniqueCategories || 0) >= requirement.target;\n\n      // NOTE REQUIREMENTS\n      case 'note_count':\n        return (userStats.totalNotes || 0) >= requirement.target;\n      case 'word_count':\n        return (userStats.totalWords || 0) >= requirement.target;\n      case 'tag_count':\n      case 'unique_tags':\n        return (userStats.uniqueTags || 0) >= requirement.target;\n      case 'note_edits':\n        return (userStats.totalEdits || 0) >= requirement.target;\n      case 'single_note_edits':\n        return (userStats.maxNoteEdits || userStats.maxEditsInNote || 0) >= requirement.target;\n      case 'single_note_words':\n        return (userStats.maxWordsInNote || 0) >= requirement.target;\n      case 'single_note_tags':\n        return (userStats.maxTagsInNote || 0) >= requirement.target;\n      case 'weekend_notes':\n        return (userStats.weekendNotes || 0) >= requirement.target;\n      case 'weekly_notes':\n        return (userStats.notesThisWeek || 0) >= requirement.target;\n      case 'streak':\n        return (userStats.noteStreak || 0) >= requirement.target;\n      case 'time_range':\n        return (userStats.timeRangeNotes || 0) >= 1;\n      case 'speed_writing':\n        return (userStats.speedWriting || 0) >= requirement.target;\n\n      // TASK REQUIREMENTS\n      case 'task_count':\n        return (userStats.completedTasks || 0) >= requirement.target;\n      case 'tasks_created':\n        return (userStats.totalTasks || 0) >= requirement.target;\n      case 'daily_tasks':\n        return (userStats.tasksToday || 0) >= requirement.target;\n      case 'weekly_tasks':\n        return (userStats.tasksThisWeek || 0) >= requirement.target;\n      case 'monthly_tasks':\n        return (userStats.tasksThisMonth || 0) >= requirement.target;\n      case 'high_priority_tasks':\n        return (userStats.highPriorityTasks || 0) >= requirement.target;\n      case 'early_completions':\n        return (userStats.earlyCompletions || 0) >= requirement.target;\n      case 'completion_streak':\n        return (userStats.taskStreak || 0) >= requirement.target;\n      case 'task_categories':\n        return (userStats.taskCategories || 0) >= requirement.target;\n      case 'priority_usage':\n        return (userStats.priorityUsage || 0) >= requirement.target;\n      case 'due_date_usage':\n        return (userStats.dueDateUsage || 0) >= requirement.target;\n      case 'completion_ratio':\n        const totalTasks = userStats.totalTasks || 0;\n        const completedTasks = userStats.completedTasks || 0;\n        return totalTasks > 0 && completedTasks / totalTasks >= requirement.ratio;\n      case 'morning_completions':\n        return (userStats.morningCompletions || 0) >= requirement.target;\n      case 'evening_completions':\n        return (userStats.eveningCompletions || 0) >= requirement.target;\n      case 'active_lists':\n        return (userStats.activeLists || 0) >= requirement.target;\n      case 'urgent_tasks':\n        return (userStats.urgentTasks || 0) >= requirement.target;\n      case 'ontime_rate':\n        const totalWithDueDate = userStats.tasksWithDueDate || 0;\n        const onTimeCompletions = userStats.onTimeCompletions || 0;\n        return totalWithDueDate >= requirement.tasks && onTimeCompletions / totalWithDueDate >= requirement.rate;\n      case 'concurrent_tasks':\n        return (userStats.maxConcurrentTasks || 0) >= requirement.target;\n\n      // FOCUS/SESSION REQUIREMENTS (additional)\n      case 'session_duration_range':\n        return (userStats.sessionDurationRange || 0) >= 1;\n      case 'break_session':\n        return (userStats.breakSessions || 0) >= requirement.target;\n      case 'time_before':\n        return (userStats.timeBefore || 0) >= requirement.target;\n      case 'time_after':\n        return (userStats.timeAfter || 0) >= requirement.target;\n      case 'pomodoro_count':\n        return (userStats.pomodoroSessions || 0) >= requirement.target;\n      case 'daily_streak':\n        return (userStats.currentStreak || userStats.dailyStreak || 0) >= requirement.target;\n      case 'category_sessions':\n        const categorySessions = userStats.categorySessions || {};\n        return (categorySessions[requirement.category] || 0) >= requirement.target;\n      case 'duration_variety':\n        return (userStats.durationVariety || 0) >= requirement.target;\n      case 'category_time':\n        const categoryTimeStats = userStats.categoryTime || {};\n        return (categoryTimeStats[requirement.category] || 0) >= requirement.target;\n      case 'long_sessions':\n        return (userStats.longSessions || 0) >= requirement.target;\n      case 'monthly_sessions':\n        return (userStats.monthlyFocusSessions || 0) >= requirement.target;\n      case 'time_variety':\n        return (userStats.timeVariety || 0) >= requirement.target;\n\n      // COMBO/SPECIAL REQUIREMENTS\n      case 'daily_combo':\n        return userStats.dailyCombo || false;\n      case 'weekly_combo':\n        return userStats.weeklyCombo || false;\n      case 'achievement_count':\n        return (userStats.completedAchievements || 0) >= requirement.target;\n      case 'activity_consistency':\n        return (userStats.currentStreak || 0) >= requirement.target;\n      case 'category_mastery':\n        return (userStats.categoryMastery || 0) >= requirement.target;\n      case 'super_combo':\n        return userStats.superCombo || false;\n      case 'weekend_activity':\n        return (userStats.weekendActivity || 0) >= requirement.target;\n      case 'late_night_activity':\n        return (userStats.lateNightActivity || 0) >= requirement.target;\n      case 'early_morning_activity':\n        return (userStats.earlyMorningActivity || 0) >= requirement.target;\n      case 'combo_streak':\n        return (userStats.comboStreak || 0) >= requirement.target;\n      case 'category_completion':\n        return (userStats.categoryCompletion || 0) >= requirement.target;\n      case 'daily_activity_streak':\n        return (userStats.dailyActivityStreak || 0) >= requirement.target;\n      case 'feature_usage':\n        return (userStats.featureUsage || 0) >= requirement.target;\n      case 'daily_activity_count':\n        return (userStats.dailyActivityCount || 0) >= requirement.target;\n      case 'monthly_activity_count':\n        return (userStats.monthlyActivityCount || 0) >= requirement.target;\n      case 'player_level':\n        return (userStats.playerLevel || 0) >= requirement.target;\n      case 'total_xp':\n        return (userStats.totalXP || 0) >= requirement.target;\n      case 'completion_percentage':\n        return (userStats.completionPercentage || 0) >= requirement.target;\n      default:\n        console.warn(`Unknown requirement type: ${requirement.type}`);\n        return false;\n    }\n  }\n\n  // Trigger achievement notification with enhanced styling\n  triggerAchievementNotification(achievement) {\n    const tier = tierInfo[achievement.tier];\n    console.log(`ğŸ‰ ${tier.emoji} ${achievement.name} UNLOCKED! (+${achievement.xpReward} XP)`);\n\n    // Dispatch custom event for UI components\n    window.dispatchEvent(new CustomEvent('achievementUnlocked', {\n      detail: {\n        achievement,\n        tier,\n        timestamp: new Date().toISOString()\n      }\n    }));\n\n    // Play achievement sound (if available)\n    this.playAchievementSound(achievement.tier);\n  }\n\n  // Play achievement sound based on tier\n  playAchievementSound(tier) {\n    try {\n      const audio = new Audio(`/sounds/achievement_${tier}.mp3`);\n      audio.volume = 0.3;\n      audio.play().catch(() => {\n        console.log(`Sound not found for tier: ${tier}`);\n      });\n    } catch (error) {\n      console.error('Error playing achievement sound:', error);\n    }\n  }\n\n  // Get achievement progress\n  getAchievementProgress(achievementId, userStats) {\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement || this.isUnlocked(achievementId)) return 1;\n    const req = achievement.requirement;\n    let current = 0;\n    let target = req.target || 1;\n    switch (req.type) {\n      case 'note_count':\n        current = userStats.totalNotes || 0;\n        break;\n      case 'word_count':\n        current = userStats.totalWords || 0;\n        break;\n      case 'task_count':\n        current = userStats.totalTasks || 0;\n        break;\n      case 'session_count':\n        current = userStats.totalSessions || 0;\n        break;\n      case 'total_time':\n        current = userStats.totalFocusTime || 0;\n        break;\n      case 'unique_tags':\n        current = userStats.uniqueTags || 0;\n        break;\n      case 'streak':\n      case 'completion_streak':\n      case 'daily_streak':\n        current = userStats[req.type === 'streak' ? 'noteStreak' : req.type === 'completion_streak' ? 'taskStreak' : 'focusStreak'] || 0;\n        break;\n      default:\n        return 0;\n    }\n    return Math.min(current / target, 1);\n  }\n\n  // Get user's next achievements to unlock\n  getNextAchievements(userStats, limit = 5) {\n    return allAchievements.filter(achievement => !this.isUnlocked(achievement.id)).map(achievement => ({\n      ...achievement,\n      progress: this.getAchievementProgress(achievement.id, userStats)\n    })).sort((a, b) => b.progress - a.progress).slice(0, limit);\n  }\n\n  // Get recently unlocked achievements\n  getRecentlyUnlocked(days = 7) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    return this.unlockedAchievements.filter(achievement => new Date(achievement.unlockedAt) >= cutoffDate).sort((a, b) => new Date(b.unlockedAt) - new Date(a.unlockedAt));\n  }\n\n  // Get stats summary\n  getStats() {\n    const total = allAchievements.length;\n    const unlocked = this.unlockedAchievements.length;\n    const byTier = {\n      common: this.unlockedAchievements.filter(a => a.tier === 'common').length,\n      uncommon: this.unlockedAchievements.filter(a => a.tier === 'uncommon').length,\n      rare: this.unlockedAchievements.filter(a => a.tier === 'rare').length,\n      legendary: this.unlockedAchievements.filter(a => a.tier === 'legendary').length\n    };\n    const totalXP = this.unlockedAchievements.reduce((sum, achievement) => sum + achievement.xpReward, 0);\n    return {\n      total,\n      unlocked,\n      percentage: Math.round(unlocked / total * 100),\n      byTier,\n      totalXP,\n      recentUnlocks: this.getRecentlyUnlocked(7).length\n    };\n  }\n\n  // Force unlock an achievement (for testing)\n  forceUnlock(achievementId) {\n    console.log(`ğŸ§ª FORCE UNLOCK: ${achievementId}`);\n\n    // Get current unlocked achievements and filter out nulls\n    const currentUnlocked = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]').filter(id => id !== null && id !== undefined);\n    if (!currentUnlocked.includes(achievementId)) {\n      const newUnlocked = [...currentUnlocked, achievementId];\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n\n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData[achievementId] = {\n        unlockedAt: new Date().toISOString(),\n        progress: 100\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      console.log(`âœ… Force unlocked: ${achievementId}`);\n\n      // Sync with backend\n      this.syncAchievementWithBackend(achievementId);\n\n      // Trigger update event\n      window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n    } else {\n      console.log(`âš ï¸ ${achievementId} already unlocked`);\n    }\n  }\n\n  // Reset all achievements (for testing)\n  resetAchievements() {\n    console.log('ğŸ§ª RESET: Clearing all achievements');\n    localStorage.removeItem('unlockedAchievements');\n    localStorage.removeItem('achievementData');\n    window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n  }\n\n  // Clean up localStorage (remove null values)\n  cleanupLocalStorage() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]').filter(id => id !== null && id !== undefined);\n    localStorage.setItem('unlockedAchievements', JSON.stringify(unlockedIds));\n    console.log('ğŸ§¹ Cleaned up localStorage, removed null values');\n  }\n\n  // Get achievement with unlock date\n  getAchievementWithUnlockDate(achievement) {\n    const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n    const unlockDates = achievementData.unlockDates || {};\n    return {\n      ...achievement,\n      unlockedAt: unlockDates[achievement.id] || null\n    };\n  }\n\n  // Get unlocked achievements\n  getUnlockedAchievements() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]').filter(id => id !== null && id !== undefined);\n    return unlockedIds.map(id => {\n      const achievement = allAchievements.find(a => a.id === id);\n      if (!achievement) {\n        console.warn(`âš ï¸ Achievement with id ${id} not found`);\n        return null;\n      }\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      const data = achievementData[id] || {};\n      return {\n        ...achievement,\n        unlockedAt: data.unlockedAt || new Date().toISOString(),\n        progress: data.progress || 100\n      };\n    }).filter(Boolean);\n  }\n\n  // Recalculate and unlock all achievements based on current user stats\n  async recalculateAchievements(userStats) {\n    console.log('ğŸ”„ RECALCULATING ACHIEVEMENTS based on current stats:', userStats);\n    const previouslyUnlocked = this.getUnlockedAchievements().map(a => a.id);\n    const newlyUnlocked = [];\n\n    // Check every achievement against current stats\n    allAchievements.forEach(achievement => {\n      if (!previouslyUnlocked.includes(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          console.log(`ğŸ† Should unlock: ${achievement.id} - ${achievement.name}`);\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        } else {\n          // Show progress for close achievements\n          const progress = this.getAchievementProgress(achievement.id, userStats);\n          if (progress > 0.5) {\n            console.log(`ğŸ“ˆ Close to unlocking: ${achievement.id} - ${Math.round(progress * 100)}%`);\n          }\n        }\n      }\n    });\n    console.log(`âœ… Recalculation complete! Unlocked ${newlyUnlocked.length} new achievements:`, newlyUnlocked.map(a => a.name));\n    return newlyUnlocked;\n  }\n\n  // Enhanced data gathering that checks multiple possible storage keys\n  async getCurrentUserStats() {\n    console.log('ğŸ“Š GATHERING USER STATS FROM ALL SOURCES...');\n    try {\n      const username = 'user';\n      const [notesResponse, tasksResponse, focusEntriesResponse] = await Promise.all([fetch(`http://localhost:8080/api/notes?username=${username}`).catch(() => ({\n        ok: false\n      })), fetch(`http://localhost:8080/api/tasks?username=${username}`).catch(() => ({\n        ok: false\n      })),\n      // âœ… Add tasks\n      fetch(`http://localhost:8080/api/focus/entries?username=${username}`).catch(() => ({\n        ok: false\n      })) // âœ… Use entries\n      ]);\n      const notes = notesResponse.ok ? await notesResponse.json() : [];\n      const tasks = tasksResponse.ok ? await tasksResponse.json() : []; // âœ… Get real tasks\n      const focusSessions = focusEntriesResponse.ok ? await focusEntriesResponse.json() : [];\n      console.log(`ğŸ“ Found notes from backend: ${notes.length} notes`);\n      console.log(`âœ… Found tasks from backend: ${tasks.length} tasks`); // âœ… Real task count\n      console.log(`â±ï¸ Found focus entries from backend: ${focusSessions.length} sessions`);\n\n      // Calculate comprehensive stats\n      const stats = {\n        // Notes stats (from backend)\n        totalNotes: notes.length,\n        totalWords: this.calculateTotalWords(notes),\n        uniqueTags: this.calculateUniqueTags(notes),\n        notesToday: this.calculateNotesToday(notes),\n        noteStreak: this.calculateNoteStreak(notes),\n        maxWordsInNote: this.calculateMaxWords(notes),\n        maxTagsInNote: this.calculateMaxTags(notes),\n        maxNoteEdits: this.calculateMaxEditsInNote(notes),\n        totalEdits: this.calculateTotalEdits(notes),\n        notesThisWeek: this.calculateNotesThisWeek(notes),\n        weekendNotes: this.calculateWeekendNotes(notes),\n        // Tasks stats (from backend) âœ… Now will work!\n        totalTasks: tasks.length,\n        completedTasks: this.calculateCompletedTasks(tasks),\n        tasksToday: this.calculateTasksToday(tasks),\n        taskStreak: this.calculateTaskStreak(tasks),\n        highPriorityTasks: this.calculateHighPriorityTasks(tasks),\n        earlyCompletions: this.calculateEarlyCompletions(tasks),\n        tasksThisWeek: this.calculateTasksThisWeek(tasks),\n        tasksThisMonth: this.calculateTasksThisMonth(tasks),\n        taskCategories: this.calculateTaskCategories(tasks),\n        priorityUsage: this.calculatePriorityUsage(tasks),\n        dueDateUsage: this.calculateDueDateUsage(tasks),\n        // Focus stats (from backend)\n        totalSessions: focusSessions.length,\n        totalFocusTime: this.calculateTotalFocusTime(focusSessions),\n        totalFocusMinutes: this.calculateTotalFocusMinutes(focusSessions),\n        maxSessionDuration: this.calculateMaxSessionDuration(focusSessions),\n        focusStreak: this.calculateFocusStreak(focusSessions),\n        averageSessionLength: this.calculateAverageSessionLength(focusSessions),\n        categoryTime: this.calculateCategoryTime(focusSessions),\n        categorySessions: this.calculateCategorySessions(focusSessions),\n        uniqueCategories: this.calculateUniqueCategories(focusSessions),\n        // Combined stats\n        daysActive: this.calculateDaysActive(notes, tasks, focusSessions),\n        currentStreak: this.calculateCurrentStreak(notes, tasks, focusSessions),\n        completedAchievements: this.getUnlockedAchievements().length\n      };\n      console.log('ğŸ“Š CALCULATED STATS:', stats);\n      return stats;\n    } catch (error) {\n      console.error('âŒ Error fetching user stats from backend:', error);\n\n      // Fallback to localStorage\n      console.log('ğŸ”„ Falling back to localStorage...');\n      const notes = JSON.parse(localStorage.getItem('notes') || '[]');\n      const tasks = JSON.parse(localStorage.getItem('tasks') || '[]');\n      const focusSessions = JSON.parse(localStorage.getItem('focusSessions') || '[]');\n      console.log(`ğŸ“ Found notes data in localStorage: ${notes.length} notes`);\n      console.log(`âœ… Found tasks data in localStorage: ${tasks.length} tasks`);\n      console.log(`â±ï¸ Found focus sessions data in localStorage: ${focusSessions.length} sessions`);\n\n      // ... same stats calculation with fallback data ...\n      return this.calculateStatsFromLocalStorage(notes, tasks, focusSessions);\n    }\n  }\n\n  // Helper calculation methods\n  calculateTotalWords(notes) {\n    return notes.reduce((total, note) => {\n      const content = note.content || note.text || note.body || '';\n      const words = content.split(/\\s+/).filter(word => word.length > 0);\n      return total + words.length;\n    }, 0);\n  }\n  calculateUniqueTags(notes) {\n    const allTags = new Set();\n    notes.forEach(note => {\n      const tags = note.tags || note.categories || [];\n      if (Array.isArray(tags)) {\n        tags.forEach(tag => allTags.add(tag));\n      }\n    });\n    return allTags.size;\n  }\n  calculateNotesToday(notes) {\n    const today = new Date().toDateString();\n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date).toDateString() === today;\n    }).length;\n  }\n  calculateNoteStreak(notes) {\n    if (notes.length === 0) return 0;\n    const notesByDate = {};\n    notes.forEach(note => {\n      const date = note.createdAt || note.created || note.date;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        notesByDate[dateStr] = true;\n      }\n    });\n    const sortedDates = Object.keys(notesByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    for (let i = 0; i < sortedDates.length; i++) {\n      const noteDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - noteDate) / (1000 * 60 * 60 * 24));\n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    return streak;\n  }\n  calculateMaxWords(notes) {\n    return Math.max(...notes.map(note => {\n      const content = note.content || note.text || note.body || '';\n      return content.split(/\\s+/).filter(word => word.length > 0).length;\n    }), 0);\n  }\n  calculateMaxTags(notes) {\n    return Math.max(...notes.map(note => {\n      const tags = note.tags || note.categories || [];\n      return Array.isArray(tags) ? tags.length : 0;\n    }), 0);\n  }\n  calculateMaxEditsInNote(notes) {\n    return Math.max(...notes.map(note => {\n      return note.editCount || note.edits || 1;\n    }), 0);\n  }\n  calculateTotalEdits(notes) {\n    return notes.reduce((total, note) => {\n      return total + (note.editCount || note.edits || 1);\n    }, 0);\n  }\n  calculateNotesThisWeek(notes) {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date) >= oneWeekAgo;\n    }).length;\n  }\n  calculateWeekendNotes(notes) {\n    return notes.filter(note => {\n      const date = new Date(note.createdAt || note.created || note.date);\n      const dayOfWeek = date.getDay();\n      return dayOfWeek === 0 || dayOfWeek === 6; // Sunday = 0, Saturday = 6\n    }).length;\n  }\n  calculateCompletedTasks(tasks) {\n    return tasks.filter(task => task.completed || task.done || task.status === 'completed' || task.status === 'done').length;\n  }\n  calculateTasksToday(tasks) {\n    const today = new Date().toDateString();\n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created || task.date;\n      return date && new Date(date).toDateString() === today;\n    }).length;\n  }\n  calculateTaskStreak(tasks) {\n    const completedTasks = tasks.filter(task => task.completed || task.done || task.status === 'completed');\n    if (completedTasks.length === 0) return 0;\n    const tasksByDate = {};\n    completedTasks.forEach(task => {\n      const date = task.completedAt || task.createdAt || task.created || task.date;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        tasksByDate[dateStr] = true;\n      }\n    });\n    const sortedDates = Object.keys(tasksByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    for (let i = 0; i < sortedDates.length; i++) {\n      const taskDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - taskDate) / (1000 * 60 * 60 * 24));\n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    return streak;\n  }\n  calculateHighPriorityTasks(tasks) {\n    return tasks.filter(task => (task.completed || task.done || task.status === 'completed') && (task.priority === 'high' || task.priority === 'urgent' || task.priority === 3)).length;\n  }\n  calculateEarlyCompletions(tasks) {\n    return tasks.filter(task => {\n      if (!task.completed && !task.done) return false;\n      const completedDate = new Date(task.completedAt || task.created);\n      const dueDate = new Date(task.dueDate || task.due || task.deadline);\n      return dueDate && completedDate < dueDate;\n    }).length;\n  }\n  calculateTasksThisWeek(tasks) {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created || task.date;\n      return date && new Date(date) >= oneWeekAgo;\n    }).length;\n  }\n  calculateTasksThisMonth(tasks) {\n    const oneMonthAgo = new Date();\n    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);\n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created;\n      return date && new Date(date) >= oneMonthAgo;\n    }).length;\n  }\n  calculateTaskCategories(tasks) {\n    const categories = new Set();\n    tasks.forEach(task => {\n      if (task.category) {\n        categories.add(task.category);\n      }\n    });\n    return categories.size;\n  }\n  calculatePriorityUsage(tasks) {\n    return tasks.filter(task => task.priority && task.priority !== 'none').length;\n  }\n  calculateDueDateUsage(tasks) {\n    return tasks.filter(task => task.dueDate || task.due || task.deadline).length;\n  }\n  calculateTotalFocusTime(sessions) {\n    return sessions.reduce((total, session) => {\n      return total + (session.timeSpent || session.duration || session.time || 0);\n    }, 0);\n  }\n  calculateMaxSessionDuration(sessions) {\n    return Math.max(...sessions.map(session => session.timeSpent || session.duration || session.time || 0), 0);\n  }\n  calculateFocusStreak(sessions) {\n    if (sessions.length === 0) return 0;\n    const sessionsByDate = {};\n    sessions.forEach(session => {\n      const date = session.createdAt || session.date || session.timestamp;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        sessionsByDate[dateStr] = true;\n      }\n    });\n    const sortedDates = Object.keys(sessionsByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    for (let i = 0; i < sortedDates.length; i++) {\n      const sessionDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - sessionDate) / (1000 * 60 * 60 * 24));\n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    return streak;\n  }\n  calculateAverageSessionLength(sessions) {\n    if (sessions.length === 0) return 0;\n    const totalTime = this.calculateTotalFocusTime(sessions);\n    return Math.round(totalTime / sessions.length);\n  }\n  calculateTotalFocusMinutes(sessions) {\n    return sessions.reduce((total, session) => {\n      const duration = session.duration || session.time || session.minutes || 0;\n      // Convert to minutes if it's in seconds\n      return total + (duration > 300 ? Math.round(duration / 60) : duration);\n    }, 0);\n  }\n  calculateCategoryTime(sessions) {\n    const categoryTime = {};\n    sessions.forEach(session => {\n      const category = session.category || 'general';\n      const time = session.timeSpent || session.duration || session.time || 0;\n      categoryTime[category] = (categoryTime[category] || 0) + time;\n    });\n    return categoryTime;\n  }\n  calculateCategorySessions(sessions) {\n    const categorySessions = {};\n    sessions.forEach(session => {\n      const category = session.category || 'general';\n      categorySessions[category] = (categorySessions[category] || 0) + 1;\n    });\n    return categorySessions;\n  }\n  calculateUniqueCategories(sessions) {\n    const categories = new Set();\n    sessions.forEach(session => {\n      if (session.category) {\n        categories.add(session.category);\n      }\n    });\n    return categories.size;\n  }\n  calculateSessionsByDuration(sessions) {\n    const sessionsByDuration = {};\n    sessions.forEach(session => {\n      const duration = session.timeSpent || session.duration || session.time || 0;\n      sessionsByDuration[duration] = (sessionsByDuration[duration] || 0) + 1;\n    });\n    return sessionsByDuration;\n  }\n\n  // Override the total focus time calculation for your data structure\n  calculateTotalFocusTime(sessions) {\n    return sessions.reduce((total, session) => {\n      return total + (session.timeSpent || session.duration || session.time || session.minutes || 0);\n    }, 0);\n  }\n\n  // Override max session duration for your data structure\n  calculateMaxSessionDuration(sessions) {\n    return Math.max(...sessions.map(session => session.timeSpent || session.duration || session.time || session.minutes || 0), 0);\n  }\n  calculateDaysActive(notes, tasks, sessions) {\n    const allDates = new Set();\n    [...notes, ...tasks, ...sessions].forEach(item => {\n      const date = item.createdAt || item.created || item.date || item.timestamp;\n      if (date) {\n        allDates.add(new Date(date).toDateString());\n      }\n    });\n    return allDates.size;\n  }\n  calculateCurrentStreak(notes, tasks, sessions) {\n    // Combined activity streak\n    const allDates = new Set();\n    [...notes, ...tasks, ...sessions].forEach(item => {\n      const date = item.createdAt || item.created || item.date || item.timestamp;\n      if (date) {\n        allDates.add(new Date(date).toDateString());\n      }\n    });\n    const sortedDates = Array.from(allDates).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    for (let i = 0; i < sortedDates.length; i++) {\n      const activityDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - activityDate) / (1000 * 60 * 60 * 24));\n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    return streak;\n  }\n}\nexport const achievementService = new AchievementService();\nexport default achievementService;","map":{"version":3,"names":["allAchievements","tierInfo","AchievementService","constructor","unlockedAchievements","loadUnlockedAchievements","listeners","saved","localStorage","getItem","JSON","parse","saveUnlockedAchievements","setItem","stringify","addEventListener","callback","push","removeEventListener","filter","listener","notifyListeners","achievement","forEach","isUnlocked","achievementId","some","a","id","unlockAchievement","find","unlockedAchievement","unlockedAt","Date","toISOString","syncAchievementWithBackend","triggerAchievementNotification","trackAchievementUnlock","response","fetch","method","headers","body","username","ok","console","log","warn","error","getUnlockedAchievements","unlockedIds","map","includes","newUnlockedIds","achievementData","unlockDates","checkAchievements","userStats","newlyUnlocked","meetsRequirement","requirement","type","totalSessions","target","totalFocusTime","totalFocusMinutes","maxSessionDuration","categoryTime","category","allCategoryTime","totalTimeAllCategories","Object","values","reduce","sum","time","uniqueCategories","totalNotes","totalWords","uniqueTags","totalEdits","maxNoteEdits","maxEditsInNote","maxWordsInNote","maxTagsInNote","weekendNotes","notesThisWeek","noteStreak","timeRangeNotes","speedWriting","completedTasks","totalTasks","tasksToday","tasksThisWeek","tasksThisMonth","highPriorityTasks","earlyCompletions","taskStreak","taskCategories","priorityUsage","dueDateUsage","ratio","morningCompletions","eveningCompletions","activeLists","urgentTasks","totalWithDueDate","tasksWithDueDate","onTimeCompletions","tasks","rate","maxConcurrentTasks","sessionDurationRange","breakSessions","timeBefore","timeAfter","pomodoroSessions","currentStreak","dailyStreak","categorySessions","durationVariety","categoryTimeStats","longSessions","monthlyFocusSessions","timeVariety","dailyCombo","weeklyCombo","completedAchievements","categoryMastery","superCombo","weekendActivity","lateNightActivity","earlyMorningActivity","comboStreak","categoryCompletion","dailyActivityStreak","featureUsage","dailyActivityCount","monthlyActivityCount","playerLevel","totalXP","completionPercentage","tier","emoji","name","xpReward","window","dispatchEvent","CustomEvent","detail","timestamp","playAchievementSound","audio","Audio","volume","play","catch","getAchievementProgress","req","current","Math","min","getNextAchievements","limit","progress","sort","b","slice","getRecentlyUnlocked","days","cutoffDate","setDate","getDate","getStats","total","length","unlocked","byTier","common","uncommon","rare","legendary","percentage","round","recentUnlocks","forceUnlock","currentUnlocked","undefined","newUnlocked","resetAchievements","removeItem","cleanupLocalStorage","getAchievementWithUnlockDate","data","Boolean","recalculateAchievements","previouslyUnlocked","getCurrentUserStats","notesResponse","tasksResponse","focusEntriesResponse","Promise","all","notes","json","focusSessions","stats","calculateTotalWords","calculateUniqueTags","notesToday","calculateNotesToday","calculateNoteStreak","calculateMaxWords","calculateMaxTags","calculateMaxEditsInNote","calculateTotalEdits","calculateNotesThisWeek","calculateWeekendNotes","calculateCompletedTasks","calculateTasksToday","calculateTaskStreak","calculateHighPriorityTasks","calculateEarlyCompletions","calculateTasksThisWeek","calculateTasksThisMonth","calculateTaskCategories","calculatePriorityUsage","calculateDueDateUsage","calculateTotalFocusTime","calculateTotalFocusMinutes","calculateMaxSessionDuration","focusStreak","calculateFocusStreak","averageSessionLength","calculateAverageSessionLength","calculateCategoryTime","calculateCategorySessions","calculateUniqueCategories","daysActive","calculateDaysActive","calculateCurrentStreak","calculateStatsFromLocalStorage","note","content","text","words","split","word","allTags","Set","tags","categories","Array","isArray","tag","add","size","today","toDateString","date","createdAt","created","notesByDate","dateStr","sortedDates","keys","streak","currentDate","i","noteDate","diffDays","floor","max","editCount","edits","oneWeekAgo","dayOfWeek","getDay","task","completed","done","status","completedAt","tasksByDate","taskDate","priority","completedDate","dueDate","due","deadline","oneMonthAgo","setMonth","getMonth","sessions","session","timeSpent","duration","sessionsByDate","sessionDate","totalTime","minutes","calculateSessionsByDuration","sessionsByDuration","allDates","item","from","activityDate","achievementService"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/services/achievementService.js"],"sourcesContent":["import { allAchievements, tierInfo } from '../data/achievements';\n\nclass AchievementService {\n  constructor() {\n    this.unlockedAchievements = this.loadUnlockedAchievements();\n    this.listeners = [];\n  }\n\n  // Load unlocked achievements from localStorage\n  loadUnlockedAchievements() {\n    const saved = localStorage.getItem('unlockedAchievements');\n    return saved ? JSON.parse(saved) : [];\n  }\n\n  // Save unlocked achievements to localStorage\n  saveUnlockedAchievements() {\n    localStorage.setItem('unlockedAchievements', JSON.stringify(this.unlockedAchievements));\n  }\n\n  // Add event listener for achievement unlocks\n  addEventListener(callback) {\n    this.listeners.push(callback);\n  }\n\n  // Remove event listener\n  removeEventListener(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  // Notify listeners of achievement unlock\n  notifyListeners(achievement) {\n    this.listeners.forEach(callback => callback(achievement));\n  }\n\n  // Check if achievement is unlocked\n  isUnlocked(achievementId) {\n    return this.unlockedAchievements.some(a => a.id === achievementId);\n  }\n\n  // Unlock achievement\n  unlockAchievement(achievementId) {\n    if (this.isUnlocked(achievementId)) return false;\n    \n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement) return false;\n\n    const unlockedAchievement = {\n      ...achievement,\n      unlockedAt: new Date().toISOString()\n    };\n\n    this.unlockedAchievements.push(unlockedAchievement);\n    this.saveUnlockedAchievements();\n    \n    // âœ… Sync with backend immediately\n    this.syncAchievementWithBackend(achievementId);\n    \n    // Trigger achievement notification\n    this.triggerAchievementNotification(achievement);\n    this.notifyListeners(achievement);\n    \n    // Track when achievements are unlocked\n    this.trackAchievementUnlock(achievementId);\n    \n    return true;\n  }\n\n  // Sync achievement with backend\n  async syncAchievementWithBackend(achievementId) {\n    try {\n      const response = await fetch('http://localhost:8080/api/player/achievements/unlock', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          username: 'Jroc_182', // Changed from 'user'\n          achievementId: achievementId\n        }),\n      });\n      \n      if (response.ok) {\n        console.log(`âœ… Synced ${achievementId} with backend`);\n      } else {\n        console.warn(`âš ï¸ Failed to sync ${achievementId} with backend`);\n      }\n    } catch (error) {\n      console.error(`âŒ Error syncing ${achievementId}:`, error);\n    }\n  }\n\n  // Track when achievements are unlocked\n  trackAchievementUnlock(achievementId) {\n    const unlockedAchievements = this.getUnlockedAchievements();\n    \n    // âœ… FIX: Only store achievement IDs, not full objects\n    const unlockedIds = unlockedAchievements.map(a => a.id || a);\n    \n    if (!unlockedIds.includes(achievementId)) {\n      const newUnlockedIds = [...unlockedIds, achievementId]; // âœ… Store ID only\n      \n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData.unlockDates = {\n        ...achievementData.unlockDates,\n        [achievementId]: new Date().toISOString()\n      };\n      \n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlockedIds)); // âœ… Store IDs only\n    }\n  }\n\n  // Check achievements based on user stats\n  checkAchievements(userStats) {\n    const newlyUnlocked = [];\n\n    allAchievements.forEach(achievement => {\n      if (!this.isUnlocked(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        }\n      }\n    });\n\n    return newlyUnlocked;\n  }\n\n  // Enhanced requirement checking\n  meetsRequirement(requirement, userStats) {\n    switch (requirement.type) {\n      // Focus/Session requirements (existing)\n      case 'session_count':\n        return (userStats.totalSessions || 0) >= requirement.target;\n      \n      case 'total_time':\n        return (userStats.totalFocusTime || userStats.totalFocusMinutes || 0) >= requirement.target;\n      \n      case 'max_session':\n        return (userStats.maxSessionDuration || 0) >= requirement.target;\n      \n      case 'category_focus':\n        const categoryTime = userStats.categoryTime || {};\n        return (categoryTime[requirement.category] || 0) >= requirement.target;\n      \n      case 'all_categories_time':\n        const allCategoryTime = userStats.categoryTime || {};\n        const totalTimeAllCategories = Object.values(allCategoryTime).reduce((sum, time) => sum + time, 0);\n        return totalTimeAllCategories >= requirement.target;\n      \n      case 'unique_categories':\n        return (userStats.uniqueCategories || 0) >= requirement.target;\n\n      // NOTE REQUIREMENTS\n      case 'note_count':\n        return (userStats.totalNotes || 0) >= requirement.target;\n      \n      case 'word_count':\n        return (userStats.totalWords || 0) >= requirement.target;\n      \n      case 'tag_count':\n      case 'unique_tags':\n        return (userStats.uniqueTags || 0) >= requirement.target;\n      \n      case 'note_edits':\n        return (userStats.totalEdits || 0) >= requirement.target;\n      \n      case 'single_note_edits':\n        return (userStats.maxNoteEdits || userStats.maxEditsInNote || 0) >= requirement.target;\n      \n      case 'single_note_words':\n        return (userStats.maxWordsInNote || 0) >= requirement.target;\n      \n      case 'single_note_tags':\n        return (userStats.maxTagsInNote || 0) >= requirement.target;\n      \n      case 'weekend_notes':\n        return (userStats.weekendNotes || 0) >= requirement.target;\n      \n      case 'weekly_notes':\n        return (userStats.notesThisWeek || 0) >= requirement.target;\n      \n      case 'streak':\n        return (userStats.noteStreak || 0) >= requirement.target;\n      \n      case 'time_range':\n        return (userStats.timeRangeNotes || 0) >= 1;\n      \n      case 'speed_writing':\n        return (userStats.speedWriting || 0) >= requirement.target;\n\n      // TASK REQUIREMENTS\n      case 'task_count':\n        return (userStats.completedTasks || 0) >= requirement.target;\n      \n      case 'tasks_created':\n        return (userStats.totalTasks || 0) >= requirement.target;\n      \n      case 'daily_tasks':\n        return (userStats.tasksToday || 0) >= requirement.target;\n      \n      case 'weekly_tasks':\n        return (userStats.tasksThisWeek || 0) >= requirement.target;\n      \n      case 'monthly_tasks':\n        return (userStats.tasksThisMonth || 0) >= requirement.target;\n      \n      case 'high_priority_tasks':\n        return (userStats.highPriorityTasks || 0) >= requirement.target;\n      \n      case 'early_completions':\n        return (userStats.earlyCompletions || 0) >= requirement.target;\n      \n      case 'completion_streak':\n        return (userStats.taskStreak || 0) >= requirement.target;\n      \n      case 'task_categories':\n        return (userStats.taskCategories || 0) >= requirement.target;\n      \n      case 'priority_usage':\n        return (userStats.priorityUsage || 0) >= requirement.target;\n      \n      case 'due_date_usage':\n        return (userStats.dueDateUsage || 0) >= requirement.target;\n      \n      case 'completion_ratio':\n        const totalTasks = userStats.totalTasks || 0;\n        const completedTasks = userStats.completedTasks || 0;\n        return totalTasks > 0 && (completedTasks / totalTasks) >= requirement.ratio;\n      \n      case 'morning_completions':\n        return (userStats.morningCompletions || 0) >= requirement.target;\n      \n      case 'evening_completions':\n        return (userStats.eveningCompletions || 0) >= requirement.target;\n      \n      case 'active_lists':\n        return (userStats.activeLists || 0) >= requirement.target;\n      \n      case 'urgent_tasks':\n        return (userStats.urgentTasks || 0) >= requirement.target;\n      \n      case 'ontime_rate':\n        const totalWithDueDate = userStats.tasksWithDueDate || 0;\n        const onTimeCompletions = userStats.onTimeCompletions || 0;\n        return totalWithDueDate >= requirement.tasks && \n               (onTimeCompletions / totalWithDueDate) >= requirement.rate;\n      \n      case 'concurrent_tasks':\n        return (userStats.maxConcurrentTasks || 0) >= requirement.target;\n\n      // FOCUS/SESSION REQUIREMENTS (additional)\n      case 'session_duration_range':\n        return (userStats.sessionDurationRange || 0) >= 1;\n      \n      case 'break_session':\n        return (userStats.breakSessions || 0) >= requirement.target;\n      \n      case 'time_before':\n        return (userStats.timeBefore || 0) >= requirement.target;\n      \n      case 'time_after':\n        return (userStats.timeAfter || 0) >= requirement.target;\n      \n      case 'pomodoro_count':\n        return (userStats.pomodoroSessions || 0) >= requirement.target;\n      \n      case 'daily_streak':\n        return (userStats.currentStreak || userStats.dailyStreak || 0) >= requirement.target;\n      \n      case 'category_sessions':\n        const categorySessions = userStats.categorySessions || {};\n        return (categorySessions[requirement.category] || 0) >= requirement.target;\n      \n      case 'duration_variety':\n        return (userStats.durationVariety || 0) >= requirement.target;\n      \n      case 'category_time':\n        const categoryTimeStats = userStats.categoryTime || {};\n        return (categoryTimeStats[requirement.category] || 0) >= requirement.target;\n      \n      case 'long_sessions':\n        return (userStats.longSessions || 0) >= requirement.target;\n      \n      case 'monthly_sessions':\n        return (userStats.monthlyFocusSessions || 0) >= requirement.target;\n      \n      case 'time_variety':\n        return (userStats.timeVariety || 0) >= requirement.target;\n\n      // COMBO/SPECIAL REQUIREMENTS\n      case 'daily_combo':\n        return (userStats.dailyCombo || false);\n      \n      case 'weekly_combo':\n        return (userStats.weeklyCombo || false);\n      \n      case 'achievement_count':\n        return (userStats.completedAchievements || 0) >= requirement.target;\n      \n      case 'activity_consistency':\n        return (userStats.currentStreak || 0) >= requirement.target;\n\n      case 'category_mastery':\n        return (userStats.categoryMastery || 0) >= requirement.target;\n      \n      case 'super_combo':\n        return (userStats.superCombo || false);\n      \n      case 'weekend_activity':\n        return (userStats.weekendActivity || 0) >= requirement.target;\n      \n      case 'late_night_activity':\n        return (userStats.lateNightActivity || 0) >= requirement.target;\n      \n      case 'early_morning_activity':\n        return (userStats.earlyMorningActivity || 0) >= requirement.target;\n      \n      case 'combo_streak':\n        return (userStats.comboStreak || 0) >= requirement.target;\n      \n      case 'category_completion':\n        return (userStats.categoryCompletion || 0) >= requirement.target;\n      \n      case 'daily_activity_streak':\n        return (userStats.dailyActivityStreak || 0) >= requirement.target;\n      \n      case 'feature_usage':\n        return (userStats.featureUsage || 0) >= requirement.target;\n      \n      case 'daily_activity_count':\n        return (userStats.dailyActivityCount || 0) >= requirement.target;\n      \n      case 'monthly_activity_count':\n        return (userStats.monthlyActivityCount || 0) >= requirement.target;\n      \n      case 'player_level':\n        return (userStats.playerLevel || 0) >= requirement.target;\n      \n      case 'total_xp':\n        return (userStats.totalXP || 0) >= requirement.target;\n      \n      case 'completion_percentage':\n        return (userStats.completionPercentage || 0) >= requirement.target;\n      \n      default:\n        console.warn(`Unknown requirement type: ${requirement.type}`);\n        return false;\n    }\n  }\n\n  // Trigger achievement notification with enhanced styling\n  triggerAchievementNotification(achievement) {\n    const tier = tierInfo[achievement.tier];\n    \n    console.log(`ğŸ‰ ${tier.emoji} ${achievement.name} UNLOCKED! (+${achievement.xpReward} XP)`);\n    \n    // Dispatch custom event for UI components\n    window.dispatchEvent(new CustomEvent('achievementUnlocked', {\n      detail: {\n        achievement,\n        tier,\n        timestamp: new Date().toISOString()\n      }\n    }));\n\n    // Play achievement sound (if available)\n    this.playAchievementSound(achievement.tier);\n  }\n\n  // Play achievement sound based on tier\n  playAchievementSound(tier) {\n    try {\n      const audio = new Audio(`/sounds/achievement_${tier}.mp3`);\n      audio.volume = 0.3;\n      audio.play().catch(() => {\n        console.log(`Sound not found for tier: ${tier}`);\n      });\n    } catch (error) {\n      console.error('Error playing achievement sound:', error);\n    }\n  }\n\n  // Get achievement progress\n  getAchievementProgress(achievementId, userStats) {\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement || this.isUnlocked(achievementId)) return 1;\n\n    const req = achievement.requirement;\n    let current = 0;\n    let target = req.target || 1;\n\n    switch (req.type) {\n      case 'note_count':\n        current = userStats.totalNotes || 0;\n        break;\n      case 'word_count':\n        current = userStats.totalWords || 0;\n        break;\n      case 'task_count':\n        current = userStats.totalTasks || 0;\n        break;\n      case 'session_count':\n        current = userStats.totalSessions || 0;\n        break;\n      case 'total_time':\n        current = userStats.totalFocusTime || 0;\n        break;\n      case 'unique_tags':\n        current = userStats.uniqueTags || 0;\n        break;\n      case 'streak':\n      case 'completion_streak':\n      case 'daily_streak':\n        current = userStats[req.type === 'streak' ? 'noteStreak' : \n                            req.type === 'completion_streak' ? 'taskStreak' : 'focusStreak'] || 0;\n        break;\n      default:\n        return 0;\n    }\n\n    return Math.min(current / target, 1);\n  }\n\n  // Get user's next achievements to unlock\n  getNextAchievements(userStats, limit = 5) {\n    return allAchievements\n      .filter(achievement => !this.isUnlocked(achievement.id))\n      .map(achievement => ({\n        ...achievement,\n        progress: this.getAchievementProgress(achievement.id, userStats)\n      }))\n      .sort((a, b) => b.progress - a.progress)\n      .slice(0, limit);\n  }\n\n  // Get recently unlocked achievements\n  getRecentlyUnlocked(days = 7) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    \n    return this.unlockedAchievements\n      .filter(achievement => new Date(achievement.unlockedAt) >= cutoffDate)\n      .sort((a, b) => new Date(b.unlockedAt) - new Date(a.unlockedAt));\n  }\n\n  // Get stats summary\n  getStats() {\n    const total = allAchievements.length;\n    const unlocked = this.unlockedAchievements.length;\n    const byTier = {\n      common: this.unlockedAchievements.filter(a => a.tier === 'common').length,\n      uncommon: this.unlockedAchievements.filter(a => a.tier === 'uncommon').length,\n      rare: this.unlockedAchievements.filter(a => a.tier === 'rare').length,\n      legendary: this.unlockedAchievements.filter(a => a.tier === 'legendary').length\n    };\n\n    const totalXP = this.unlockedAchievements.reduce((sum, achievement) => sum + achievement.xpReward, 0);\n\n    return {\n      total,\n      unlocked,\n      percentage: Math.round((unlocked / total) * 100),\n      byTier,\n      totalXP,\n      recentUnlocks: this.getRecentlyUnlocked(7).length\n    };\n  }\n\n  // Force unlock an achievement (for testing)\n  forceUnlock(achievementId) {\n    console.log(`ğŸ§ª FORCE UNLOCK: ${achievementId}`);\n    \n    // Get current unlocked achievements and filter out nulls\n    const currentUnlocked = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]')\n      .filter(id => id !== null && id !== undefined);\n    \n    if (!currentUnlocked.includes(achievementId)) {\n      const newUnlocked = [...currentUnlocked, achievementId];\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n      \n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData[achievementId] = {\n        unlockedAt: new Date().toISOString(),\n        progress: 100\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      \n      console.log(`âœ… Force unlocked: ${achievementId}`);\n      \n      // Sync with backend\n      this.syncAchievementWithBackend(achievementId);\n      \n      // Trigger update event\n      window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n    } else {\n      console.log(`âš ï¸ ${achievementId} already unlocked`);\n    }\n  }\n\n  // Reset all achievements (for testing)\n  resetAchievements() {\n    console.log('ğŸ§ª RESET: Clearing all achievements');\n    localStorage.removeItem('unlockedAchievements');\n    localStorage.removeItem('achievementData');\n    window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n  }\n\n  // Clean up localStorage (remove null values)\n  cleanupLocalStorage() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]')\n      .filter(id => id !== null && id !== undefined);\n    \n    localStorage.setItem('unlockedAchievements', JSON.stringify(unlockedIds));\n    console.log('ğŸ§¹ Cleaned up localStorage, removed null values');\n  }\n\n  // Get achievement with unlock date\n  getAchievementWithUnlockDate(achievement) {\n    const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n    const unlockDates = achievementData.unlockDates || {};\n    \n    return {\n      ...achievement,\n      unlockedAt: unlockDates[achievement.id] || null\n    };\n  }\n\n  // Get unlocked achievements\n  getUnlockedAchievements() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]')\n      .filter(id => id !== null && id !== undefined);\n    \n    return unlockedIds.map(id => {\n      const achievement = allAchievements.find(a => a.id === id);\n      if (!achievement) {\n        console.warn(`âš ï¸ Achievement with id ${id} not found`);\n        return null;\n      }\n      \n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      const data = achievementData[id] || {};\n      \n      return {\n        ...achievement,\n        unlockedAt: data.unlockedAt || new Date().toISOString(),\n        progress: data.progress || 100\n      };\n    }).filter(Boolean);\n  }\n\n  // Recalculate and unlock all achievements based on current user stats\n  async recalculateAchievements(userStats) {\n    console.log('ğŸ”„ RECALCULATING ACHIEVEMENTS based on current stats:', userStats);\n    \n    const previouslyUnlocked = this.getUnlockedAchievements().map(a => a.id);\n    const newlyUnlocked = [];\n    \n    // Check every achievement against current stats\n    allAchievements.forEach(achievement => {\n      if (!previouslyUnlocked.includes(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          console.log(`ğŸ† Should unlock: ${achievement.id} - ${achievement.name}`);\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        } else {\n          // Show progress for close achievements\n          const progress = this.getAchievementProgress(achievement.id, userStats);\n          if (progress > 0.5) {\n            console.log(`ğŸ“ˆ Close to unlocking: ${achievement.id} - ${Math.round(progress * 100)}%`);\n          }\n        }\n      }\n    });\n    \n    console.log(`âœ… Recalculation complete! Unlocked ${newlyUnlocked.length} new achievements:`, \n      newlyUnlocked.map(a => a.name));\n    \n    return newlyUnlocked;\n  }\n\n  // Enhanced data gathering that checks multiple possible storage keys\n  async getCurrentUserStats() {\n    console.log('ğŸ“Š GATHERING USER STATS FROM ALL SOURCES...');\n    \n    try {\n      const username = 'user';\n      \n      const [notesResponse, tasksResponse, focusEntriesResponse] = await Promise.all([\n        fetch(`http://localhost:8080/api/notes?username=${username}`).catch(() => ({ ok: false })),\n        fetch(`http://localhost:8080/api/tasks?username=${username}`).catch(() => ({ ok: false })), // âœ… Add tasks\n        fetch(`http://localhost:8080/api/focus/entries?username=${username}`).catch(() => ({ ok: false })) // âœ… Use entries\n      ]);\n      \n      const notes = notesResponse.ok ? await notesResponse.json() : [];\n      const tasks = tasksResponse.ok ? await tasksResponse.json() : []; // âœ… Get real tasks\n      const focusSessions = focusEntriesResponse.ok ? await focusEntriesResponse.json() : [];\n      \n      console.log(`ğŸ“ Found notes from backend: ${notes.length} notes`);\n      console.log(`âœ… Found tasks from backend: ${tasks.length} tasks`); // âœ… Real task count\n      console.log(`â±ï¸ Found focus entries from backend: ${focusSessions.length} sessions`);\n      \n      // Calculate comprehensive stats\n      const stats = {\n        // Notes stats (from backend)\n        totalNotes: notes.length,\n        totalWords: this.calculateTotalWords(notes),\n        uniqueTags: this.calculateUniqueTags(notes),\n        notesToday: this.calculateNotesToday(notes),\n        noteStreak: this.calculateNoteStreak(notes),\n        maxWordsInNote: this.calculateMaxWords(notes),\n        maxTagsInNote: this.calculateMaxTags(notes),\n        maxNoteEdits: this.calculateMaxEditsInNote(notes),\n        totalEdits: this.calculateTotalEdits(notes),\n        notesThisWeek: this.calculateNotesThisWeek(notes),\n        weekendNotes: this.calculateWeekendNotes(notes),\n        \n        // Tasks stats (from backend) âœ… Now will work!\n        totalTasks: tasks.length,\n        completedTasks: this.calculateCompletedTasks(tasks),\n        tasksToday: this.calculateTasksToday(tasks),\n        taskStreak: this.calculateTaskStreak(tasks),\n        highPriorityTasks: this.calculateHighPriorityTasks(tasks),\n        earlyCompletions: this.calculateEarlyCompletions(tasks),\n        tasksThisWeek: this.calculateTasksThisWeek(tasks),\n        tasksThisMonth: this.calculateTasksThisMonth(tasks),\n        taskCategories: this.calculateTaskCategories(tasks),\n        priorityUsage: this.calculatePriorityUsage(tasks),\n        dueDateUsage: this.calculateDueDateUsage(tasks),\n        \n        // Focus stats (from backend)\n        totalSessions: focusSessions.length,\n        totalFocusTime: this.calculateTotalFocusTime(focusSessions),\n        totalFocusMinutes: this.calculateTotalFocusMinutes(focusSessions),\n        maxSessionDuration: this.calculateMaxSessionDuration(focusSessions),\n        focusStreak: this.calculateFocusStreak(focusSessions),\n        averageSessionLength: this.calculateAverageSessionLength(focusSessions),\n        categoryTime: this.calculateCategoryTime(focusSessions),\n        categorySessions: this.calculateCategorySessions(focusSessions),\n        uniqueCategories: this.calculateUniqueCategories(focusSessions),\n        \n        // Combined stats\n        daysActive: this.calculateDaysActive(notes, tasks, focusSessions),\n        currentStreak: this.calculateCurrentStreak(notes, tasks, focusSessions),\n        completedAchievements: this.getUnlockedAchievements().length\n      };\n      \n      console.log('ğŸ“Š CALCULATED STATS:', stats);\n      return stats;\n      \n    } catch (error) {\n      console.error('âŒ Error fetching user stats from backend:', error);\n      \n      // Fallback to localStorage\n      console.log('ğŸ”„ Falling back to localStorage...');\n      const notes = JSON.parse(localStorage.getItem('notes') || '[]');\n      const tasks = JSON.parse(localStorage.getItem('tasks') || '[]');\n      const focusSessions = JSON.parse(localStorage.getItem('focusSessions') || '[]');\n      \n      console.log(`ğŸ“ Found notes data in localStorage: ${notes.length} notes`);\n      console.log(`âœ… Found tasks data in localStorage: ${tasks.length} tasks`);\n      console.log(`â±ï¸ Found focus sessions data in localStorage: ${focusSessions.length} sessions`);\n      \n      // ... same stats calculation with fallback data ...\n      return this.calculateStatsFromLocalStorage(notes, tasks, focusSessions);\n    }\n  }\n\n  // Helper calculation methods\n  calculateTotalWords(notes) {\n    return notes.reduce((total, note) => {\n      const content = note.content || note.text || note.body || '';\n      const words = content.split(/\\s+/).filter(word => word.length > 0);\n      return total + words.length;\n    }, 0);\n  }\n\n  calculateUniqueTags(notes) {\n    const allTags = new Set();\n    notes.forEach(note => {\n      const tags = note.tags || note.categories || [];\n      if (Array.isArray(tags)) {\n        tags.forEach(tag => allTags.add(tag));\n      }\n    });\n    return allTags.size;\n  }\n\n  calculateNotesToday(notes) {\n    const today = new Date().toDateString();\n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date).toDateString() === today;\n    }).length;\n  }\n\n  calculateNoteStreak(notes) {\n    if (notes.length === 0) return 0;\n    \n    const notesByDate = {};\n    notes.forEach(note => {\n      const date = note.createdAt || note.created || note.date;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        notesByDate[dateStr] = true;\n      }\n    });\n    \n    const sortedDates = Object.keys(notesByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    \n    for (let i = 0; i < sortedDates.length; i++) {\n      const noteDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - noteDate) / (1000 * 60 * 60 * 24));\n      \n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    \n    return streak;\n  }\n\n  calculateMaxWords(notes) {\n    return Math.max(...notes.map(note => {\n      const content = note.content || note.text || note.body || '';\n      return content.split(/\\s+/).filter(word => word.length > 0).length;\n    }), 0);\n  }\n\n  calculateMaxTags(notes) {\n    return Math.max(...notes.map(note => {\n      const tags = note.tags || note.categories || [];\n      return Array.isArray(tags) ? tags.length : 0;\n    }), 0);\n  }\n\n  calculateMaxEditsInNote(notes) {\n    return Math.max(...notes.map(note => {\n      return note.editCount || note.edits || 1;\n    }), 0);\n  }\n\n  calculateTotalEdits(notes) {\n    return notes.reduce((total, note) => {\n      return total + (note.editCount || note.edits || 1);\n    }, 0);\n  }\n\n  calculateNotesThisWeek(notes) {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    \n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date) >= oneWeekAgo;\n    }).length;\n  }\n\n  calculateWeekendNotes(notes) {\n    return notes.filter(note => {\n      const date = new Date(note.createdAt || note.created || note.date);\n      const dayOfWeek = date.getDay();\n      return dayOfWeek === 0 || dayOfWeek === 6; // Sunday = 0, Saturday = 6\n    }).length;\n  }\n\n  calculateCompletedTasks(tasks) {\n    return tasks.filter(task => \n      task.completed || task.done || task.status === 'completed' || task.status === 'done'\n    ).length;\n  }\n\n  calculateTasksToday(tasks) {\n    const today = new Date().toDateString();\n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created || task.date;\n      return date && new Date(date).toDateString() === today;\n    }).length;\n  }\n\n  calculateTaskStreak(tasks) {\n    const completedTasks = tasks.filter(task => \n      task.completed || task.done || task.status === 'completed'\n    );\n    \n    if (completedTasks.length === 0) return 0;\n    \n    const tasksByDate = {};\n    completedTasks.forEach(task => {\n      const date = task.completedAt || task.createdAt || task.created || task.date;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        tasksByDate[dateStr] = true;\n      }\n    });\n    \n    const sortedDates = Object.keys(tasksByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    \n    for (let i = 0; i < sortedDates.length; i++) {\n      const taskDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - taskDate) / (1000 * 60 * 60 * 24));\n      \n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    \n    return streak;\n  }\n\n  calculateHighPriorityTasks(tasks) {\n    return tasks.filter(task => \n      (task.completed || task.done || task.status === 'completed') &&\n      (task.priority === 'high' || task.priority === 'urgent' || task.priority === 3)\n    ).length;\n  }\n\n  calculateEarlyCompletions(tasks) {\n    return tasks.filter(task => {\n      if (!task.completed && !task.done) return false;\n      \n      const completedDate = new Date(task.completedAt || task.created);\n      const dueDate = new Date(task.dueDate || task.due || task.deadline);\n      \n      return dueDate && completedDate < dueDate;\n    }).length;\n  }\n\n  calculateTasksThisWeek(tasks) {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    \n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created || task.date;\n      return date && new Date(date) >= oneWeekAgo;\n    }).length;\n  }\n\n  calculateTasksThisMonth(tasks) {\n    const oneMonthAgo = new Date();\n    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);\n    \n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created;\n      return date && new Date(date) >= oneMonthAgo;\n    }).length;\n  }\n\n  calculateTaskCategories(tasks) {\n    const categories = new Set();\n    tasks.forEach(task => {\n      if (task.category) {\n        categories.add(task.category);\n      }\n    });\n    return categories.size;\n  }\n\n  calculatePriorityUsage(tasks) {\n    return tasks.filter(task => task.priority && task.priority !== 'none').length;\n  }\n\n  calculateDueDateUsage(tasks) {\n    return tasks.filter(task => task.dueDate || task.due || task.deadline).length;\n  }\n\n  calculateTotalFocusTime(sessions) {\n    return sessions.reduce((total, session) => {\n      return total + (session.timeSpent || session.duration || session.time || 0);\n    }, 0);\n  }\n\n  calculateMaxSessionDuration(sessions) {\n    return Math.max(...sessions.map(session => \n      session.timeSpent || session.duration || session.time || 0\n    ), 0);\n  }\n\n  calculateFocusStreak(sessions) {\n    if (sessions.length === 0) return 0;\n    \n    const sessionsByDate = {};\n    sessions.forEach(session => {\n      const date = session.createdAt || session.date || session.timestamp;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        sessionsByDate[dateStr] = true;\n      }\n    });\n    \n    const sortedDates = Object.keys(sessionsByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    \n    for (let i = 0; i < sortedDates.length; i++) {\n      const sessionDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - sessionDate) / (1000 * 60 * 60 * 24));\n      \n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    \n    return streak;\n  }\n\n  calculateAverageSessionLength(sessions) {\n    if (sessions.length === 0) return 0;\n    const totalTime = this.calculateTotalFocusTime(sessions);\n    return Math.round(totalTime / sessions.length);\n  }\n\n  calculateTotalFocusMinutes(sessions) {\n    return sessions.reduce((total, session) => {\n      const duration = session.duration || session.time || session.minutes || 0;\n      // Convert to minutes if it's in seconds\n      return total + (duration > 300 ? Math.round(duration / 60) : duration);\n    }, 0);\n  }\n\n  calculateCategoryTime(sessions) {\n    const categoryTime = {};\n    sessions.forEach(session => {\n      const category = session.category || 'general';\n      const time = session.timeSpent || session.duration || session.time || 0;\n      categoryTime[category] = (categoryTime[category] || 0) + time;\n    });\n    return categoryTime;\n  }\n\n  calculateCategorySessions(sessions) {\n    const categorySessions = {};\n    sessions.forEach(session => {\n      const category = session.category || 'general';\n      categorySessions[category] = (categorySessions[category] || 0) + 1;\n    });\n    return categorySessions;\n  }\n\n  calculateUniqueCategories(sessions) {\n    const categories = new Set();\n    sessions.forEach(session => {\n      if (session.category) {\n        categories.add(session.category);\n      }\n    });\n    return categories.size;\n  }\n\n  calculateSessionsByDuration(sessions) {\n    const sessionsByDuration = {};\n    sessions.forEach(session => {\n      const duration = session.timeSpent || session.duration || session.time || 0;\n      sessionsByDuration[duration] = (sessionsByDuration[duration] || 0) + 1;\n    });\n    return sessionsByDuration;\n  }\n\n  // Override the total focus time calculation for your data structure\n  calculateTotalFocusTime(sessions) {\n    return sessions.reduce((total, session) => {\n      return total + (session.timeSpent || session.duration || session.time || session.minutes || 0);\n    }, 0);\n  }\n\n  // Override max session duration for your data structure\n  calculateMaxSessionDuration(sessions) {\n    return Math.max(...sessions.map(session => \n      session.timeSpent || session.duration || session.time || session.minutes || 0\n    ), 0);\n  }\n\n  calculateDaysActive(notes, tasks, sessions) {\n    const allDates = new Set();\n    \n    [...notes, ...tasks, ...sessions].forEach(item => {\n      const date = item.createdAt || item.created || item.date || item.timestamp;\n      if (date) {\n        allDates.add(new Date(date).toDateString());\n      }\n    });\n    \n    return allDates.size;\n  }\n\n  calculateCurrentStreak(notes, tasks, sessions) {\n    // Combined activity streak\n    const allDates = new Set();\n    \n    [...notes, ...tasks, ...sessions].forEach(item => {\n      const date = item.createdAt || item.created || item.date || item.timestamp;\n      if (date) {\n        allDates.add(new Date(date).toDateString());\n      }\n    });\n    \n    const sortedDates = Array.from(allDates).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    \n    for (let i = 0; i < sortedDates.length; i++) {\n      const activityDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - activityDate) / (1000 * 60 * 60 * 24));\n      \n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    \n    return streak;\n  }\n}\n\nexport const achievementService = new AchievementService();\nexport default achievementService;"],"mappings":"AAAA,SAASA,eAAe,EAAEC,QAAQ,QAAQ,sBAAsB;AAEhE,MAAMC,kBAAkB,CAAC;EACvBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,oBAAoB,GAAG,IAAI,CAACC,wBAAwB,CAAC,CAAC;IAC3D,IAAI,CAACC,SAAS,GAAG,EAAE;EACrB;;EAEA;EACAD,wBAAwBA,CAAA,EAAG;IACzB,MAAME,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,sBAAsB,CAAC;IAC1D,OAAOF,KAAK,GAAGG,IAAI,CAACC,KAAK,CAACJ,KAAK,CAAC,GAAG,EAAE;EACvC;;EAEA;EACAK,wBAAwBA,CAAA,EAAG;IACzBJ,YAAY,CAACK,OAAO,CAAC,sBAAsB,EAAEH,IAAI,CAACI,SAAS,CAAC,IAAI,CAACV,oBAAoB,CAAC,CAAC;EACzF;;EAEA;EACAW,gBAAgBA,CAACC,QAAQ,EAAE;IACzB,IAAI,CAACV,SAAS,CAACW,IAAI,CAACD,QAAQ,CAAC;EAC/B;;EAEA;EACAE,mBAAmBA,CAACF,QAAQ,EAAE;IAC5B,IAAI,CAACV,SAAS,GAAG,IAAI,CAACA,SAAS,CAACa,MAAM,CAACC,QAAQ,IAAIA,QAAQ,KAAKJ,QAAQ,CAAC;EAC3E;;EAEA;EACAK,eAAeA,CAACC,WAAW,EAAE;IAC3B,IAAI,CAAChB,SAAS,CAACiB,OAAO,CAACP,QAAQ,IAAIA,QAAQ,CAACM,WAAW,CAAC,CAAC;EAC3D;;EAEA;EACAE,UAAUA,CAACC,aAAa,EAAE;IACxB,OAAO,IAAI,CAACrB,oBAAoB,CAACsB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKH,aAAa,CAAC;EACpE;;EAEA;EACAI,iBAAiBA,CAACJ,aAAa,EAAE;IAC/B,IAAI,IAAI,CAACD,UAAU,CAACC,aAAa,CAAC,EAAE,OAAO,KAAK;IAEhD,MAAMH,WAAW,GAAGtB,eAAe,CAAC8B,IAAI,CAACH,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKH,aAAa,CAAC;IACrE,IAAI,CAACH,WAAW,EAAE,OAAO,KAAK;IAE9B,MAAMS,mBAAmB,GAAG;MAC1B,GAAGT,WAAW;MACdU,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACrC,CAAC;IAED,IAAI,CAAC9B,oBAAoB,CAACa,IAAI,CAACc,mBAAmB,CAAC;IACnD,IAAI,CAACnB,wBAAwB,CAAC,CAAC;;IAE/B;IACA,IAAI,CAACuB,0BAA0B,CAACV,aAAa,CAAC;;IAE9C;IACA,IAAI,CAACW,8BAA8B,CAACd,WAAW,CAAC;IAChD,IAAI,CAACD,eAAe,CAACC,WAAW,CAAC;;IAEjC;IACA,IAAI,CAACe,sBAAsB,CAACZ,aAAa,CAAC;IAE1C,OAAO,IAAI;EACb;;EAEA;EACA,MAAMU,0BAA0BA,CAACV,aAAa,EAAE;IAC9C,IAAI;MACF,MAAMa,QAAQ,GAAG,MAAMC,KAAK,CAAC,sDAAsD,EAAE;QACnFC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB,CAAC;QACDC,IAAI,EAAEhC,IAAI,CAACI,SAAS,CAAC;UACnB6B,QAAQ,EAAE,UAAU;UAAE;UACtBlB,aAAa,EAAEA;QACjB,CAAC;MACH,CAAC,CAAC;MAEF,IAAIa,QAAQ,CAACM,EAAE,EAAE;QACfC,OAAO,CAACC,GAAG,CAAC,YAAYrB,aAAa,eAAe,CAAC;MACvD,CAAC,MAAM;QACLoB,OAAO,CAACE,IAAI,CAAC,qBAAqBtB,aAAa,eAAe,CAAC;MACjE;IACF,CAAC,CAAC,OAAOuB,KAAK,EAAE;MACdH,OAAO,CAACG,KAAK,CAAC,mBAAmBvB,aAAa,GAAG,EAAEuB,KAAK,CAAC;IAC3D;EACF;;EAEA;EACAX,sBAAsBA,CAACZ,aAAa,EAAE;IACpC,MAAMrB,oBAAoB,GAAG,IAAI,CAAC6C,uBAAuB,CAAC,CAAC;;IAE3D;IACA,MAAMC,WAAW,GAAG9C,oBAAoB,CAAC+C,GAAG,CAACxB,CAAC,IAAIA,CAAC,CAACC,EAAE,IAAID,CAAC,CAAC;IAE5D,IAAI,CAACuB,WAAW,CAACE,QAAQ,CAAC3B,aAAa,CAAC,EAAE;MACxC,MAAM4B,cAAc,GAAG,CAAC,GAAGH,WAAW,EAAEzB,aAAa,CAAC,CAAC,CAAC;;MAExD;MACA,MAAM6B,eAAe,GAAG5C,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC,IAAI,IAAI,CAAC;MACnF6C,eAAe,CAACC,WAAW,GAAG;QAC5B,GAAGD,eAAe,CAACC,WAAW;QAC9B,CAAC9B,aAAa,GAAG,IAAIQ,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MAC1C,CAAC;MAED1B,YAAY,CAACK,OAAO,CAAC,iBAAiB,EAAEH,IAAI,CAACI,SAAS,CAACwC,eAAe,CAAC,CAAC;MACxE9C,YAAY,CAACK,OAAO,CAAC,sBAAsB,EAAEH,IAAI,CAACI,SAAS,CAACuC,cAAc,CAAC,CAAC,CAAC,CAAC;IAChF;EACF;;EAEA;EACAG,iBAAiBA,CAACC,SAAS,EAAE;IAC3B,MAAMC,aAAa,GAAG,EAAE;IAExB1D,eAAe,CAACuB,OAAO,CAACD,WAAW,IAAI;MACrC,IAAI,CAAC,IAAI,CAACE,UAAU,CAACF,WAAW,CAACM,EAAE,CAAC,EAAE;QACpC,IAAI,IAAI,CAAC+B,gBAAgB,CAACrC,WAAW,CAACsC,WAAW,EAAEH,SAAS,CAAC,EAAE;UAC7D,IAAI,IAAI,CAAC5B,iBAAiB,CAACP,WAAW,CAACM,EAAE,CAAC,EAAE;YAC1C8B,aAAa,CAACzC,IAAI,CAACK,WAAW,CAAC;UACjC;QACF;MACF;IACF,CAAC,CAAC;IAEF,OAAOoC,aAAa;EACtB;;EAEA;EACAC,gBAAgBA,CAACC,WAAW,EAAEH,SAAS,EAAE;IACvC,QAAQG,WAAW,CAACC,IAAI;MACtB;MACA,KAAK,eAAe;QAClB,OAAO,CAACJ,SAAS,CAACK,aAAa,IAAI,CAAC,KAAKF,WAAW,CAACG,MAAM;MAE7D,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAACO,cAAc,IAAIP,SAAS,CAACQ,iBAAiB,IAAI,CAAC,KAAKL,WAAW,CAACG,MAAM;MAE7F,KAAK,aAAa;QAChB,OAAO,CAACN,SAAS,CAACS,kBAAkB,IAAI,CAAC,KAAKN,WAAW,CAACG,MAAM;MAElE,KAAK,gBAAgB;QACnB,MAAMI,YAAY,GAAGV,SAAS,CAACU,YAAY,IAAI,CAAC,CAAC;QACjD,OAAO,CAACA,YAAY,CAACP,WAAW,CAACQ,QAAQ,CAAC,IAAI,CAAC,KAAKR,WAAW,CAACG,MAAM;MAExE,KAAK,qBAAqB;QACxB,MAAMM,eAAe,GAAGZ,SAAS,CAACU,YAAY,IAAI,CAAC,CAAC;QACpD,MAAMG,sBAAsB,GAAGC,MAAM,CAACC,MAAM,CAACH,eAAe,CAAC,CAACI,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAKD,GAAG,GAAGC,IAAI,EAAE,CAAC,CAAC;QAClG,OAAOL,sBAAsB,IAAIV,WAAW,CAACG,MAAM;MAErD,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAACmB,gBAAgB,IAAI,CAAC,KAAKhB,WAAW,CAACG,MAAM;;MAEhE;MACA,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAACoB,UAAU,IAAI,CAAC,KAAKjB,WAAW,CAACG,MAAM;MAE1D,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAACqB,UAAU,IAAI,CAAC,KAAKlB,WAAW,CAACG,MAAM;MAE1D,KAAK,WAAW;MAChB,KAAK,aAAa;QAChB,OAAO,CAACN,SAAS,CAACsB,UAAU,IAAI,CAAC,KAAKnB,WAAW,CAACG,MAAM;MAE1D,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAACuB,UAAU,IAAI,CAAC,KAAKpB,WAAW,CAACG,MAAM;MAE1D,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAACwB,YAAY,IAAIxB,SAAS,CAACyB,cAAc,IAAI,CAAC,KAAKtB,WAAW,CAACG,MAAM;MAExF,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAAC0B,cAAc,IAAI,CAAC,KAAKvB,WAAW,CAACG,MAAM;MAE9D,KAAK,kBAAkB;QACrB,OAAO,CAACN,SAAS,CAAC2B,aAAa,IAAI,CAAC,KAAKxB,WAAW,CAACG,MAAM;MAE7D,KAAK,eAAe;QAClB,OAAO,CAACN,SAAS,CAAC4B,YAAY,IAAI,CAAC,KAAKzB,WAAW,CAACG,MAAM;MAE5D,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAAC6B,aAAa,IAAI,CAAC,KAAK1B,WAAW,CAACG,MAAM;MAE7D,KAAK,QAAQ;QACX,OAAO,CAACN,SAAS,CAAC8B,UAAU,IAAI,CAAC,KAAK3B,WAAW,CAACG,MAAM;MAE1D,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAAC+B,cAAc,IAAI,CAAC,KAAK,CAAC;MAE7C,KAAK,eAAe;QAClB,OAAO,CAAC/B,SAAS,CAACgC,YAAY,IAAI,CAAC,KAAK7B,WAAW,CAACG,MAAM;;MAE5D;MACA,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAACiC,cAAc,IAAI,CAAC,KAAK9B,WAAW,CAACG,MAAM;MAE9D,KAAK,eAAe;QAClB,OAAO,CAACN,SAAS,CAACkC,UAAU,IAAI,CAAC,KAAK/B,WAAW,CAACG,MAAM;MAE1D,KAAK,aAAa;QAChB,OAAO,CAACN,SAAS,CAACmC,UAAU,IAAI,CAAC,KAAKhC,WAAW,CAACG,MAAM;MAE1D,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAACoC,aAAa,IAAI,CAAC,KAAKjC,WAAW,CAACG,MAAM;MAE7D,KAAK,eAAe;QAClB,OAAO,CAACN,SAAS,CAACqC,cAAc,IAAI,CAAC,KAAKlC,WAAW,CAACG,MAAM;MAE9D,KAAK,qBAAqB;QACxB,OAAO,CAACN,SAAS,CAACsC,iBAAiB,IAAI,CAAC,KAAKnC,WAAW,CAACG,MAAM;MAEjE,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAACuC,gBAAgB,IAAI,CAAC,KAAKpC,WAAW,CAACG,MAAM;MAEhE,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAACwC,UAAU,IAAI,CAAC,KAAKrC,WAAW,CAACG,MAAM;MAE1D,KAAK,iBAAiB;QACpB,OAAO,CAACN,SAAS,CAACyC,cAAc,IAAI,CAAC,KAAKtC,WAAW,CAACG,MAAM;MAE9D,KAAK,gBAAgB;QACnB,OAAO,CAACN,SAAS,CAAC0C,aAAa,IAAI,CAAC,KAAKvC,WAAW,CAACG,MAAM;MAE7D,KAAK,gBAAgB;QACnB,OAAO,CAACN,SAAS,CAAC2C,YAAY,IAAI,CAAC,KAAKxC,WAAW,CAACG,MAAM;MAE5D,KAAK,kBAAkB;QACrB,MAAM4B,UAAU,GAAGlC,SAAS,CAACkC,UAAU,IAAI,CAAC;QAC5C,MAAMD,cAAc,GAAGjC,SAAS,CAACiC,cAAc,IAAI,CAAC;QACpD,OAAOC,UAAU,GAAG,CAAC,IAAKD,cAAc,GAAGC,UAAU,IAAK/B,WAAW,CAACyC,KAAK;MAE7E,KAAK,qBAAqB;QACxB,OAAO,CAAC5C,SAAS,CAAC6C,kBAAkB,IAAI,CAAC,KAAK1C,WAAW,CAACG,MAAM;MAElE,KAAK,qBAAqB;QACxB,OAAO,CAACN,SAAS,CAAC8C,kBAAkB,IAAI,CAAC,KAAK3C,WAAW,CAACG,MAAM;MAElE,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAAC+C,WAAW,IAAI,CAAC,KAAK5C,WAAW,CAACG,MAAM;MAE3D,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAACgD,WAAW,IAAI,CAAC,KAAK7C,WAAW,CAACG,MAAM;MAE3D,KAAK,aAAa;QAChB,MAAM2C,gBAAgB,GAAGjD,SAAS,CAACkD,gBAAgB,IAAI,CAAC;QACxD,MAAMC,iBAAiB,GAAGnD,SAAS,CAACmD,iBAAiB,IAAI,CAAC;QAC1D,OAAOF,gBAAgB,IAAI9C,WAAW,CAACiD,KAAK,IACpCD,iBAAiB,GAAGF,gBAAgB,IAAK9C,WAAW,CAACkD,IAAI;MAEnE,KAAK,kBAAkB;QACrB,OAAO,CAACrD,SAAS,CAACsD,kBAAkB,IAAI,CAAC,KAAKnD,WAAW,CAACG,MAAM;;MAElE;MACA,KAAK,wBAAwB;QAC3B,OAAO,CAACN,SAAS,CAACuD,oBAAoB,IAAI,CAAC,KAAK,CAAC;MAEnD,KAAK,eAAe;QAClB,OAAO,CAACvD,SAAS,CAACwD,aAAa,IAAI,CAAC,KAAKrD,WAAW,CAACG,MAAM;MAE7D,KAAK,aAAa;QAChB,OAAO,CAACN,SAAS,CAACyD,UAAU,IAAI,CAAC,KAAKtD,WAAW,CAACG,MAAM;MAE1D,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAAC0D,SAAS,IAAI,CAAC,KAAKvD,WAAW,CAACG,MAAM;MAEzD,KAAK,gBAAgB;QACnB,OAAO,CAACN,SAAS,CAAC2D,gBAAgB,IAAI,CAAC,KAAKxD,WAAW,CAACG,MAAM;MAEhE,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAAC4D,aAAa,IAAI5D,SAAS,CAAC6D,WAAW,IAAI,CAAC,KAAK1D,WAAW,CAACG,MAAM;MAEtF,KAAK,mBAAmB;QACtB,MAAMwD,gBAAgB,GAAG9D,SAAS,CAAC8D,gBAAgB,IAAI,CAAC,CAAC;QACzD,OAAO,CAACA,gBAAgB,CAAC3D,WAAW,CAACQ,QAAQ,CAAC,IAAI,CAAC,KAAKR,WAAW,CAACG,MAAM;MAE5E,KAAK,kBAAkB;QACrB,OAAO,CAACN,SAAS,CAAC+D,eAAe,IAAI,CAAC,KAAK5D,WAAW,CAACG,MAAM;MAE/D,KAAK,eAAe;QAClB,MAAM0D,iBAAiB,GAAGhE,SAAS,CAACU,YAAY,IAAI,CAAC,CAAC;QACtD,OAAO,CAACsD,iBAAiB,CAAC7D,WAAW,CAACQ,QAAQ,CAAC,IAAI,CAAC,KAAKR,WAAW,CAACG,MAAM;MAE7E,KAAK,eAAe;QAClB,OAAO,CAACN,SAAS,CAACiE,YAAY,IAAI,CAAC,KAAK9D,WAAW,CAACG,MAAM;MAE5D,KAAK,kBAAkB;QACrB,OAAO,CAACN,SAAS,CAACkE,oBAAoB,IAAI,CAAC,KAAK/D,WAAW,CAACG,MAAM;MAEpE,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAACmE,WAAW,IAAI,CAAC,KAAKhE,WAAW,CAACG,MAAM;;MAE3D;MACA,KAAK,aAAa;QAChB,OAAQN,SAAS,CAACoE,UAAU,IAAI,KAAK;MAEvC,KAAK,cAAc;QACjB,OAAQpE,SAAS,CAACqE,WAAW,IAAI,KAAK;MAExC,KAAK,mBAAmB;QACtB,OAAO,CAACrE,SAAS,CAACsE,qBAAqB,IAAI,CAAC,KAAKnE,WAAW,CAACG,MAAM;MAErE,KAAK,sBAAsB;QACzB,OAAO,CAACN,SAAS,CAAC4D,aAAa,IAAI,CAAC,KAAKzD,WAAW,CAACG,MAAM;MAE7D,KAAK,kBAAkB;QACrB,OAAO,CAACN,SAAS,CAACuE,eAAe,IAAI,CAAC,KAAKpE,WAAW,CAACG,MAAM;MAE/D,KAAK,aAAa;QAChB,OAAQN,SAAS,CAACwE,UAAU,IAAI,KAAK;MAEvC,KAAK,kBAAkB;QACrB,OAAO,CAACxE,SAAS,CAACyE,eAAe,IAAI,CAAC,KAAKtE,WAAW,CAACG,MAAM;MAE/D,KAAK,qBAAqB;QACxB,OAAO,CAACN,SAAS,CAAC0E,iBAAiB,IAAI,CAAC,KAAKvE,WAAW,CAACG,MAAM;MAEjE,KAAK,wBAAwB;QAC3B,OAAO,CAACN,SAAS,CAAC2E,oBAAoB,IAAI,CAAC,KAAKxE,WAAW,CAACG,MAAM;MAEpE,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAAC4E,WAAW,IAAI,CAAC,KAAKzE,WAAW,CAACG,MAAM;MAE3D,KAAK,qBAAqB;QACxB,OAAO,CAACN,SAAS,CAAC6E,kBAAkB,IAAI,CAAC,KAAK1E,WAAW,CAACG,MAAM;MAElE,KAAK,uBAAuB;QAC1B,OAAO,CAACN,SAAS,CAAC8E,mBAAmB,IAAI,CAAC,KAAK3E,WAAW,CAACG,MAAM;MAEnE,KAAK,eAAe;QAClB,OAAO,CAACN,SAAS,CAAC+E,YAAY,IAAI,CAAC,KAAK5E,WAAW,CAACG,MAAM;MAE5D,KAAK,sBAAsB;QACzB,OAAO,CAACN,SAAS,CAACgF,kBAAkB,IAAI,CAAC,KAAK7E,WAAW,CAACG,MAAM;MAElE,KAAK,wBAAwB;QAC3B,OAAO,CAACN,SAAS,CAACiF,oBAAoB,IAAI,CAAC,KAAK9E,WAAW,CAACG,MAAM;MAEpE,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAACkF,WAAW,IAAI,CAAC,KAAK/E,WAAW,CAACG,MAAM;MAE3D,KAAK,UAAU;QACb,OAAO,CAACN,SAAS,CAACmF,OAAO,IAAI,CAAC,KAAKhF,WAAW,CAACG,MAAM;MAEvD,KAAK,uBAAuB;QAC1B,OAAO,CAACN,SAAS,CAACoF,oBAAoB,IAAI,CAAC,KAAKjF,WAAW,CAACG,MAAM;MAEpE;QACElB,OAAO,CAACE,IAAI,CAAC,6BAA6Ba,WAAW,CAACC,IAAI,EAAE,CAAC;QAC7D,OAAO,KAAK;IAChB;EACF;;EAEA;EACAzB,8BAA8BA,CAACd,WAAW,EAAE;IAC1C,MAAMwH,IAAI,GAAG7I,QAAQ,CAACqB,WAAW,CAACwH,IAAI,CAAC;IAEvCjG,OAAO,CAACC,GAAG,CAAC,MAAMgG,IAAI,CAACC,KAAK,IAAIzH,WAAW,CAAC0H,IAAI,gBAAgB1H,WAAW,CAAC2H,QAAQ,MAAM,CAAC;;IAE3F;IACAC,MAAM,CAACC,aAAa,CAAC,IAAIC,WAAW,CAAC,qBAAqB,EAAE;MAC1DC,MAAM,EAAE;QACN/H,WAAW;QACXwH,IAAI;QACJQ,SAAS,EAAE,IAAIrH,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC;IACF,CAAC,CAAC,CAAC;;IAEH;IACA,IAAI,CAACqH,oBAAoB,CAACjI,WAAW,CAACwH,IAAI,CAAC;EAC7C;;EAEA;EACAS,oBAAoBA,CAACT,IAAI,EAAE;IACzB,IAAI;MACF,MAAMU,KAAK,GAAG,IAAIC,KAAK,CAAC,uBAAuBX,IAAI,MAAM,CAAC;MAC1DU,KAAK,CAACE,MAAM,GAAG,GAAG;MAClBF,KAAK,CAACG,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,MAAM;QACvB/G,OAAO,CAACC,GAAG,CAAC,6BAA6BgG,IAAI,EAAE,CAAC;MAClD,CAAC,CAAC;IACJ,CAAC,CAAC,OAAO9F,KAAK,EAAE;MACdH,OAAO,CAACG,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;IAC1D;EACF;;EAEA;EACA6G,sBAAsBA,CAACpI,aAAa,EAAEgC,SAAS,EAAE;IAC/C,MAAMnC,WAAW,GAAGtB,eAAe,CAAC8B,IAAI,CAACH,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKH,aAAa,CAAC;IACrE,IAAI,CAACH,WAAW,IAAI,IAAI,CAACE,UAAU,CAACC,aAAa,CAAC,EAAE,OAAO,CAAC;IAE5D,MAAMqI,GAAG,GAAGxI,WAAW,CAACsC,WAAW;IACnC,IAAImG,OAAO,GAAG,CAAC;IACf,IAAIhG,MAAM,GAAG+F,GAAG,CAAC/F,MAAM,IAAI,CAAC;IAE5B,QAAQ+F,GAAG,CAACjG,IAAI;MACd,KAAK,YAAY;QACfkG,OAAO,GAAGtG,SAAS,CAACoB,UAAU,IAAI,CAAC;QACnC;MACF,KAAK,YAAY;QACfkF,OAAO,GAAGtG,SAAS,CAACqB,UAAU,IAAI,CAAC;QACnC;MACF,KAAK,YAAY;QACfiF,OAAO,GAAGtG,SAAS,CAACkC,UAAU,IAAI,CAAC;QACnC;MACF,KAAK,eAAe;QAClBoE,OAAO,GAAGtG,SAAS,CAACK,aAAa,IAAI,CAAC;QACtC;MACF,KAAK,YAAY;QACfiG,OAAO,GAAGtG,SAAS,CAACO,cAAc,IAAI,CAAC;QACvC;MACF,KAAK,aAAa;QAChB+F,OAAO,GAAGtG,SAAS,CAACsB,UAAU,IAAI,CAAC;QACnC;MACF,KAAK,QAAQ;MACb,KAAK,mBAAmB;MACxB,KAAK,cAAc;QACjBgF,OAAO,GAAGtG,SAAS,CAACqG,GAAG,CAACjG,IAAI,KAAK,QAAQ,GAAG,YAAY,GACpCiG,GAAG,CAACjG,IAAI,KAAK,mBAAmB,GAAG,YAAY,GAAG,aAAa,CAAC,IAAI,CAAC;QACzF;MACF;QACE,OAAO,CAAC;IACZ;IAEA,OAAOmG,IAAI,CAACC,GAAG,CAACF,OAAO,GAAGhG,MAAM,EAAE,CAAC,CAAC;EACtC;;EAEA;EACAmG,mBAAmBA,CAACzG,SAAS,EAAE0G,KAAK,GAAG,CAAC,EAAE;IACxC,OAAOnK,eAAe,CACnBmB,MAAM,CAACG,WAAW,IAAI,CAAC,IAAI,CAACE,UAAU,CAACF,WAAW,CAACM,EAAE,CAAC,CAAC,CACvDuB,GAAG,CAAC7B,WAAW,KAAK;MACnB,GAAGA,WAAW;MACd8I,QAAQ,EAAE,IAAI,CAACP,sBAAsB,CAACvI,WAAW,CAACM,EAAE,EAAE6B,SAAS;IACjE,CAAC,CAAC,CAAC,CACF4G,IAAI,CAAC,CAAC1I,CAAC,EAAE2I,CAAC,KAAKA,CAAC,CAACF,QAAQ,GAAGzI,CAAC,CAACyI,QAAQ,CAAC,CACvCG,KAAK,CAAC,CAAC,EAAEJ,KAAK,CAAC;EACpB;;EAEA;EACAK,mBAAmBA,CAACC,IAAI,GAAG,CAAC,EAAE;IAC5B,MAAMC,UAAU,GAAG,IAAIzI,IAAI,CAAC,CAAC;IAC7ByI,UAAU,CAACC,OAAO,CAACD,UAAU,CAACE,OAAO,CAAC,CAAC,GAAGH,IAAI,CAAC;IAE/C,OAAO,IAAI,CAACrK,oBAAoB,CAC7Be,MAAM,CAACG,WAAW,IAAI,IAAIW,IAAI,CAACX,WAAW,CAACU,UAAU,CAAC,IAAI0I,UAAU,CAAC,CACrEL,IAAI,CAAC,CAAC1I,CAAC,EAAE2I,CAAC,KAAK,IAAIrI,IAAI,CAACqI,CAAC,CAACtI,UAAU,CAAC,GAAG,IAAIC,IAAI,CAACN,CAAC,CAACK,UAAU,CAAC,CAAC;EACpE;;EAEA;EACA6I,QAAQA,CAAA,EAAG;IACT,MAAMC,KAAK,GAAG9K,eAAe,CAAC+K,MAAM;IACpC,MAAMC,QAAQ,GAAG,IAAI,CAAC5K,oBAAoB,CAAC2K,MAAM;IACjD,MAAME,MAAM,GAAG;MACbC,MAAM,EAAE,IAAI,CAAC9K,oBAAoB,CAACe,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACmH,IAAI,KAAK,QAAQ,CAAC,CAACiC,MAAM;MACzEI,QAAQ,EAAE,IAAI,CAAC/K,oBAAoB,CAACe,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACmH,IAAI,KAAK,UAAU,CAAC,CAACiC,MAAM;MAC7EK,IAAI,EAAE,IAAI,CAAChL,oBAAoB,CAACe,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACmH,IAAI,KAAK,MAAM,CAAC,CAACiC,MAAM;MACrEM,SAAS,EAAE,IAAI,CAACjL,oBAAoB,CAACe,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAACmH,IAAI,KAAK,WAAW,CAAC,CAACiC;IAC3E,CAAC;IAED,MAAMnC,OAAO,GAAG,IAAI,CAACxI,oBAAoB,CAACqE,MAAM,CAAC,CAACC,GAAG,EAAEpD,WAAW,KAAKoD,GAAG,GAAGpD,WAAW,CAAC2H,QAAQ,EAAE,CAAC,CAAC;IAErG,OAAO;MACL6B,KAAK;MACLE,QAAQ;MACRM,UAAU,EAAEtB,IAAI,CAACuB,KAAK,CAAEP,QAAQ,GAAGF,KAAK,GAAI,GAAG,CAAC;MAChDG,MAAM;MACNrC,OAAO;MACP4C,aAAa,EAAE,IAAI,CAAChB,mBAAmB,CAAC,CAAC,CAAC,CAACO;IAC7C,CAAC;EACH;;EAEA;EACAU,WAAWA,CAAChK,aAAa,EAAE;IACzBoB,OAAO,CAACC,GAAG,CAAC,oBAAoBrB,aAAa,EAAE,CAAC;;IAEhD;IACA,MAAMiK,eAAe,GAAGhL,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,sBAAsB,CAAC,IAAI,IAAI,CAAC,CACrFU,MAAM,CAACS,EAAE,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK+J,SAAS,CAAC;IAEhD,IAAI,CAACD,eAAe,CAACtI,QAAQ,CAAC3B,aAAa,CAAC,EAAE;MAC5C,MAAMmK,WAAW,GAAG,CAAC,GAAGF,eAAe,EAAEjK,aAAa,CAAC;MACvDjB,YAAY,CAACK,OAAO,CAAC,sBAAsB,EAAEH,IAAI,CAACI,SAAS,CAAC8K,WAAW,CAAC,CAAC;;MAEzE;MACA,MAAMtI,eAAe,GAAG5C,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC,IAAI,IAAI,CAAC;MACnF6C,eAAe,CAAC7B,aAAa,CAAC,GAAG;QAC/BO,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACpCkI,QAAQ,EAAE;MACZ,CAAC;MACD5J,YAAY,CAACK,OAAO,CAAC,iBAAiB,EAAEH,IAAI,CAACI,SAAS,CAACwC,eAAe,CAAC,CAAC;MAExET,OAAO,CAACC,GAAG,CAAC,qBAAqBrB,aAAa,EAAE,CAAC;;MAEjD;MACA,IAAI,CAACU,0BAA0B,CAACV,aAAa,CAAC;;MAE9C;MACAyH,MAAM,CAACC,aAAa,CAAC,IAAIC,WAAW,CAAC,qBAAqB,CAAC,CAAC;IAC9D,CAAC,MAAM;MACLvG,OAAO,CAACC,GAAG,CAAC,MAAMrB,aAAa,mBAAmB,CAAC;IACrD;EACF;;EAEA;EACAoK,iBAAiBA,CAAA,EAAG;IAClBhJ,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;IAClDtC,YAAY,CAACsL,UAAU,CAAC,sBAAsB,CAAC;IAC/CtL,YAAY,CAACsL,UAAU,CAAC,iBAAiB,CAAC;IAC1C5C,MAAM,CAACC,aAAa,CAAC,IAAIC,WAAW,CAAC,qBAAqB,CAAC,CAAC;EAC9D;;EAEA;EACA2C,mBAAmBA,CAAA,EAAG;IACpB,MAAM7I,WAAW,GAAGxC,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,sBAAsB,CAAC,IAAI,IAAI,CAAC,CACjFU,MAAM,CAACS,EAAE,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK+J,SAAS,CAAC;IAEhDnL,YAAY,CAACK,OAAO,CAAC,sBAAsB,EAAEH,IAAI,CAACI,SAAS,CAACoC,WAAW,CAAC,CAAC;IACzEL,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;EAChE;;EAEA;EACAkJ,4BAA4BA,CAAC1K,WAAW,EAAE;IACxC,MAAMgC,eAAe,GAAG5C,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC,IAAI,IAAI,CAAC;IACnF,MAAM8C,WAAW,GAAGD,eAAe,CAACC,WAAW,IAAI,CAAC,CAAC;IAErD,OAAO;MACL,GAAGjC,WAAW;MACdU,UAAU,EAAEuB,WAAW,CAACjC,WAAW,CAACM,EAAE,CAAC,IAAI;IAC7C,CAAC;EACH;;EAEA;EACAqB,uBAAuBA,CAAA,EAAG;IACxB,MAAMC,WAAW,GAAGxC,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,sBAAsB,CAAC,IAAI,IAAI,CAAC,CACjFU,MAAM,CAACS,EAAE,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK+J,SAAS,CAAC;IAEhD,OAAOzI,WAAW,CAACC,GAAG,CAACvB,EAAE,IAAI;MAC3B,MAAMN,WAAW,GAAGtB,eAAe,CAAC8B,IAAI,CAACH,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKA,EAAE,CAAC;MAC1D,IAAI,CAACN,WAAW,EAAE;QAChBuB,OAAO,CAACE,IAAI,CAAC,0BAA0BnB,EAAE,YAAY,CAAC;QACtD,OAAO,IAAI;MACb;MAEA,MAAM0B,eAAe,GAAG5C,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC,IAAI,IAAI,CAAC;MACnF,MAAMwL,IAAI,GAAG3I,eAAe,CAAC1B,EAAE,CAAC,IAAI,CAAC,CAAC;MAEtC,OAAO;QACL,GAAGN,WAAW;QACdU,UAAU,EAAEiK,IAAI,CAACjK,UAAU,IAAI,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACvDkI,QAAQ,EAAE6B,IAAI,CAAC7B,QAAQ,IAAI;MAC7B,CAAC;IACH,CAAC,CAAC,CAACjJ,MAAM,CAAC+K,OAAO,CAAC;EACpB;;EAEA;EACA,MAAMC,uBAAuBA,CAAC1I,SAAS,EAAE;IACvCZ,OAAO,CAACC,GAAG,CAAC,uDAAuD,EAAEW,SAAS,CAAC;IAE/E,MAAM2I,kBAAkB,GAAG,IAAI,CAACnJ,uBAAuB,CAAC,CAAC,CAACE,GAAG,CAACxB,CAAC,IAAIA,CAAC,CAACC,EAAE,CAAC;IACxE,MAAM8B,aAAa,GAAG,EAAE;;IAExB;IACA1D,eAAe,CAACuB,OAAO,CAACD,WAAW,IAAI;MACrC,IAAI,CAAC8K,kBAAkB,CAAChJ,QAAQ,CAAC9B,WAAW,CAACM,EAAE,CAAC,EAAE;QAChD,IAAI,IAAI,CAAC+B,gBAAgB,CAACrC,WAAW,CAACsC,WAAW,EAAEH,SAAS,CAAC,EAAE;UAC7DZ,OAAO,CAACC,GAAG,CAAC,qBAAqBxB,WAAW,CAACM,EAAE,MAAMN,WAAW,CAAC0H,IAAI,EAAE,CAAC;UACxE,IAAI,IAAI,CAACnH,iBAAiB,CAACP,WAAW,CAACM,EAAE,CAAC,EAAE;YAC1C8B,aAAa,CAACzC,IAAI,CAACK,WAAW,CAAC;UACjC;QACF,CAAC,MAAM;UACL;UACA,MAAM8I,QAAQ,GAAG,IAAI,CAACP,sBAAsB,CAACvI,WAAW,CAACM,EAAE,EAAE6B,SAAS,CAAC;UACvE,IAAI2G,QAAQ,GAAG,GAAG,EAAE;YAClBvH,OAAO,CAACC,GAAG,CAAC,0BAA0BxB,WAAW,CAACM,EAAE,MAAMoI,IAAI,CAACuB,KAAK,CAACnB,QAAQ,GAAG,GAAG,CAAC,GAAG,CAAC;UAC1F;QACF;MACF;IACF,CAAC,CAAC;IAEFvH,OAAO,CAACC,GAAG,CAAC,sCAAsCY,aAAa,CAACqH,MAAM,oBAAoB,EACxFrH,aAAa,CAACP,GAAG,CAACxB,CAAC,IAAIA,CAAC,CAACqH,IAAI,CAAC,CAAC;IAEjC,OAAOtF,aAAa;EACtB;;EAEA;EACA,MAAM2I,mBAAmBA,CAAA,EAAG;IAC1BxJ,OAAO,CAACC,GAAG,CAAC,6CAA6C,CAAC;IAE1D,IAAI;MACF,MAAMH,QAAQ,GAAG,MAAM;MAEvB,MAAM,CAAC2J,aAAa,EAAEC,aAAa,EAAEC,oBAAoB,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAC7EnK,KAAK,CAAC,4CAA4CI,QAAQ,EAAE,CAAC,CAACiH,KAAK,CAAC,OAAO;QAAEhH,EAAE,EAAE;MAAM,CAAC,CAAC,CAAC,EAC1FL,KAAK,CAAC,4CAA4CI,QAAQ,EAAE,CAAC,CAACiH,KAAK,CAAC,OAAO;QAAEhH,EAAE,EAAE;MAAM,CAAC,CAAC,CAAC;MAAE;MAC5FL,KAAK,CAAC,oDAAoDI,QAAQ,EAAE,CAAC,CAACiH,KAAK,CAAC,OAAO;QAAEhH,EAAE,EAAE;MAAM,CAAC,CAAC,CAAC,CAAC;MAAA,CACpG,CAAC;MAEF,MAAM+J,KAAK,GAAGL,aAAa,CAAC1J,EAAE,GAAG,MAAM0J,aAAa,CAACM,IAAI,CAAC,CAAC,GAAG,EAAE;MAChE,MAAM/F,KAAK,GAAG0F,aAAa,CAAC3J,EAAE,GAAG,MAAM2J,aAAa,CAACK,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;MAClE,MAAMC,aAAa,GAAGL,oBAAoB,CAAC5J,EAAE,GAAG,MAAM4J,oBAAoB,CAACI,IAAI,CAAC,CAAC,GAAG,EAAE;MAEtF/J,OAAO,CAACC,GAAG,CAAC,gCAAgC6J,KAAK,CAAC5B,MAAM,QAAQ,CAAC;MACjElI,OAAO,CAACC,GAAG,CAAC,+BAA+B+D,KAAK,CAACkE,MAAM,QAAQ,CAAC,CAAC,CAAC;MAClElI,OAAO,CAACC,GAAG,CAAC,wCAAwC+J,aAAa,CAAC9B,MAAM,WAAW,CAAC;;MAEpF;MACA,MAAM+B,KAAK,GAAG;QACZ;QACAjI,UAAU,EAAE8H,KAAK,CAAC5B,MAAM;QACxBjG,UAAU,EAAE,IAAI,CAACiI,mBAAmB,CAACJ,KAAK,CAAC;QAC3C5H,UAAU,EAAE,IAAI,CAACiI,mBAAmB,CAACL,KAAK,CAAC;QAC3CM,UAAU,EAAE,IAAI,CAACC,mBAAmB,CAACP,KAAK,CAAC;QAC3CpH,UAAU,EAAE,IAAI,CAAC4H,mBAAmB,CAACR,KAAK,CAAC;QAC3CxH,cAAc,EAAE,IAAI,CAACiI,iBAAiB,CAACT,KAAK,CAAC;QAC7CvH,aAAa,EAAE,IAAI,CAACiI,gBAAgB,CAACV,KAAK,CAAC;QAC3C1H,YAAY,EAAE,IAAI,CAACqI,uBAAuB,CAACX,KAAK,CAAC;QACjD3H,UAAU,EAAE,IAAI,CAACuI,mBAAmB,CAACZ,KAAK,CAAC;QAC3CrH,aAAa,EAAE,IAAI,CAACkI,sBAAsB,CAACb,KAAK,CAAC;QACjDtH,YAAY,EAAE,IAAI,CAACoI,qBAAqB,CAACd,KAAK,CAAC;QAE/C;QACAhH,UAAU,EAAEkB,KAAK,CAACkE,MAAM;QACxBrF,cAAc,EAAE,IAAI,CAACgI,uBAAuB,CAAC7G,KAAK,CAAC;QACnDjB,UAAU,EAAE,IAAI,CAAC+H,mBAAmB,CAAC9G,KAAK,CAAC;QAC3CZ,UAAU,EAAE,IAAI,CAAC2H,mBAAmB,CAAC/G,KAAK,CAAC;QAC3Cd,iBAAiB,EAAE,IAAI,CAAC8H,0BAA0B,CAAChH,KAAK,CAAC;QACzDb,gBAAgB,EAAE,IAAI,CAAC8H,yBAAyB,CAACjH,KAAK,CAAC;QACvDhB,aAAa,EAAE,IAAI,CAACkI,sBAAsB,CAAClH,KAAK,CAAC;QACjDf,cAAc,EAAE,IAAI,CAACkI,uBAAuB,CAACnH,KAAK,CAAC;QACnDX,cAAc,EAAE,IAAI,CAAC+H,uBAAuB,CAACpH,KAAK,CAAC;QACnDV,aAAa,EAAE,IAAI,CAAC+H,sBAAsB,CAACrH,KAAK,CAAC;QACjDT,YAAY,EAAE,IAAI,CAAC+H,qBAAqB,CAACtH,KAAK,CAAC;QAE/C;QACA/C,aAAa,EAAE+I,aAAa,CAAC9B,MAAM;QACnC/G,cAAc,EAAE,IAAI,CAACoK,uBAAuB,CAACvB,aAAa,CAAC;QAC3D5I,iBAAiB,EAAE,IAAI,CAACoK,0BAA0B,CAACxB,aAAa,CAAC;QACjE3I,kBAAkB,EAAE,IAAI,CAACoK,2BAA2B,CAACzB,aAAa,CAAC;QACnE0B,WAAW,EAAE,IAAI,CAACC,oBAAoB,CAAC3B,aAAa,CAAC;QACrD4B,oBAAoB,EAAE,IAAI,CAACC,6BAA6B,CAAC7B,aAAa,CAAC;QACvE1I,YAAY,EAAE,IAAI,CAACwK,qBAAqB,CAAC9B,aAAa,CAAC;QACvDtF,gBAAgB,EAAE,IAAI,CAACqH,yBAAyB,CAAC/B,aAAa,CAAC;QAC/DjI,gBAAgB,EAAE,IAAI,CAACiK,yBAAyB,CAAChC,aAAa,CAAC;QAE/D;QACAiC,UAAU,EAAE,IAAI,CAACC,mBAAmB,CAACpC,KAAK,EAAE9F,KAAK,EAAEgG,aAAa,CAAC;QACjExF,aAAa,EAAE,IAAI,CAAC2H,sBAAsB,CAACrC,KAAK,EAAE9F,KAAK,EAAEgG,aAAa,CAAC;QACvE9E,qBAAqB,EAAE,IAAI,CAAC9E,uBAAuB,CAAC,CAAC,CAAC8H;MACxD,CAAC;MAEDlI,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEgK,KAAK,CAAC;MAC1C,OAAOA,KAAK;IAEd,CAAC,CAAC,OAAO9J,KAAK,EAAE;MACdH,OAAO,CAACG,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;;MAEjE;MACAH,OAAO,CAACC,GAAG,CAAC,oCAAoC,CAAC;MACjD,MAAM6J,KAAK,GAAGjM,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC;MAC/D,MAAMoG,KAAK,GAAGnG,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC;MAC/D,MAAMoM,aAAa,GAAGnM,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC;MAE/EoC,OAAO,CAACC,GAAG,CAAC,wCAAwC6J,KAAK,CAAC5B,MAAM,QAAQ,CAAC;MACzElI,OAAO,CAACC,GAAG,CAAC,uCAAuC+D,KAAK,CAACkE,MAAM,QAAQ,CAAC;MACxElI,OAAO,CAACC,GAAG,CAAC,iDAAiD+J,aAAa,CAAC9B,MAAM,WAAW,CAAC;;MAE7F;MACA,OAAO,IAAI,CAACkE,8BAA8B,CAACtC,KAAK,EAAE9F,KAAK,EAAEgG,aAAa,CAAC;IACzE;EACF;;EAEA;EACAE,mBAAmBA,CAACJ,KAAK,EAAE;IACzB,OAAOA,KAAK,CAAClI,MAAM,CAAC,CAACqG,KAAK,EAAEoE,IAAI,KAAK;MACnC,MAAMC,OAAO,GAAGD,IAAI,CAACC,OAAO,IAAID,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACxM,IAAI,IAAI,EAAE;MAC5D,MAAM2M,KAAK,GAAGF,OAAO,CAACG,KAAK,CAAC,KAAK,CAAC,CAACnO,MAAM,CAACoO,IAAI,IAAIA,IAAI,CAACxE,MAAM,GAAG,CAAC,CAAC;MAClE,OAAOD,KAAK,GAAGuE,KAAK,CAACtE,MAAM;IAC7B,CAAC,EAAE,CAAC,CAAC;EACP;EAEAiC,mBAAmBA,CAACL,KAAK,EAAE;IACzB,MAAM6C,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;IACzB9C,KAAK,CAACpL,OAAO,CAAC2N,IAAI,IAAI;MACpB,MAAMQ,IAAI,GAAGR,IAAI,CAACQ,IAAI,IAAIR,IAAI,CAACS,UAAU,IAAI,EAAE;MAC/C,IAAIC,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,EAAE;QACvBA,IAAI,CAACnO,OAAO,CAACuO,GAAG,IAAIN,OAAO,CAACO,GAAG,CAACD,GAAG,CAAC,CAAC;MACvC;IACF,CAAC,CAAC;IACF,OAAON,OAAO,CAACQ,IAAI;EACrB;EAEA9C,mBAAmBA,CAACP,KAAK,EAAE;IACzB,MAAMsD,KAAK,GAAG,IAAIhO,IAAI,CAAC,CAAC,CAACiO,YAAY,CAAC,CAAC;IACvC,OAAOvD,KAAK,CAACxL,MAAM,CAAC+N,IAAI,IAAI;MAC1B,MAAMiB,IAAI,GAAGjB,IAAI,CAACkB,SAAS,IAAIlB,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACiB,IAAI;MACxD,OAAOA,IAAI,IAAI,IAAIlO,IAAI,CAACkO,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC,KAAKD,KAAK;IACxD,CAAC,CAAC,CAAClF,MAAM;EACX;EAEAoC,mBAAmBA,CAACR,KAAK,EAAE;IACzB,IAAIA,KAAK,CAAC5B,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC;IAEhC,MAAMuF,WAAW,GAAG,CAAC,CAAC;IACtB3D,KAAK,CAACpL,OAAO,CAAC2N,IAAI,IAAI;MACpB,MAAMiB,IAAI,GAAGjB,IAAI,CAACkB,SAAS,IAAIlB,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACiB,IAAI;MACxD,IAAIA,IAAI,EAAE;QACR,MAAMI,OAAO,GAAG,IAAItO,IAAI,CAACkO,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC;QAC7CI,WAAW,CAACC,OAAO,CAAC,GAAG,IAAI;MAC7B;IACF,CAAC,CAAC;IAEF,MAAMC,WAAW,GAAGjM,MAAM,CAACkM,IAAI,CAACH,WAAW,CAAC,CAACjG,IAAI,CAAC,CAAC1I,CAAC,EAAE2I,CAAC,KAAK,IAAIrI,IAAI,CAACqI,CAAC,CAAC,GAAG,IAAIrI,IAAI,CAACN,CAAC,CAAC,CAAC;IACtF,IAAI+O,MAAM,GAAG,CAAC;IACd,IAAIC,WAAW,GAAG,IAAI1O,IAAI,CAAC,CAAC;IAE5B,KAAK,IAAI2O,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACzF,MAAM,EAAE6F,CAAC,EAAE,EAAE;MAC3C,MAAMC,QAAQ,GAAG,IAAI5O,IAAI,CAACuO,WAAW,CAACI,CAAC,CAAC,CAAC;MACzC,MAAME,QAAQ,GAAG9G,IAAI,CAAC+G,KAAK,CAAC,CAACJ,WAAW,GAAGE,QAAQ,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;MAE7E,IAAIC,QAAQ,KAAKF,CAAC,EAAE;QAClBF,MAAM,EAAE;MACV,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOA,MAAM;EACf;EAEAtD,iBAAiBA,CAACT,KAAK,EAAE;IACvB,OAAO3C,IAAI,CAACgH,GAAG,CAAC,GAAGrE,KAAK,CAACxJ,GAAG,CAAC+L,IAAI,IAAI;MACnC,MAAMC,OAAO,GAAGD,IAAI,CAACC,OAAO,IAAID,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACxM,IAAI,IAAI,EAAE;MAC5D,OAAOyM,OAAO,CAACG,KAAK,CAAC,KAAK,CAAC,CAACnO,MAAM,CAACoO,IAAI,IAAIA,IAAI,CAACxE,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM;IACpE,CAAC,CAAC,EAAE,CAAC,CAAC;EACR;EAEAsC,gBAAgBA,CAACV,KAAK,EAAE;IACtB,OAAO3C,IAAI,CAACgH,GAAG,CAAC,GAAGrE,KAAK,CAACxJ,GAAG,CAAC+L,IAAI,IAAI;MACnC,MAAMQ,IAAI,GAAGR,IAAI,CAACQ,IAAI,IAAIR,IAAI,CAACS,UAAU,IAAI,EAAE;MAC/C,OAAOC,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,GAAGA,IAAI,CAAC3E,MAAM,GAAG,CAAC;IAC9C,CAAC,CAAC,EAAE,CAAC,CAAC;EACR;EAEAuC,uBAAuBA,CAACX,KAAK,EAAE;IAC7B,OAAO3C,IAAI,CAACgH,GAAG,CAAC,GAAGrE,KAAK,CAACxJ,GAAG,CAAC+L,IAAI,IAAI;MACnC,OAAOA,IAAI,CAAC+B,SAAS,IAAI/B,IAAI,CAACgC,KAAK,IAAI,CAAC;IAC1C,CAAC,CAAC,EAAE,CAAC,CAAC;EACR;EAEA3D,mBAAmBA,CAACZ,KAAK,EAAE;IACzB,OAAOA,KAAK,CAAClI,MAAM,CAAC,CAACqG,KAAK,EAAEoE,IAAI,KAAK;MACnC,OAAOpE,KAAK,IAAIoE,IAAI,CAAC+B,SAAS,IAAI/B,IAAI,CAACgC,KAAK,IAAI,CAAC,CAAC;IACpD,CAAC,EAAE,CAAC,CAAC;EACP;EAEA1D,sBAAsBA,CAACb,KAAK,EAAE;IAC5B,MAAMwE,UAAU,GAAG,IAAIlP,IAAI,CAAC,CAAC;IAC7BkP,UAAU,CAACxG,OAAO,CAACwG,UAAU,CAACvG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;IAE5C,OAAO+B,KAAK,CAACxL,MAAM,CAAC+N,IAAI,IAAI;MAC1B,MAAMiB,IAAI,GAAGjB,IAAI,CAACkB,SAAS,IAAIlB,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACiB,IAAI;MACxD,OAAOA,IAAI,IAAI,IAAIlO,IAAI,CAACkO,IAAI,CAAC,IAAIgB,UAAU;IAC7C,CAAC,CAAC,CAACpG,MAAM;EACX;EAEA0C,qBAAqBA,CAACd,KAAK,EAAE;IAC3B,OAAOA,KAAK,CAACxL,MAAM,CAAC+N,IAAI,IAAI;MAC1B,MAAMiB,IAAI,GAAG,IAAIlO,IAAI,CAACiN,IAAI,CAACkB,SAAS,IAAIlB,IAAI,CAACmB,OAAO,IAAInB,IAAI,CAACiB,IAAI,CAAC;MAClE,MAAMiB,SAAS,GAAGjB,IAAI,CAACkB,MAAM,CAAC,CAAC;MAC/B,OAAOD,SAAS,KAAK,CAAC,IAAIA,SAAS,KAAK,CAAC,CAAC,CAAC;IAC7C,CAAC,CAAC,CAACrG,MAAM;EACX;EAEA2C,uBAAuBA,CAAC7G,KAAK,EAAE;IAC7B,OAAOA,KAAK,CAAC1F,MAAM,CAACmQ,IAAI,IACtBA,IAAI,CAACC,SAAS,IAAID,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACG,MAAM,KAAK,WAAW,IAAIH,IAAI,CAACG,MAAM,KAAK,MAChF,CAAC,CAAC1G,MAAM;EACV;EAEA4C,mBAAmBA,CAAC9G,KAAK,EAAE;IACzB,MAAMoJ,KAAK,GAAG,IAAIhO,IAAI,CAAC,CAAC,CAACiO,YAAY,CAAC,CAAC;IACvC,OAAOrJ,KAAK,CAAC1F,MAAM,CAACmQ,IAAI,IAAI;MAC1B,MAAMnB,IAAI,GAAGmB,IAAI,CAACI,WAAW,IAAIJ,IAAI,CAAClB,SAAS,IAAIkB,IAAI,CAACjB,OAAO,IAAIiB,IAAI,CAACnB,IAAI;MAC5E,OAAOA,IAAI,IAAI,IAAIlO,IAAI,CAACkO,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC,KAAKD,KAAK;IACxD,CAAC,CAAC,CAAClF,MAAM;EACX;EAEA6C,mBAAmBA,CAAC/G,KAAK,EAAE;IACzB,MAAMnB,cAAc,GAAGmB,KAAK,CAAC1F,MAAM,CAACmQ,IAAI,IACtCA,IAAI,CAACC,SAAS,IAAID,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACG,MAAM,KAAK,WACjD,CAAC;IAED,IAAI/L,cAAc,CAACqF,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC;IAEzC,MAAM4G,WAAW,GAAG,CAAC,CAAC;IACtBjM,cAAc,CAACnE,OAAO,CAAC+P,IAAI,IAAI;MAC7B,MAAMnB,IAAI,GAAGmB,IAAI,CAACI,WAAW,IAAIJ,IAAI,CAAClB,SAAS,IAAIkB,IAAI,CAACjB,OAAO,IAAIiB,IAAI,CAACnB,IAAI;MAC5E,IAAIA,IAAI,EAAE;QACR,MAAMI,OAAO,GAAG,IAAItO,IAAI,CAACkO,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC;QAC7CyB,WAAW,CAACpB,OAAO,CAAC,GAAG,IAAI;MAC7B;IACF,CAAC,CAAC;IAEF,MAAMC,WAAW,GAAGjM,MAAM,CAACkM,IAAI,CAACkB,WAAW,CAAC,CAACtH,IAAI,CAAC,CAAC1I,CAAC,EAAE2I,CAAC,KAAK,IAAIrI,IAAI,CAACqI,CAAC,CAAC,GAAG,IAAIrI,IAAI,CAACN,CAAC,CAAC,CAAC;IACtF,IAAI+O,MAAM,GAAG,CAAC;IACd,IAAIC,WAAW,GAAG,IAAI1O,IAAI,CAAC,CAAC;IAE5B,KAAK,IAAI2O,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACzF,MAAM,EAAE6F,CAAC,EAAE,EAAE;MAC3C,MAAMgB,QAAQ,GAAG,IAAI3P,IAAI,CAACuO,WAAW,CAACI,CAAC,CAAC,CAAC;MACzC,MAAME,QAAQ,GAAG9G,IAAI,CAAC+G,KAAK,CAAC,CAACJ,WAAW,GAAGiB,QAAQ,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;MAE7E,IAAId,QAAQ,KAAKF,CAAC,EAAE;QAClBF,MAAM,EAAE;MACV,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOA,MAAM;EACf;EAEA7C,0BAA0BA,CAAChH,KAAK,EAAE;IAChC,OAAOA,KAAK,CAAC1F,MAAM,CAACmQ,IAAI,IACtB,CAACA,IAAI,CAACC,SAAS,IAAID,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACG,MAAM,KAAK,WAAW,MAC1DH,IAAI,CAACO,QAAQ,KAAK,MAAM,IAAIP,IAAI,CAACO,QAAQ,KAAK,QAAQ,IAAIP,IAAI,CAACO,QAAQ,KAAK,CAAC,CAChF,CAAC,CAAC9G,MAAM;EACV;EAEA+C,yBAAyBA,CAACjH,KAAK,EAAE;IAC/B,OAAOA,KAAK,CAAC1F,MAAM,CAACmQ,IAAI,IAAI;MAC1B,IAAI,CAACA,IAAI,CAACC,SAAS,IAAI,CAACD,IAAI,CAACE,IAAI,EAAE,OAAO,KAAK;MAE/C,MAAMM,aAAa,GAAG,IAAI7P,IAAI,CAACqP,IAAI,CAACI,WAAW,IAAIJ,IAAI,CAACjB,OAAO,CAAC;MAChE,MAAM0B,OAAO,GAAG,IAAI9P,IAAI,CAACqP,IAAI,CAACS,OAAO,IAAIT,IAAI,CAACU,GAAG,IAAIV,IAAI,CAACW,QAAQ,CAAC;MAEnE,OAAOF,OAAO,IAAID,aAAa,GAAGC,OAAO;IAC3C,CAAC,CAAC,CAAChH,MAAM;EACX;EAEAgD,sBAAsBA,CAAClH,KAAK,EAAE;IAC5B,MAAMsK,UAAU,GAAG,IAAIlP,IAAI,CAAC,CAAC;IAC7BkP,UAAU,CAACxG,OAAO,CAACwG,UAAU,CAACvG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;IAE5C,OAAO/D,KAAK,CAAC1F,MAAM,CAACmQ,IAAI,IAAI;MAC1B,MAAMnB,IAAI,GAAGmB,IAAI,CAACI,WAAW,IAAIJ,IAAI,CAAClB,SAAS,IAAIkB,IAAI,CAACjB,OAAO,IAAIiB,IAAI,CAACnB,IAAI;MAC5E,OAAOA,IAAI,IAAI,IAAIlO,IAAI,CAACkO,IAAI,CAAC,IAAIgB,UAAU;IAC7C,CAAC,CAAC,CAACpG,MAAM;EACX;EAEAiD,uBAAuBA,CAACnH,KAAK,EAAE;IAC7B,MAAMqL,WAAW,GAAG,IAAIjQ,IAAI,CAAC,CAAC;IAC9BiQ,WAAW,CAACC,QAAQ,CAACD,WAAW,CAACE,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;IAEhD,OAAOvL,KAAK,CAAC1F,MAAM,CAACmQ,IAAI,IAAI;MAC1B,MAAMnB,IAAI,GAAGmB,IAAI,CAACI,WAAW,IAAIJ,IAAI,CAAClB,SAAS,IAAIkB,IAAI,CAACjB,OAAO;MAC/D,OAAOF,IAAI,IAAI,IAAIlO,IAAI,CAACkO,IAAI,CAAC,IAAI+B,WAAW;IAC9C,CAAC,CAAC,CAACnH,MAAM;EACX;EAEAkD,uBAAuBA,CAACpH,KAAK,EAAE;IAC7B,MAAM8I,UAAU,GAAG,IAAIF,GAAG,CAAC,CAAC;IAC5B5I,KAAK,CAACtF,OAAO,CAAC+P,IAAI,IAAI;MACpB,IAAIA,IAAI,CAAClN,QAAQ,EAAE;QACjBuL,UAAU,CAACI,GAAG,CAACuB,IAAI,CAAClN,QAAQ,CAAC;MAC/B;IACF,CAAC,CAAC;IACF,OAAOuL,UAAU,CAACK,IAAI;EACxB;EAEA9B,sBAAsBA,CAACrH,KAAK,EAAE;IAC5B,OAAOA,KAAK,CAAC1F,MAAM,CAACmQ,IAAI,IAAIA,IAAI,CAACO,QAAQ,IAAIP,IAAI,CAACO,QAAQ,KAAK,MAAM,CAAC,CAAC9G,MAAM;EAC/E;EAEAoD,qBAAqBA,CAACtH,KAAK,EAAE;IAC3B,OAAOA,KAAK,CAAC1F,MAAM,CAACmQ,IAAI,IAAIA,IAAI,CAACS,OAAO,IAAIT,IAAI,CAACU,GAAG,IAAIV,IAAI,CAACW,QAAQ,CAAC,CAAClH,MAAM;EAC/E;EAEAqD,uBAAuBA,CAACiE,QAAQ,EAAE;IAChC,OAAOA,QAAQ,CAAC5N,MAAM,CAAC,CAACqG,KAAK,EAAEwH,OAAO,KAAK;MACzC,OAAOxH,KAAK,IAAIwH,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAC3N,IAAI,IAAI,CAAC,CAAC;IAC7E,CAAC,EAAE,CAAC,CAAC;EACP;EAEA2J,2BAA2BA,CAAC+D,QAAQ,EAAE;IACpC,OAAOrI,IAAI,CAACgH,GAAG,CAAC,GAAGqB,QAAQ,CAAClP,GAAG,CAACmP,OAAO,IACrCA,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAC3N,IAAI,IAAI,CAC3D,CAAC,EAAE,CAAC,CAAC;EACP;EAEA6J,oBAAoBA,CAAC6D,QAAQ,EAAE;IAC7B,IAAIA,QAAQ,CAACtH,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC;IAEnC,MAAM0H,cAAc,GAAG,CAAC,CAAC;IACzBJ,QAAQ,CAAC9Q,OAAO,CAAC+Q,OAAO,IAAI;MAC1B,MAAMnC,IAAI,GAAGmC,OAAO,CAAClC,SAAS,IAAIkC,OAAO,CAACnC,IAAI,IAAImC,OAAO,CAAChJ,SAAS;MACnE,IAAI6G,IAAI,EAAE;QACR,MAAMI,OAAO,GAAG,IAAItO,IAAI,CAACkO,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC;QAC7CuC,cAAc,CAAClC,OAAO,CAAC,GAAG,IAAI;MAChC;IACF,CAAC,CAAC;IAEF,MAAMC,WAAW,GAAGjM,MAAM,CAACkM,IAAI,CAACgC,cAAc,CAAC,CAACpI,IAAI,CAAC,CAAC1I,CAAC,EAAE2I,CAAC,KAAK,IAAIrI,IAAI,CAACqI,CAAC,CAAC,GAAG,IAAIrI,IAAI,CAACN,CAAC,CAAC,CAAC;IACzF,IAAI+O,MAAM,GAAG,CAAC;IACd,IAAIC,WAAW,GAAG,IAAI1O,IAAI,CAAC,CAAC;IAE5B,KAAK,IAAI2O,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACzF,MAAM,EAAE6F,CAAC,EAAE,EAAE;MAC3C,MAAM8B,WAAW,GAAG,IAAIzQ,IAAI,CAACuO,WAAW,CAACI,CAAC,CAAC,CAAC;MAC5C,MAAME,QAAQ,GAAG9G,IAAI,CAAC+G,KAAK,CAAC,CAACJ,WAAW,GAAG+B,WAAW,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;MAEhF,IAAI5B,QAAQ,KAAKF,CAAC,EAAE;QAClBF,MAAM,EAAE;MACV,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOA,MAAM;EACf;EAEAhC,6BAA6BA,CAAC2D,QAAQ,EAAE;IACtC,IAAIA,QAAQ,CAACtH,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC;IACnC,MAAM4H,SAAS,GAAG,IAAI,CAACvE,uBAAuB,CAACiE,QAAQ,CAAC;IACxD,OAAOrI,IAAI,CAACuB,KAAK,CAACoH,SAAS,GAAGN,QAAQ,CAACtH,MAAM,CAAC;EAChD;EAEAsD,0BAA0BA,CAACgE,QAAQ,EAAE;IACnC,OAAOA,QAAQ,CAAC5N,MAAM,CAAC,CAACqG,KAAK,EAAEwH,OAAO,KAAK;MACzC,MAAME,QAAQ,GAAGF,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAC3N,IAAI,IAAI2N,OAAO,CAACM,OAAO,IAAI,CAAC;MACzE;MACA,OAAO9H,KAAK,IAAI0H,QAAQ,GAAG,GAAG,GAAGxI,IAAI,CAACuB,KAAK,CAACiH,QAAQ,GAAG,EAAE,CAAC,GAAGA,QAAQ,CAAC;IACxE,CAAC,EAAE,CAAC,CAAC;EACP;EAEA7D,qBAAqBA,CAAC0D,QAAQ,EAAE;IAC9B,MAAMlO,YAAY,GAAG,CAAC,CAAC;IACvBkO,QAAQ,CAAC9Q,OAAO,CAAC+Q,OAAO,IAAI;MAC1B,MAAMlO,QAAQ,GAAGkO,OAAO,CAAClO,QAAQ,IAAI,SAAS;MAC9C,MAAMO,IAAI,GAAG2N,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAC3N,IAAI,IAAI,CAAC;MACvER,YAAY,CAACC,QAAQ,CAAC,GAAG,CAACD,YAAY,CAACC,QAAQ,CAAC,IAAI,CAAC,IAAIO,IAAI;IAC/D,CAAC,CAAC;IACF,OAAOR,YAAY;EACrB;EAEAyK,yBAAyBA,CAACyD,QAAQ,EAAE;IAClC,MAAM9K,gBAAgB,GAAG,CAAC,CAAC;IAC3B8K,QAAQ,CAAC9Q,OAAO,CAAC+Q,OAAO,IAAI;MAC1B,MAAMlO,QAAQ,GAAGkO,OAAO,CAAClO,QAAQ,IAAI,SAAS;MAC9CmD,gBAAgB,CAACnD,QAAQ,CAAC,GAAG,CAACmD,gBAAgB,CAACnD,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;IACpE,CAAC,CAAC;IACF,OAAOmD,gBAAgB;EACzB;EAEAsH,yBAAyBA,CAACwD,QAAQ,EAAE;IAClC,MAAM1C,UAAU,GAAG,IAAIF,GAAG,CAAC,CAAC;IAC5B4C,QAAQ,CAAC9Q,OAAO,CAAC+Q,OAAO,IAAI;MAC1B,IAAIA,OAAO,CAAClO,QAAQ,EAAE;QACpBuL,UAAU,CAACI,GAAG,CAACuC,OAAO,CAAClO,QAAQ,CAAC;MAClC;IACF,CAAC,CAAC;IACF,OAAOuL,UAAU,CAACK,IAAI;EACxB;EAEA6C,2BAA2BA,CAACR,QAAQ,EAAE;IACpC,MAAMS,kBAAkB,GAAG,CAAC,CAAC;IAC7BT,QAAQ,CAAC9Q,OAAO,CAAC+Q,OAAO,IAAI;MAC1B,MAAME,QAAQ,GAAGF,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAC3N,IAAI,IAAI,CAAC;MAC3EmO,kBAAkB,CAACN,QAAQ,CAAC,GAAG,CAACM,kBAAkB,CAACN,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;IACxE,CAAC,CAAC;IACF,OAAOM,kBAAkB;EAC3B;;EAEA;EACA1E,uBAAuBA,CAACiE,QAAQ,EAAE;IAChC,OAAOA,QAAQ,CAAC5N,MAAM,CAAC,CAACqG,KAAK,EAAEwH,OAAO,KAAK;MACzC,OAAOxH,KAAK,IAAIwH,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAC3N,IAAI,IAAI2N,OAAO,CAACM,OAAO,IAAI,CAAC,CAAC;IAChG,CAAC,EAAE,CAAC,CAAC;EACP;;EAEA;EACAtE,2BAA2BA,CAAC+D,QAAQ,EAAE;IACpC,OAAOrI,IAAI,CAACgH,GAAG,CAAC,GAAGqB,QAAQ,CAAClP,GAAG,CAACmP,OAAO,IACrCA,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAC3N,IAAI,IAAI2N,OAAO,CAACM,OAAO,IAAI,CAC9E,CAAC,EAAE,CAAC,CAAC;EACP;EAEA7D,mBAAmBA,CAACpC,KAAK,EAAE9F,KAAK,EAAEwL,QAAQ,EAAE;IAC1C,MAAMU,QAAQ,GAAG,IAAItD,GAAG,CAAC,CAAC;IAE1B,CAAC,GAAG9C,KAAK,EAAE,GAAG9F,KAAK,EAAE,GAAGwL,QAAQ,CAAC,CAAC9Q,OAAO,CAACyR,IAAI,IAAI;MAChD,MAAM7C,IAAI,GAAG6C,IAAI,CAAC5C,SAAS,IAAI4C,IAAI,CAAC3C,OAAO,IAAI2C,IAAI,CAAC7C,IAAI,IAAI6C,IAAI,CAAC1J,SAAS;MAC1E,IAAI6G,IAAI,EAAE;QACR4C,QAAQ,CAAChD,GAAG,CAAC,IAAI9N,IAAI,CAACkO,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC,CAAC;MAC7C;IACF,CAAC,CAAC;IAEF,OAAO6C,QAAQ,CAAC/C,IAAI;EACtB;EAEAhB,sBAAsBA,CAACrC,KAAK,EAAE9F,KAAK,EAAEwL,QAAQ,EAAE;IAC7C;IACA,MAAMU,QAAQ,GAAG,IAAItD,GAAG,CAAC,CAAC;IAE1B,CAAC,GAAG9C,KAAK,EAAE,GAAG9F,KAAK,EAAE,GAAGwL,QAAQ,CAAC,CAAC9Q,OAAO,CAACyR,IAAI,IAAI;MAChD,MAAM7C,IAAI,GAAG6C,IAAI,CAAC5C,SAAS,IAAI4C,IAAI,CAAC3C,OAAO,IAAI2C,IAAI,CAAC7C,IAAI,IAAI6C,IAAI,CAAC1J,SAAS;MAC1E,IAAI6G,IAAI,EAAE;QACR4C,QAAQ,CAAChD,GAAG,CAAC,IAAI9N,IAAI,CAACkO,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC,CAAC;MAC7C;IACF,CAAC,CAAC;IAEF,MAAMM,WAAW,GAAGZ,KAAK,CAACqD,IAAI,CAACF,QAAQ,CAAC,CAAC1I,IAAI,CAAC,CAAC1I,CAAC,EAAE2I,CAAC,KAAK,IAAIrI,IAAI,CAACqI,CAAC,CAAC,GAAG,IAAIrI,IAAI,CAACN,CAAC,CAAC,CAAC;IAClF,IAAI+O,MAAM,GAAG,CAAC;IACd,IAAIC,WAAW,GAAG,IAAI1O,IAAI,CAAC,CAAC;IAE5B,KAAK,IAAI2O,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACzF,MAAM,EAAE6F,CAAC,EAAE,EAAE;MAC3C,MAAMsC,YAAY,GAAG,IAAIjR,IAAI,CAACuO,WAAW,CAACI,CAAC,CAAC,CAAC;MAC7C,MAAME,QAAQ,GAAG9G,IAAI,CAAC+G,KAAK,CAAC,CAACJ,WAAW,GAAGuC,YAAY,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;MAEjF,IAAIpC,QAAQ,KAAKF,CAAC,EAAE;QAClBF,MAAM,EAAE;MACV,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOA,MAAM;EACf;AACF;AAEA,OAAO,MAAMyC,kBAAkB,GAAG,IAAIjT,kBAAkB,CAAC,CAAC;AAC1D,eAAeiT,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}