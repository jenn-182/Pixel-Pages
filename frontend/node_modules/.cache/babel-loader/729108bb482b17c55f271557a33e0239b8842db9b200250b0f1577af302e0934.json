{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nconst useFocusSessions = () => {\n  _s();\n  const [sessions, setSessions] = useState([]);\n  const [loading, setLoading] = useState(true);\n\n  // For now, we'll use localStorage since we don't have backend endpoints yet\n  const STORAGE_KEY = 'pixelPages_focusSessions';\n  const LOGS_STORAGE_KEY = 'pixelPages_focusLogs';\n\n  // Load sessions from localStorage\n  const loadSessions = () => {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEY);\n      if (stored) {\n        setSessions(JSON.parse(stored));\n      }\n    } catch (error) {\n      console.error('Error loading focus sessions:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Save sessions to localStorage\n  const saveSessions = newSessions => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(newSessions));\n    } catch (error) {\n      console.error('Error saving focus sessions:', error);\n    }\n  };\n\n  // Create new session category\n  const createSession = async sessionData => {\n    try {\n      const newSession = {\n        id: Date.now().toString(),\n        name: sessionData.name,\n        description: sessionData.description || '',\n        colorCode: sessionData.colorCode || '#8B5CF6',\n        tag: sessionData.tag || '',\n        workDuration: sessionData.workDuration || 25,\n        breakDuration: sessionData.breakDuration || 5,\n        longBreakDuration: sessionData.longBreakDuration || 15,\n        cycles: sessionData.cycles || 1,\n        createdAt: new Date().toISOString(),\n        totalTimeLogged: 0\n      };\n      const updatedSessions = [...sessions, newSession];\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return newSession;\n    } catch (error) {\n      console.error('Error creating session:', error);\n      throw error;\n    }\n  };\n\n  // Update session category\n  const updateSession = async (sessionId, sessionData) => {\n    try {\n      const updatedSessions = sessions.map(session => session.id === sessionId ? {\n        ...session,\n        ...sessionData,\n        updatedAt: new Date().toISOString()\n      } : session);\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return updatedSessions.find(s => s.id === sessionId);\n    } catch (error) {\n      console.error('Error updating session:', error);\n      throw error;\n    }\n  };\n\n  // Delete session category\n  const deleteSession = async sessionId => {\n    try {\n      const updatedSessions = sessions.filter(s => s.id !== sessionId);\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n\n      // Also remove related logs\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      const updatedLogs = logs.filter(log => log.sessionId !== sessionId);\n      localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(updatedLogs));\n    } catch (error) {\n      console.error('Error deleting session:', error);\n      throw error;\n    }\n  };\n\n  // Log completed focus time\n  const logFocusTime = async (sessionId, timeSpent, date = new Date()) => {\n    try {\n      const logEntry = {\n        id: Date.now().toString(),\n        sessionId,\n        timeSpent,\n        // in minutes\n        date: date.toISOString(),\n        completed: true,\n        createdAt: new Date().toISOString()\n      };\n\n      // Save to logs\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      const updatedLogs = [...logs, logEntry];\n      localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(updatedLogs));\n\n      // Update session's total time\n      const updatedSessions = sessions.map(session => session.id === sessionId ? {\n        ...session,\n        totalTimeLogged: (session.totalTimeLogged || 0) + timeSpent\n      } : session);\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return logEntry;\n    } catch (error) {\n      console.error('Error logging focus time:', error);\n      throw error;\n    }\n  };\n\n  // Get focus logs for a session\n  const getSessionLogs = sessionId => {\n    try {\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      return logs.filter(log => log.sessionId === sessionId);\n    } catch (error) {\n      console.error('Error getting session logs:', error);\n      return [];\n    }\n  };\n\n  // Get all focus logs\n  const getAllLogs = () => {\n    try {\n      return JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n    } catch (error) {\n      console.error('Error getting all logs:', error);\n      return [];\n    }\n  };\n  useEffect(() => {\n    loadSessions();\n  }, []);\n  return {\n    sessions,\n    loading,\n    createSession,\n    updateSession,\n    deleteSession,\n    logFocusTime,\n    getSessionLogs,\n    getAllLogs,\n    refetch: loadSessions\n  };\n};\n_s(useFocusSessions, \"TgG2i7AZommEFr3q/aeiXxYueSg=\");\nexport default useFocusSessions;\n\n// Replace the logSession call with direct localStorage manipulation\nconst handleSubmit = async e => {\n  e.preventDefault();\n  if (!formData.duration || formData.duration <= 0) {\n    alert('Please enter a valid duration');\n    return;\n  }\n  try {\n    let sessionToLog;\n    if (formData.sessionId) {\n      sessionToLog = sessions.find(s => s.id === formData.sessionId);\n    } else if (formData.customSessionName) {\n      sessionToLog = {\n        id: `manual_${Date.now()}`,\n        name: formData.customSessionName,\n        tag: 'other',\n        colorCode: '#6B7280'\n      };\n    } else {\n      alert('Please select a session or enter a custom session name');\n      return;\n    }\n\n    // Create the log entry\n    const logEntry = {\n      id: `log_${Date.now()}`,\n      sessionId: sessionToLog.id,\n      sessionName: sessionToLog.name,\n      timeSpent: parseInt(formData.duration),\n      date: formData.date,\n      timestamp: new Date().toISOString(),\n      notes: formData.notes,\n      isManualEntry: true\n    };\n\n    // Get existing logs from localStorage\n    const existingLogs = JSON.parse(localStorage.getItem('focusSessionLogs') || '[]');\n\n    // Add new log\n    existingLogs.push(logEntry);\n\n    // Save back to localStorage\n    localStorage.setItem('focusSessionLogs', JSON.stringify(existingLogs));\n    console.log('Successfully saved log entry:', logEntry);\n    resetForm();\n    onClose();\n\n    // Call the parent's onSubmit to refresh stats\n    if (onSubmit) {\n      onSubmit();\n    }\n    alert(`Successfully logged ${formData.duration} minutes for \"${sessionToLog.name}\"`);\n  } catch (error) {\n    console.error('Failed to save log entry:', error);\n    alert(`Failed to log time entry: ${error.message || 'Please try again.'}`);\n  }\n};","map":{"version":3,"names":["useState","useEffect","useFocusSessions","_s","sessions","setSessions","loading","setLoading","STORAGE_KEY","LOGS_STORAGE_KEY","loadSessions","stored","localStorage","getItem","JSON","parse","error","console","saveSessions","newSessions","setItem","stringify","createSession","sessionData","newSession","id","Date","now","toString","name","description","colorCode","tag","workDuration","breakDuration","longBreakDuration","cycles","createdAt","toISOString","totalTimeLogged","updatedSessions","updateSession","sessionId","map","session","updatedAt","find","s","deleteSession","filter","logs","updatedLogs","log","logFocusTime","timeSpent","date","logEntry","completed","getSessionLogs","getAllLogs","refetch","handleSubmit","e","preventDefault","formData","duration","alert","sessionToLog","customSessionName","sessionName","parseInt","timestamp","notes","isManualEntry","existingLogs","push","resetForm","onClose","onSubmit","message"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/hooks/useFocusSessions.js"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nconst useFocusSessions = () => {\n  const [sessions, setSessions] = useState([]);\n  const [loading, setLoading] = useState(true);\n\n  // For now, we'll use localStorage since we don't have backend endpoints yet\n  const STORAGE_KEY = 'pixelPages_focusSessions';\n  const LOGS_STORAGE_KEY = 'pixelPages_focusLogs';\n\n  // Load sessions from localStorage\n  const loadSessions = () => {\n    try {\n      const stored = localStorage.getItem(STORAGE_KEY);\n      if (stored) {\n        setSessions(JSON.parse(stored));\n      }\n    } catch (error) {\n      console.error('Error loading focus sessions:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Save sessions to localStorage\n  const saveSessions = (newSessions) => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(newSessions));\n    } catch (error) {\n      console.error('Error saving focus sessions:', error);\n    }\n  };\n\n  // Create new session category\n  const createSession = async (sessionData) => {\n    try {\n      const newSession = {\n        id: Date.now().toString(),\n        name: sessionData.name,\n        description: sessionData.description || '',\n        colorCode: sessionData.colorCode || '#8B5CF6',\n        tag: sessionData.tag || '',\n        workDuration: sessionData.workDuration || 25,\n        breakDuration: sessionData.breakDuration || 5,\n        longBreakDuration: sessionData.longBreakDuration || 15,\n        cycles: sessionData.cycles || 1,\n        createdAt: new Date().toISOString(),\n        totalTimeLogged: 0\n      };\n\n      const updatedSessions = [...sessions, newSession];\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return newSession;\n    } catch (error) {\n      console.error('Error creating session:', error);\n      throw error;\n    }\n  };\n\n  // Update session category\n  const updateSession = async (sessionId, sessionData) => {\n    try {\n      const updatedSessions = sessions.map(session => \n        session.id === sessionId \n          ? { ...session, ...sessionData, updatedAt: new Date().toISOString() }\n          : session\n      );\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      return updatedSessions.find(s => s.id === sessionId);\n    } catch (error) {\n      console.error('Error updating session:', error);\n      throw error;\n    }\n  };\n\n  // Delete session category\n  const deleteSession = async (sessionId) => {\n    try {\n      const updatedSessions = sessions.filter(s => s.id !== sessionId);\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n      \n      // Also remove related logs\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      const updatedLogs = logs.filter(log => log.sessionId !== sessionId);\n      localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(updatedLogs));\n    } catch (error) {\n      console.error('Error deleting session:', error);\n      throw error;\n    }\n  };\n\n  // Log completed focus time\n  const logFocusTime = async (sessionId, timeSpent, date = new Date()) => {\n    try {\n      const logEntry = {\n        id: Date.now().toString(),\n        sessionId,\n        timeSpent, // in minutes\n        date: date.toISOString(),\n        completed: true,\n        createdAt: new Date().toISOString()\n      };\n\n      // Save to logs\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      const updatedLogs = [...logs, logEntry];\n      localStorage.setItem(LOGS_STORAGE_KEY, JSON.stringify(updatedLogs));\n\n      // Update session's total time\n      const updatedSessions = sessions.map(session => \n        session.id === sessionId \n          ? { ...session, totalTimeLogged: (session.totalTimeLogged || 0) + timeSpent }\n          : session\n      );\n      setSessions(updatedSessions);\n      saveSessions(updatedSessions);\n\n      return logEntry;\n    } catch (error) {\n      console.error('Error logging focus time:', error);\n      throw error;\n    }\n  };\n\n  // Get focus logs for a session\n  const getSessionLogs = (sessionId) => {\n    try {\n      const logs = JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n      return logs.filter(log => log.sessionId === sessionId);\n    } catch (error) {\n      console.error('Error getting session logs:', error);\n      return [];\n    }\n  };\n\n  // Get all focus logs\n  const getAllLogs = () => {\n    try {\n      return JSON.parse(localStorage.getItem(LOGS_STORAGE_KEY) || '[]');\n    } catch (error) {\n      console.error('Error getting all logs:', error);\n      return [];\n    }\n  };\n\n  useEffect(() => {\n    loadSessions();\n  }, []);\n\n  return {\n    sessions,\n    loading,\n    createSession,\n    updateSession,\n    deleteSession,\n    logFocusTime,\n    getSessionLogs,\n    getAllLogs,\n    refetch: loadSessions\n  };\n};\n\nexport default useFocusSessions;\n\n// Replace the logSession call with direct localStorage manipulation\nconst handleSubmit = async (e) => {\n    e.preventDefault();\n    \n    if (!formData.duration || formData.duration <= 0) {\n      alert('Please enter a valid duration');\n      return;\n    }\n\n    try {\n      let sessionToLog;\n      \n      if (formData.sessionId) {\n        sessionToLog = sessions.find(s => s.id === formData.sessionId);\n      } else if (formData.customSessionName) {\n        sessionToLog = {\n          id: `manual_${Date.now()}`,\n          name: formData.customSessionName,\n          tag: 'other',\n          colorCode: '#6B7280'\n        };\n      } else {\n        alert('Please select a session or enter a custom session name');\n        return;\n      }\n\n      // Create the log entry\n      const logEntry = {\n        id: `log_${Date.now()}`,\n        sessionId: sessionToLog.id,\n        sessionName: sessionToLog.name,\n        timeSpent: parseInt(formData.duration),\n        date: formData.date,\n        timestamp: new Date().toISOString(),\n        notes: formData.notes,\n        isManualEntry: true\n      };\n\n      // Get existing logs from localStorage\n      const existingLogs = JSON.parse(localStorage.getItem('focusSessionLogs') || '[]');\n      \n      // Add new log\n      existingLogs.push(logEntry);\n      \n      // Save back to localStorage\n      localStorage.setItem('focusSessionLogs', JSON.stringify(existingLogs));\n\n      console.log('Successfully saved log entry:', logEntry);\n\n      resetForm();\n      onClose();\n      \n      // Call the parent's onSubmit to refresh stats\n      if (onSubmit) {\n        onSubmit();\n      }\n      \n      alert(`Successfully logged ${formData.duration} minutes for \"${sessionToLog.name}\"`);\n      \n    } catch (error) {\n      console.error('Failed to save log entry:', error);\n      alert(`Failed to log time entry: ${error.message || 'Please try again.'}`);\n    }\n  };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}