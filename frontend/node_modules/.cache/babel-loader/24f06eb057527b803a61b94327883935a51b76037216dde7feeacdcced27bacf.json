{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nconst useFolders = () => {\n  _s();\n  const [folders, setFolders] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Fetch all root folders\n  const fetchFolders = async () => {\n    try {\n      setLoading(true);\n      const response = await fetch('http://localhost:8080/api/folders');\n      if (!response.ok) {\n        throw new Error('Failed to fetch folders');\n      }\n      const data = await response.json();\n      setFolders(data);\n      setError(null);\n    } catch (err) {\n      setError(err.message);\n      console.error('Error fetching folders:', err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Create new folder\n  const createFolder = async folderData => {\n    try {\n      const response = await fetch('http://localhost:8080/api/folders', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(folderData)\n      });\n      if (!response.ok) {\n        if (response.status === 409) {\n          throw new Error('A folder with this name already exists in this location');\n        }\n        throw new Error('Failed to create folder');\n      }\n      const newFolder = await response.json();\n\n      // Update local state\n      if (!folderData.parentFolderId) {\n        setFolders(prev => [...prev, newFolder]);\n      } else {\n        // Refresh folders to get updated hierarchy\n        await fetchFolders();\n      }\n      return newFolder;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Update folder\n  const updateFolder = async (id, folderData) => {\n    try {\n      const response = await fetch(`http://localhost:8080/api/folders/${id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(folderData)\n      });\n      if (!response.ok) {\n        throw new Error('Failed to update folder');\n      }\n      const updatedFolder = await response.json();\n\n      // Update local state\n      setFolders(prev => prev.map(folder => folder.id === id ? updatedFolder : folder));\n      return updatedFolder;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Delete folder\n  const deleteFolder = async (id, moveContentsToParent = true) => {\n    try {\n      const response = await fetch(`http://localhost:8080/api/folders/${id}?moveContentsToParent=${moveContentsToParent}`, {\n        method: 'DELETE'\n      });\n      if (!response.ok) {\n        throw new Error('Failed to delete folder');\n      }\n\n      // Update local state\n      setFolders(prev => prev.filter(folder => folder.id !== id));\n      return true;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Get folder by ID\n  const getFolderById = async id => {\n    try {\n      const response = await fetch(`http://localhost:8080/api/folders/${id}`);\n      if (!response.ok) {\n        throw new Error('Failed to fetch folder');\n      }\n      return await response.json();\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Get folder path (breadcrumb)\n  const getFolderPath = async id => {\n    try {\n      const response = await fetch(`http://localhost:8080/api/folders/${id}/path`);\n      if (!response.ok) {\n        throw new Error('Failed to fetch folder path');\n      }\n      return await response.json();\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Search folders\n  const searchFolders = async query => {\n    try {\n      const response = await fetch(`http://localhost:8080/api/folders/search?query=${encodeURIComponent(query)}`);\n      if (!response.ok) {\n        throw new Error('Failed to search folders');\n      }\n      return await response.json();\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Check if folder name is unique\n  const checkFolderNameUnique = async (name, parentFolderId = null) => {\n    try {\n      const url = new URL('http://localhost:8080/api/folders/check-name');\n      url.searchParams.append('name', name);\n      if (parentFolderId) {\n        url.searchParams.append('parentFolderId', parentFolderId);\n      }\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error('Failed to check folder name');\n      }\n      const data = await response.json();\n      return data.isUnique;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Load folders on mount\n  useEffect(() => {\n    fetchFolders();\n  }, []);\n  return {\n    folders,\n    loading,\n    error,\n    refetch: fetchFolders,\n    createFolder,\n    updateFolder,\n    deleteFolder,\n    getFolderById,\n    getFolderPath,\n    searchFolders,\n    checkFolderNameUnique\n  };\n};\n_s(useFolders, \"aQenjvS7Yx7VbFcYZP2EqPbYyEA=\");\nexport default useFolders;","map":{"version":3,"names":["useState","useEffect","useFolders","_s","folders","setFolders","loading","setLoading","error","setError","fetchFolders","response","fetch","ok","Error","data","json","err","message","console","createFolder","folderData","method","headers","body","JSON","stringify","status","newFolder","parentFolderId","prev","updateFolder","id","updatedFolder","map","folder","deleteFolder","moveContentsToParent","filter","getFolderById","getFolderPath","searchFolders","query","encodeURIComponent","checkFolderNameUnique","name","url","URL","searchParams","append","isUnique","refetch"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/hooks/useFolders.js"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nconst useFolders = () => {\n  const [folders, setFolders] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Fetch all root folders\n  const fetchFolders = async () => {\n    try {\n      setLoading(true);\n      const response = await fetch('http://localhost:8080/api/folders');\n      if (!response.ok) {\n        throw new Error('Failed to fetch folders');\n      }\n      const data = await response.json();\n      setFolders(data);\n      setError(null);\n    } catch (err) {\n      setError(err.message);\n      console.error('Error fetching folders:', err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Create new folder\n  const createFolder = async (folderData) => {\n    try {\n      const response = await fetch('http://localhost:8080/api/folders', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(folderData),\n      });\n\n      if (!response.ok) {\n        if (response.status === 409) {\n          throw new Error('A folder with this name already exists in this location');\n        }\n        throw new Error('Failed to create folder');\n      }\n\n      const newFolder = await response.json();\n      \n      // Update local state\n      if (!folderData.parentFolderId) {\n        setFolders(prev => [...prev, newFolder]);\n      } else {\n        // Refresh folders to get updated hierarchy\n        await fetchFolders();\n      }\n      \n      return newFolder;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Update folder\n  const updateFolder = async (id, folderData) => {\n    try {\n      const response = await fetch(`http://localhost:8080/api/folders/${id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(folderData),\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to update folder');\n      }\n\n      const updatedFolder = await response.json();\n      \n      // Update local state\n      setFolders(prev => \n        prev.map(folder => folder.id === id ? updatedFolder : folder)\n      );\n      \n      return updatedFolder;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Delete folder\n  const deleteFolder = async (id, moveContentsToParent = true) => {\n    try {\n      const response = await fetch(\n        `http://localhost:8080/api/folders/${id}?moveContentsToParent=${moveContentsToParent}`, \n        {\n          method: 'DELETE',\n        }\n      );\n\n      if (!response.ok) {\n        throw new Error('Failed to delete folder');\n      }\n\n      // Update local state\n      setFolders(prev => prev.filter(folder => folder.id !== id));\n      \n      return true;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Get folder by ID\n  const getFolderById = async (id) => {\n    try {\n      const response = await fetch(`http://localhost:8080/api/folders/${id}`);\n      if (!response.ok) {\n        throw new Error('Failed to fetch folder');\n      }\n      return await response.json();\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Get folder path (breadcrumb)\n  const getFolderPath = async (id) => {\n    try {\n      const response = await fetch(`http://localhost:8080/api/folders/${id}/path`);\n      if (!response.ok) {\n        throw new Error('Failed to fetch folder path');\n      }\n      return await response.json();\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Search folders\n  const searchFolders = async (query) => {\n    try {\n      const response = await fetch(`http://localhost:8080/api/folders/search?query=${encodeURIComponent(query)}`);\n      if (!response.ok) {\n        throw new Error('Failed to search folders');\n      }\n      return await response.json();\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Check if folder name is unique\n  const checkFolderNameUnique = async (name, parentFolderId = null) => {\n    try {\n      const url = new URL('http://localhost:8080/api/folders/check-name');\n      url.searchParams.append('name', name);\n      if (parentFolderId) {\n        url.searchParams.append('parentFolderId', parentFolderId);\n      }\n\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error('Failed to check folder name');\n      }\n      const data = await response.json();\n      return data.isUnique;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    }\n  };\n\n  // Load folders on mount\n  useEffect(() => {\n    fetchFolders();\n  }, []);\n\n  return {\n    folders,\n    loading,\n    error,\n    refetch: fetchFolders,\n    createFolder,\n    updateFolder,\n    deleteFolder,\n    getFolderById,\n    getFolderPath,\n    searchFolders,\n    checkFolderNameUnique,\n  };\n};\n\nexport default useFolders;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}