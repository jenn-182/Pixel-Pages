{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport apiService from '../services/api';\nexport const useFocusTimer = username => {\n  _s();\n  const [activeSession, setActiveSession] = useState(null);\n  const [timeRemaining, setTimeRemaining] = useState(0);\n  const [isRunning, setIsRunning] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [currentPhase, setCurrentPhase] = useState('work'); // 'work', 'break', 'long_break'\n  const [currentCycle, setCurrentCycle] = useState(1);\n  const [startTime, setStartTime] = useState(null);\n  const [totalTimeSpent, setTotalTimeSpent] = useState(0);\n  const intervalRef = useRef(null);\n  const startTimeRef = useRef(null);\n\n  // Handle phase completion (work -> break -> work, etc.)\n  const handlePhaseComplete = useCallback(async () => {\n    if (!activeSession || !username) return;\n    try {\n      const phaseStartTime = startTimeRef.current || startTime;\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      console.log('ðŸŽ¯ Phase completed:', {\n        phase: currentPhase,\n        timeSpent: timeSpentMinutes,\n        sessionId: activeSession.id\n      });\n\n      // Save completed phase to backend\n      if (timeSpentMinutes > 0) {\n        const entryData = {\n          sessionId: activeSession.id,\n          ownerUsername: username,\n          timeSpent: timeSpentMinutes,\n          date: new Date().toISOString().split('T')[0],\n          startTime: phaseStartTime.toISOString(),\n          endTime: endTime.toISOString(),\n          completed: true,\n          phase: currentPhase,\n          cycleNumber: currentCycle\n        };\n        console.log('ðŸ’¾ Saving focus entry:', entryData);\n        await apiService.createFocusEntry(entryData);\n        console.log('âœ… Focus entry saved successfully');\n      }\n\n      // Update total time\n      setTotalTimeSpent(prev => prev + timeSpentMinutes);\n\n      // Determine next phase\n      let nextPhase = currentPhase;\n      let nextCycle = currentCycle;\n      let nextDuration = 0;\n      if (currentPhase === 'work') {\n        if (currentCycle >= activeSession.cycles) {\n          // Session complete\n          console.log('ðŸŽ‰ Session completed!');\n          clearInterval(intervalRef.current);\n          setIsRunning(false);\n          resetTimer();\n          return;\n        } else {\n          // Go to break\n          nextPhase = currentCycle % 4 === 0 ? 'long_break' : 'break';\n          nextDuration = nextPhase === 'long_break' ? 15 : activeSession.breakDuration;\n        }\n      } else {\n        // Break finished, go to work\n        nextPhase = 'work';\n        nextCycle = currentCycle + 1;\n        nextDuration = activeSession.workDuration;\n      }\n\n      // Update state for next phase\n      setCurrentPhase(nextPhase);\n      setCurrentCycle(nextCycle);\n      setTimeRemaining(nextDuration * 60);\n      setStartTime(new Date());\n      startTimeRef.current = new Date();\n      console.log('âž¡ï¸ Moving to next phase:', {\n        nextPhase,\n        nextCycle,\n        nextDuration\n      });\n    } catch (err) {\n      console.error('âŒ Error handling phase complete:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle]);\n\n  // Start a focus session\n  const startSession = useCallback(async session => {\n    if (!session || !username) return;\n    try {\n      console.log('ðŸš€ Starting focus session:', session.name);\n      setActiveSession(session);\n      setTimeRemaining(session.workDuration * 60); // Convert minutes to seconds\n      setCurrentPhase('work');\n      setCurrentCycle(1);\n      setTotalTimeSpent(0);\n      setIsRunning(true);\n      setIsPaused(false);\n      setStartTime(new Date());\n      startTimeRef.current = new Date();\n\n      // Start the timer\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          if (prev <= 1) {\n            // Time's up, handle phase completion\n            handlePhaseComplete();\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n    } catch (err) {\n      console.error('âŒ Error starting session:', err);\n    }\n  }, [username, handlePhaseComplete]);\n\n  // Pause/Resume timer\n  const togglePause = useCallback(() => {\n    if (!activeSession) return;\n    if (isRunning && !isPaused) {\n      // Pause\n      clearInterval(intervalRef.current);\n      setIsPaused(true);\n      console.log('â¸ï¸ Timer paused');\n    } else if (isRunning && isPaused) {\n      // Resume\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          if (prev <= 1) {\n            handlePhaseComplete();\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      setIsPaused(false);\n      console.log('â–¶ï¸ Timer resumed');\n    }\n  }, [activeSession, isRunning, isPaused, handlePhaseComplete]);\n\n  // Stop session and save progress\n  const stopSession = useCallback(async () => {\n    if (!activeSession || !username) return;\n    try {\n      clearInterval(intervalRef.current);\n      console.log('ðŸ›‘ Stopping session...');\n\n      // Calculate time spent in this phase\n      const phaseStartTime = startTimeRef.current || startTime;\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      if (timeSpentMinutes > 0) {\n        console.log(`ðŸ’¾ Saving ${timeSpentMinutes} minutes of focus time`);\n\n        // Save the entry to backend\n        const entryData = {\n          sessionId: activeSession.id,\n          ownerUsername: username,\n          timeSpent: timeSpentMinutes,\n          date: new Date().toISOString().split('T')[0],\n          startTime: phaseStartTime.toISOString(),\n          endTime: endTime.toISOString(),\n          completed: false,\n          // Manually stopped\n          phase: currentPhase,\n          cycleNumber: currentCycle,\n          notes: `Session stopped manually (${timeSpentMinutes} minutes)`\n        };\n        await apiService.createFocusEntry(entryData);\n        console.log('âœ… Focus entry saved successfully');\n      }\n\n      // Reset timer state\n      resetTimer();\n    } catch (err) {\n      console.error('âŒ Error stopping session:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle]);\n\n  // Reset timer state\n  const resetTimer = useCallback(() => {\n    clearInterval(intervalRef.current);\n    setActiveSession(null);\n    setTimeRemaining(0);\n    setIsRunning(false);\n    setIsPaused(false);\n    setCurrentPhase('work');\n    setCurrentCycle(1);\n    setStartTime(null);\n    setTotalTimeSpent(0);\n    startTimeRef.current = null;\n    console.log('ðŸ”„ Timer reset');\n  }, []);\n\n  // Format time display\n  const formatTime = useCallback(seconds => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n  return {\n    activeSession,\n    timeRemaining,\n    isRunning,\n    isPaused,\n    currentPhase,\n    currentCycle,\n    totalTimeSpent,\n    startSession,\n    stopSession,\n    togglePause,\n    resetTimer,\n    formatTime: (seconds = timeRemaining) => formatTime(seconds),\n    progress: activeSession ? (activeSession.workDuration * 60 - timeRemaining) / (activeSession.workDuration * 60) * 100 : 0\n  };\n};\n\n// Add default export for backward compatibility\n_s(useFocusTimer, \"wRL92IdDfYMYkIZLe8JPTxaWalg=\");\nexport default useFocusTimer;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","apiService","useFocusTimer","username","_s","activeSession","setActiveSession","timeRemaining","setTimeRemaining","isRunning","setIsRunning","isPaused","setIsPaused","currentPhase","setCurrentPhase","currentCycle","setCurrentCycle","startTime","setStartTime","totalTimeSpent","setTotalTimeSpent","intervalRef","startTimeRef","handlePhaseComplete","phaseStartTime","current","endTime","Date","timeSpentMinutes","Math","round","console","log","phase","timeSpent","sessionId","id","entryData","ownerUsername","date","toISOString","split","completed","cycleNumber","createFocusEntry","prev","nextPhase","nextCycle","nextDuration","cycles","clearInterval","resetTimer","breakDuration","workDuration","err","error","startSession","session","name","setInterval","togglePause","stopSession","notes","formatTime","seconds","mins","floor","secs","toString","padStart","progress"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/hooks/useFocusTimer.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport apiService from '../services/api';\n\nexport const useFocusTimer = (username) => {\n  const [activeSession, setActiveSession] = useState(null);\n  const [timeRemaining, setTimeRemaining] = useState(0);\n  const [isRunning, setIsRunning] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [currentPhase, setCurrentPhase] = useState('work'); // 'work', 'break', 'long_break'\n  const [currentCycle, setCurrentCycle] = useState(1);\n  const [startTime, setStartTime] = useState(null);\n  const [totalTimeSpent, setTotalTimeSpent] = useState(0);\n  \n  const intervalRef = useRef(null);\n  const startTimeRef = useRef(null);\n\n  // Handle phase completion (work -> break -> work, etc.)\n  const handlePhaseComplete = useCallback(async () => {\n    if (!activeSession || !username) return;\n    \n    try {\n      const phaseStartTime = startTimeRef.current || startTime;\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      \n      console.log('ðŸŽ¯ Phase completed:', {\n        phase: currentPhase,\n        timeSpent: timeSpentMinutes,\n        sessionId: activeSession.id\n      });\n      \n      // Save completed phase to backend\n      if (timeSpentMinutes > 0) {\n        const entryData = {\n          sessionId: activeSession.id,\n          ownerUsername: username,\n          timeSpent: timeSpentMinutes,\n          date: new Date().toISOString().split('T')[0],\n          startTime: phaseStartTime.toISOString(),\n          endTime: endTime.toISOString(),\n          completed: true,\n          phase: currentPhase,\n          cycleNumber: currentCycle\n        };\n        \n        console.log('ðŸ’¾ Saving focus entry:', entryData);\n        await apiService.createFocusEntry(entryData);\n        console.log('âœ… Focus entry saved successfully');\n      }\n      \n      // Update total time\n      setTotalTimeSpent(prev => prev + timeSpentMinutes);\n      \n      // Determine next phase\n      let nextPhase = currentPhase;\n      let nextCycle = currentCycle;\n      let nextDuration = 0;\n      \n      if (currentPhase === 'work') {\n        if (currentCycle >= activeSession.cycles) {\n          // Session complete\n          console.log('ðŸŽ‰ Session completed!');\n          clearInterval(intervalRef.current);\n          setIsRunning(false);\n          resetTimer();\n          return;\n        } else {\n          // Go to break\n          nextPhase = currentCycle % 4 === 0 ? 'long_break' : 'break';\n          nextDuration = nextPhase === 'long_break' ? 15 : activeSession.breakDuration;\n        }\n      } else {\n        // Break finished, go to work\n        nextPhase = 'work';\n        nextCycle = currentCycle + 1;\n        nextDuration = activeSession.workDuration;\n      }\n      \n      // Update state for next phase\n      setCurrentPhase(nextPhase);\n      setCurrentCycle(nextCycle);\n      setTimeRemaining(nextDuration * 60);\n      setStartTime(new Date());\n      startTimeRef.current = new Date();\n      \n      console.log('âž¡ï¸ Moving to next phase:', { nextPhase, nextCycle, nextDuration });\n      \n    } catch (err) {\n      console.error('âŒ Error handling phase complete:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle]);\n\n  // Start a focus session\n  const startSession = useCallback(async (session) => {\n    if (!session || !username) return;\n    \n    try {\n      console.log('ðŸš€ Starting focus session:', session.name);\n      \n      setActiveSession(session);\n      setTimeRemaining(session.workDuration * 60); // Convert minutes to seconds\n      setCurrentPhase('work');\n      setCurrentCycle(1);\n      setTotalTimeSpent(0);\n      setIsRunning(true);\n      setIsPaused(false);\n      setStartTime(new Date());\n      startTimeRef.current = new Date();\n      \n      // Start the timer\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          if (prev <= 1) {\n            // Time's up, handle phase completion\n            handlePhaseComplete();\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      \n    } catch (err) {\n      console.error('âŒ Error starting session:', err);\n    }\n  }, [username, handlePhaseComplete]);\n\n  // Pause/Resume timer\n  const togglePause = useCallback(() => {\n    if (!activeSession) return;\n    \n    if (isRunning && !isPaused) {\n      // Pause\n      clearInterval(intervalRef.current);\n      setIsPaused(true);\n      console.log('â¸ï¸ Timer paused');\n    } else if (isRunning && isPaused) {\n      // Resume\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          if (prev <= 1) {\n            handlePhaseComplete();\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      setIsPaused(false);\n      console.log('â–¶ï¸ Timer resumed');\n    }\n  }, [activeSession, isRunning, isPaused, handlePhaseComplete]);\n\n  // Stop session and save progress\n  const stopSession = useCallback(async () => {\n    if (!activeSession || !username) return;\n    \n    try {\n      clearInterval(intervalRef.current);\n      console.log('ðŸ›‘ Stopping session...');\n      \n      // Calculate time spent in this phase\n      const phaseStartTime = startTimeRef.current || startTime;\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      \n      if (timeSpentMinutes > 0) {\n        console.log(`ðŸ’¾ Saving ${timeSpentMinutes} minutes of focus time`);\n        \n        // Save the entry to backend\n        const entryData = {\n          sessionId: activeSession.id,\n          ownerUsername: username,\n          timeSpent: timeSpentMinutes,\n          date: new Date().toISOString().split('T')[0],\n          startTime: phaseStartTime.toISOString(),\n          endTime: endTime.toISOString(),\n          completed: false, // Manually stopped\n          phase: currentPhase,\n          cycleNumber: currentCycle,\n          notes: `Session stopped manually (${timeSpentMinutes} minutes)`\n        };\n        \n        await apiService.createFocusEntry(entryData);\n        console.log('âœ… Focus entry saved successfully');\n      }\n      \n      // Reset timer state\n      resetTimer();\n      \n    } catch (err) {\n      console.error('âŒ Error stopping session:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle]);\n\n  // Reset timer state\n  const resetTimer = useCallback(() => {\n    clearInterval(intervalRef.current);\n    setActiveSession(null);\n    setTimeRemaining(0);\n    setIsRunning(false);\n    setIsPaused(false);\n    setCurrentPhase('work');\n    setCurrentCycle(1);\n    setStartTime(null);\n    setTotalTimeSpent(0);\n    startTimeRef.current = null;\n    console.log('ðŸ”„ Timer reset');\n  }, []);\n\n  // Format time display\n  const formatTime = useCallback((seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    activeSession,\n    timeRemaining,\n    isRunning,\n    isPaused,\n    currentPhase,\n    currentCycle,\n    totalTimeSpent,\n    startSession,\n    stopSession,\n    togglePause,\n    resetTimer,\n    formatTime: (seconds = timeRemaining) => formatTime(seconds),\n    progress: activeSession ? \n      (((activeSession.workDuration * 60) - timeRemaining) / (activeSession.workDuration * 60)) * 100 : 0\n  };\n};\n\n// Add default export for backward compatibility\nexport default useFocusTimer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}