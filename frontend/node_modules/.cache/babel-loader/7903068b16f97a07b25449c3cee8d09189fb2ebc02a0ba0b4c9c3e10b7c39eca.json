{"ast":null,"code":"import { allAchievements, tierInfo } from '../data/achievements';\nclass AchievementService {\n  constructor() {\n    this.unlockedAchievements = this.loadUnlockedAchievements();\n    this.listeners = [];\n  }\n\n  // Load unlocked achievements from localStorage\n  loadUnlockedAchievements() {\n    const saved = localStorage.getItem('unlockedAchievements');\n    return saved ? JSON.parse(saved) : [];\n  }\n\n  // Save unlocked achievements to localStorage\n  saveUnlockedAchievements() {\n    localStorage.setItem('unlockedAchievements', JSON.stringify(this.unlockedAchievements));\n  }\n\n  // Add event listener for achievement unlocks\n  addEventListener(callback) {\n    this.listeners.push(callback);\n  }\n\n  // Remove event listener\n  removeEventListener(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  // Notify listeners of achievement unlock\n  notifyListeners(achievement) {\n    this.listeners.forEach(callback => callback(achievement));\n  }\n\n  // Check if achievement is unlocked\n  isUnlocked(achievementId) {\n    return this.unlockedAchievements.some(a => a.id === achievementId);\n  }\n\n  // Unlock achievement\n  unlockAchievement(achievementId) {\n    if (this.isUnlocked(achievementId)) return false;\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement) return false;\n    const unlockedAchievement = {\n      ...achievement,\n      unlockedAt: new Date().toISOString()\n    };\n    this.unlockedAchievements.push(unlockedAchievement);\n    this.saveUnlockedAchievements();\n\n    // ✅ Sync with backend immediately\n    this.syncAchievementWithBackend(achievementId);\n\n    // Trigger achievement notification\n    this.triggerAchievementNotification(achievement);\n    this.notifyListeners(achievement);\n\n    // Track when achievements are unlocked\n    this.trackAchievementUnlock(achievementId);\n    return true;\n  }\n\n  // Sync achievement with backend\n  async syncAchievementWithBackend(achievementId) {\n    try {\n      const response = await fetch('http://localhost:8080/api/player/achievements/unlock', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          username: 'Jroc_182',\n          // Changed from 'user'\n          achievementId: achievementId\n        })\n      });\n      if (response.ok) {\n        console.log(`✅ Synced ${achievementId} with backend`);\n      } else {\n        console.warn(`⚠️ Failed to sync ${achievementId} with backend`);\n      }\n    } catch (error) {\n      console.error(`❌ Error syncing ${achievementId}:`, error);\n    }\n  }\n\n  // Track when achievements are unlocked\n  trackAchievementUnlock(achievementId) {\n    const unlockedAchievements = this.getUnlockedAchievements();\n    if (!unlockedAchievements.includes(achievementId)) {\n      const newUnlocked = [...unlockedAchievements, achievementId];\n\n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData.unlockedAchievements = newUnlocked;\n      achievementData.unlockDates = {\n        ...achievementData.unlockDates,\n        [achievementId]: new Date().toISOString()\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n    }\n  }\n\n  // Check achievements based on user stats\n  checkAchievements(userStats) {\n    const newlyUnlocked = [];\n    allAchievements.forEach(achievement => {\n      if (!this.isUnlocked(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        }\n      }\n    });\n    return newlyUnlocked;\n  }\n\n  // Enhanced requirement checking\n  meetsRequirement(requirement, userStats) {\n    var _userStats$sessionsBy;\n    switch (requirement.type) {\n      // Note achievements\n      case 'note_count':\n        return (userStats.totalNotes || 0) >= requirement.target;\n      case 'word_count':\n        return (userStats.totalWords || 0) >= requirement.target;\n      case 'unique_tags':\n        return (userStats.uniqueTags || 0) >= requirement.target;\n      case 'daily_notes':\n        // ✅ FIX: Check if user created notes TODAY\n        const today = new Date().toDateString();\n        const notesToday = userStats.notesToday || 0;\n        console.log(`📅 Daily notes check: ${notesToday} notes today (need ${requirement.target})`);\n        return notesToday >= requirement.target;\n      case 'weekend_notes':\n        return (userStats.weekendNotes || 0) >= requirement.target;\n      case 'weekly_notes':\n        return (userStats.notesThisWeek || 0) >= requirement.target;\n      case 'single_note_words':\n        return (userStats.maxWordsInNote || 0) >= requirement.target;\n      case 'single_note_tags':\n        return (userStats.maxTagsInNote || 0) >= requirement.target;\n      case 'streak':\n        return (userStats.noteStreak || 0) >= requirement.target;\n      case 'note_edits':\n        return (userStats.totalEdits || userStats.totalNotes || 0) >= requirement.target;\n\n      // Task achievements\n      case 'task_count':\n        return (userStats.totalTasks || 0) >= requirement.target;\n      case 'daily_tasks':\n        return (userStats.tasksToday || 0) >= requirement.target;\n      case 'weekly_tasks':\n        return (userStats.tasksThisWeek || 0) >= requirement.target;\n      case 'monthly_tasks':\n        return (userStats.tasksThisMonth || 0) >= requirement.target;\n      case 'high_priority_tasks':\n        return (userStats.highPriorityTasks || 0) >= requirement.target;\n      case 'urgent_tasks':\n        return (userStats.urgentTasks || 0) >= requirement.target;\n      case 'early_completions':\n        return (userStats.earlyCompletions || 0) >= requirement.target;\n      case 'completion_streak':\n        return (userStats.taskStreak || 0) >= requirement.target;\n      case 'task_categories':\n        return (userStats.taskCategories || 0) >= requirement.target;\n      case 'task_creation':\n        return (userStats.tasksCreated || 0) >= requirement.target;\n      case 'active_tasks':\n        return (userStats.activeTasks || 0) >= requirement.target;\n      case 'completion_rate':\n        const completionRate = userStats.totalTasks > 0 ? (userStats.completedTasks || 0) / userStats.totalTasks : 0;\n        return completionRate >= requirement.target;\n\n      // Focus achievements\n      case 'session_count':\n        return (userStats.totalSessions || 0) >= requirement.target;\n      case 'total_time':\n        return (userStats.totalFocusTime || 0) >= requirement.target;\n      case 'single_session_duration':\n        return (userStats.maxSessionDuration || 0) >= requirement.target;\n      case 'session_duration_range':\n        const rangeSessions = userStats.sessionsByDuration || {};\n        let rangeCount = 0;\n        for (let duration = requirement.minDuration; duration <= requirement.maxDuration; duration++) {\n          rangeCount += rangeSessions[duration] || 0;\n        }\n        return rangeCount >= requirement.target;\n      case 'pomodoro_count':\n        const pomodoroSessions = ((_userStats$sessionsBy = userStats.sessionsByDuration) === null || _userStats$sessionsBy === void 0 ? void 0 : _userStats$sessionsBy[25]) || 0;\n        return pomodoroSessions >= requirement.target;\n      case 'daily_streak':\n        return (userStats.focusStreak || 0) >= requirement.target;\n      case 'category_sessions':\n        const categorySessions = userStats.categorySessions || {};\n        return (categorySessions[requirement.category] || 0) >= requirement.target;\n      case 'category_time':\n        const categoryTime = userStats.categoryTime || {};\n        return Math.max(...Object.values(categoryTime)) >= requirement.target;\n      case 'all_categories_time':\n        const allCategoryTime = userStats.categoryTime || {};\n        return Object.values(allCategoryTime).every(time => time >= requirement.target);\n      case 'unique_categories':\n        const uniqueCategories = Object.keys(userStats.categorySessions || {}).length;\n        return uniqueCategories >= requirement.target;\n      case 'break_session':\n        const breakSessions = userStats.breakSessions || 0;\n        return breakSessions >= requirement.target;\n      case 'long_sessions':\n        const longSessions = userStats.sessionsOver90Min || 0;\n        return longSessions >= requirement.target;\n      case 'time_variety':\n        const sessionTimes = Object.keys(userStats.sessionsByTime || {}).length;\n        return sessionTimes >= requirement.target;\n\n      // Combo achievements\n      case 'daily_combo':\n        const dailyActivities = userStats.dailyActivities || [];\n        return requirement.activities.every(activity => dailyActivities.includes(activity));\n      case 'weekly_combo':\n        const weeklyActivities = userStats.weeklyActivities || [];\n        return requirement.activities.every(activity => weeklyActivities.includes(activity));\n      case 'combo_streak':\n        return (userStats.comboStreak || 0) >= requirement.target;\n      case 'activity_consistency':\n        return (userStats.activityStreak || 0) >= requirement.target;\n      case 'daily_activity_count':\n        return (userStats.activitiesToday || 0) >= requirement.target;\n      case 'monthly_activity_count':\n        return (userStats.activitiesThisMonth || 0) >= requirement.target;\n\n      // Meta achievements\n      case 'player_level':\n        return (userStats.level || 1) >= requirement.target;\n      case 'total_xp':\n        return (userStats.totalXP || 0) >= requirement.target;\n      case 'achievement_count':\n        return this.unlockedAchievements.length >= requirement.target;\n      case 'completion_percentage':\n        return this.unlockedAchievements.length / allAchievements.length >= requirement.target;\n      case 'tier_completion':\n        const tierAchievements = allAchievements.filter(a => a.tier === requirement.tier);\n        const unlockedInTier = this.unlockedAchievements.filter(a => a.tier === requirement.tier);\n        return unlockedInTier.length / tierAchievements.length >= requirement.target;\n\n      // Time-based achievements\n      case 'time_range':\n        const now = new Date();\n        const hour = now.getHours();\n        if (requirement.startHour > requirement.endHour) {\n          // Crosses midnight\n          return hour >= requirement.startHour || hour < requirement.endHour;\n        }\n        return hour >= requirement.startHour && hour < requirement.endHour;\n      case 'time_before':\n        return new Date().getHours() < requirement.hour;\n      case 'time_after':\n        return new Date().getHours() >= requirement.hour;\n      case 'weekend_activity':\n        const dayOfWeek = new Date().getDay();\n        return (dayOfWeek === 0 || dayOfWeek === 6) && (userStats.weekendActivities || 0) >= requirement.target;\n      case 'speed_writing':\n        return (userStats.fastestWordsPer5Min || 0) >= requirement.words;\n\n      // New cases added\n      case 'tag_count':\n        // ✅ MISSING - needed for TAG ROOKIE\n        return (userStats.uniqueTags || 0) >= requirement.target;\n      case 'note_edits':\n        // ✅ MISSING - needed for BASIC EDITOR  \n        return (userStats.totalEdits || userStats.totalNotes || 0) >= requirement.target;\n      case 'duration_variety':\n        return (userStats.durationVariety || 0) >= requirement.target;\n      case 'monthly_sessions':\n        return (userStats.sessionsThisMonth || 0) >= requirement.target;\n      case 'priority_usage':\n        return (userStats.priorityUsage || 0) >= requirement.target;\n      case 'due_date_usage':\n        return (userStats.dueDateUsage || 0) >= requirement.target;\n      case 'tasks_created':\n        return (userStats.tasksCreated || 0) >= requirement.target;\n      case 'completion_ratio':\n        const ratio = userStats.totalTasks > 0 ? (userStats.completedTasks || 0) / userStats.totalTasks : 0;\n        return ratio >= requirement.target;\n      case 'morning_completions':\n        return (userStats.morningCompletions || 0) >= requirement.target;\n      case 'evening_completions':\n        return (userStats.eveningCompletions || 0) >= requirement.target;\n      case 'active_lists':\n        return (userStats.activeLists || 0) >= requirement.target;\n      case 'ontime_rate':\n        const ontimeRate = userStats.totalTasks > 0 ? (userStats.ontimeTasks || 0) / userStats.totalTasks : 0;\n        return ontimeRate >= requirement.rate;\n      case 'concurrent_tasks':\n        return (userStats.concurrentTasks || 0) >= requirement.target;\n      case 'super_combo':\n        return (userStats.superCombo || 0) >= requirement.target;\n      case 'late_night_activity':\n        const currentHour = new Date().getHours();\n        const isLateNight = currentHour >= 22 || currentHour <= 5; // 10 PM to 5 AM\n        return isLateNight && (userStats.notesToday || 0) >= 1;\n      case 'early_morning_activity':\n        return (userStats.earlyMorningActivity || 0) >= requirement.target;\n      case 'category_completion':\n        return (userStats.categoryCompletion || 0) >= requirement.target;\n      case 'daily_activity_streak':\n        return (userStats.dailyActivityStreak || 0) >= requirement.target;\n      case 'feature_usage':\n        return (userStats.featureUsage || 0) >= requirement.target;\n      case 'category_mastery':\n        return (userStats.categoryMastery || 0) >= requirement.target;\n      default:\n        console.warn(`Unknown requirement type: ${requirement.type}`);\n        return false;\n    }\n  }\n\n  // Trigger achievement notification with enhanced styling\n  triggerAchievementNotification(achievement) {\n    const tier = tierInfo[achievement.tier];\n    console.log(`🎉 ${tier.emoji} ${achievement.name} UNLOCKED! (+${achievement.xpReward} XP)`);\n\n    // Dispatch custom event for UI components\n    window.dispatchEvent(new CustomEvent('achievementUnlocked', {\n      detail: {\n        achievement,\n        tier,\n        timestamp: new Date().toISOString()\n      }\n    }));\n\n    // Play achievement sound (if available)\n    this.playAchievementSound(achievement.tier);\n  }\n\n  // Play achievement sound based on tier\n  playAchievementSound(tier) {\n    try {\n      const audio = new Audio(`/sounds/achievement_${tier}.mp3`);\n      audio.volume = 0.3;\n      audio.play().catch(() => {\n        console.log(`Sound not found for tier: ${tier}`);\n      });\n    } catch (error) {\n      console.error('Error playing achievement sound:', error);\n    }\n  }\n\n  // Get achievement progress\n  getAchievementProgress(achievementId, userStats) {\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement || this.isUnlocked(achievementId)) return 1;\n    const req = achievement.requirement;\n    let current = 0;\n    let target = req.target || 1;\n    switch (req.type) {\n      case 'note_count':\n        current = userStats.totalNotes || 0;\n        break;\n      case 'word_count':\n        current = userStats.totalWords || 0;\n        break;\n      case 'task_count':\n        current = userStats.totalTasks || 0;\n        break;\n      case 'session_count':\n        current = userStats.totalSessions || 0;\n        break;\n      case 'total_time':\n        current = userStats.totalFocusTime || 0;\n        break;\n      case 'unique_tags':\n        current = userStats.uniqueTags || 0;\n        break;\n      case 'streak':\n      case 'completion_streak':\n      case 'daily_streak':\n        current = userStats[req.type === 'streak' ? 'noteStreak' : req.type === 'completion_streak' ? 'taskStreak' : 'focusStreak'] || 0;\n        break;\n      default:\n        return 0;\n    }\n    return Math.min(current / target, 1);\n  }\n\n  // Get user's next achievements to unlock\n  getNextAchievements(userStats, limit = 5) {\n    return allAchievements.filter(achievement => !this.isUnlocked(achievement.id)).map(achievement => ({\n      ...achievement,\n      progress: this.getAchievementProgress(achievement.id, userStats)\n    })).sort((a, b) => b.progress - a.progress).slice(0, limit);\n  }\n\n  // Get recently unlocked achievements\n  getRecentlyUnlocked(days = 7) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    return this.unlockedAchievements.filter(achievement => new Date(achievement.unlockedAt) >= cutoffDate).sort((a, b) => new Date(b.unlockedAt) - new Date(a.unlockedAt));\n  }\n\n  // Get stats summary\n  getStats() {\n    const total = allAchievements.length;\n    const unlocked = this.unlockedAchievements.length;\n    const byTier = {\n      common: this.unlockedAchievements.filter(a => a.tier === 'common').length,\n      uncommon: this.unlockedAchievements.filter(a => a.tier === 'uncommon').length,\n      rare: this.unlockedAchievements.filter(a => a.tier === 'rare').length,\n      legendary: this.unlockedAchievements.filter(a => a.tier === 'legendary').length\n    };\n    const totalXP = this.unlockedAchievements.reduce((sum, achievement) => sum + achievement.xpReward, 0);\n    return {\n      total,\n      unlocked,\n      percentage: Math.round(unlocked / total * 100),\n      byTier,\n      totalXP,\n      recentUnlocks: this.getRecentlyUnlocked(7).length\n    };\n  }\n\n  // Force unlock an achievement (for testing)\n  forceUnlock(achievementId) {\n    console.log(`🧪 FORCE UNLOCK: ${achievementId}`);\n\n    // Get current unlocked achievements and filter out nulls\n    const currentUnlocked = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]').filter(id => id !== null && id !== undefined);\n    if (!currentUnlocked.includes(achievementId)) {\n      const newUnlocked = [...currentUnlocked, achievementId];\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n\n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData[achievementId] = {\n        unlockedAt: new Date().toISOString(),\n        progress: 100\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      console.log(`✅ Force unlocked: ${achievementId}`);\n\n      // Sync with backend\n      this.syncAchievementWithBackend(achievementId);\n\n      // Trigger update event\n      window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n    } else {\n      console.log(`⚠️ ${achievementId} already unlocked`);\n    }\n  }\n\n  // Reset all achievements (for testing)\n  resetAchievements() {\n    console.log('🧪 RESET: Clearing all achievements');\n    localStorage.removeItem('unlockedAchievements');\n    localStorage.removeItem('achievementData');\n    window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n  }\n\n  // Clean up localStorage (remove null values)\n  cleanupLocalStorage() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]').filter(id => id !== null && id !== undefined);\n    localStorage.setItem('unlockedAchievements', JSON.stringify(unlockedIds));\n    console.log('🧹 Cleaned up localStorage, removed null values');\n  }\n\n  // Get achievement with unlock date\n  getAchievementWithUnlockDate(achievement) {\n    const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n    const unlockDates = achievementData.unlockDates || {};\n    return {\n      ...achievement,\n      unlockedAt: unlockDates[achievement.id] || null\n    };\n  }\n\n  // Get unlocked achievements\n  getUnlockedAchievements() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]').filter(id => id !== null && id !== undefined); // Filter out null/undefined values\n\n    return unlockedIds.map(id => {\n      const achievement = allAchievements.find(a => a.id === id);\n      if (!achievement) {\n        console.warn(`Achievement with id ${id} not found`);\n        return null;\n      }\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      const data = achievementData[id] || {};\n      return {\n        ...achievement,\n        unlockedAt: data.unlockedAt || new Date().toISOString(),\n        progress: data.progress || 100\n      };\n    }).filter(Boolean); // Remove any null values\n  }\n}\nexport const achievementService = new AchievementService();\nexport default achievementService;","map":{"version":3,"names":["allAchievements","tierInfo","AchievementService","constructor","unlockedAchievements","loadUnlockedAchievements","listeners","saved","localStorage","getItem","JSON","parse","saveUnlockedAchievements","setItem","stringify","addEventListener","callback","push","removeEventListener","filter","listener","notifyListeners","achievement","forEach","isUnlocked","achievementId","some","a","id","unlockAchievement","find","unlockedAchievement","unlockedAt","Date","toISOString","syncAchievementWithBackend","triggerAchievementNotification","trackAchievementUnlock","response","fetch","method","headers","body","username","ok","console","log","warn","error","getUnlockedAchievements","includes","newUnlocked","achievementData","unlockDates","checkAchievements","userStats","newlyUnlocked","meetsRequirement","requirement","_userStats$sessionsBy","type","totalNotes","target","totalWords","uniqueTags","today","toDateString","notesToday","weekendNotes","notesThisWeek","maxWordsInNote","maxTagsInNote","noteStreak","totalEdits","totalTasks","tasksToday","tasksThisWeek","tasksThisMonth","highPriorityTasks","urgentTasks","earlyCompletions","taskStreak","taskCategories","tasksCreated","activeTasks","completionRate","completedTasks","totalSessions","totalFocusTime","maxSessionDuration","rangeSessions","sessionsByDuration","rangeCount","duration","minDuration","maxDuration","pomodoroSessions","focusStreak","categorySessions","category","categoryTime","Math","max","Object","values","allCategoryTime","every","time","uniqueCategories","keys","length","breakSessions","longSessions","sessionsOver90Min","sessionTimes","sessionsByTime","dailyActivities","activities","activity","weeklyActivities","comboStreak","activityStreak","activitiesToday","activitiesThisMonth","level","totalXP","tierAchievements","tier","unlockedInTier","now","hour","getHours","startHour","endHour","dayOfWeek","getDay","weekendActivities","fastestWordsPer5Min","words","durationVariety","sessionsThisMonth","priorityUsage","dueDateUsage","ratio","morningCompletions","eveningCompletions","activeLists","ontimeRate","ontimeTasks","rate","concurrentTasks","superCombo","currentHour","isLateNight","earlyMorningActivity","categoryCompletion","dailyActivityStreak","featureUsage","categoryMastery","emoji","name","xpReward","window","dispatchEvent","CustomEvent","detail","timestamp","playAchievementSound","audio","Audio","volume","play","catch","getAchievementProgress","req","current","min","getNextAchievements","limit","map","progress","sort","b","slice","getRecentlyUnlocked","days","cutoffDate","setDate","getDate","getStats","total","unlocked","byTier","common","uncommon","rare","legendary","reduce","sum","percentage","round","recentUnlocks","forceUnlock","currentUnlocked","undefined","resetAchievements","removeItem","cleanupLocalStorage","unlockedIds","getAchievementWithUnlockDate","data","Boolean","achievementService"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/services/achievementService.js"],"sourcesContent":["import { allAchievements, tierInfo } from '../data/achievements';\n\nclass AchievementService {\n  constructor() {\n    this.unlockedAchievements = this.loadUnlockedAchievements();\n    this.listeners = [];\n  }\n\n  // Load unlocked achievements from localStorage\n  loadUnlockedAchievements() {\n    const saved = localStorage.getItem('unlockedAchievements');\n    return saved ? JSON.parse(saved) : [];\n  }\n\n  // Save unlocked achievements to localStorage\n  saveUnlockedAchievements() {\n    localStorage.setItem('unlockedAchievements', JSON.stringify(this.unlockedAchievements));\n  }\n\n  // Add event listener for achievement unlocks\n  addEventListener(callback) {\n    this.listeners.push(callback);\n  }\n\n  // Remove event listener\n  removeEventListener(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  // Notify listeners of achievement unlock\n  notifyListeners(achievement) {\n    this.listeners.forEach(callback => callback(achievement));\n  }\n\n  // Check if achievement is unlocked\n  isUnlocked(achievementId) {\n    return this.unlockedAchievements.some(a => a.id === achievementId);\n  }\n\n  // Unlock achievement\n  unlockAchievement(achievementId) {\n    if (this.isUnlocked(achievementId)) return false;\n    \n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement) return false;\n\n    const unlockedAchievement = {\n      ...achievement,\n      unlockedAt: new Date().toISOString()\n    };\n\n    this.unlockedAchievements.push(unlockedAchievement);\n    this.saveUnlockedAchievements();\n    \n    // ✅ Sync with backend immediately\n    this.syncAchievementWithBackend(achievementId);\n    \n    // Trigger achievement notification\n    this.triggerAchievementNotification(achievement);\n    this.notifyListeners(achievement);\n    \n    // Track when achievements are unlocked\n    this.trackAchievementUnlock(achievementId);\n    \n    return true;\n  }\n\n  // Sync achievement with backend\n  async syncAchievementWithBackend(achievementId) {\n    try {\n      const response = await fetch('http://localhost:8080/api/player/achievements/unlock', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          username: 'Jroc_182', // Changed from 'user'\n          achievementId: achievementId\n        }),\n      });\n      \n      if (response.ok) {\n        console.log(`✅ Synced ${achievementId} with backend`);\n      } else {\n        console.warn(`⚠️ Failed to sync ${achievementId} with backend`);\n      }\n    } catch (error) {\n      console.error(`❌ Error syncing ${achievementId}:`, error);\n    }\n  }\n\n  // Track when achievements are unlocked\n  trackAchievementUnlock(achievementId) {\n    const unlockedAchievements = this.getUnlockedAchievements();\n    \n    if (!unlockedAchievements.includes(achievementId)) {\n      const newUnlocked = [...unlockedAchievements, achievementId];\n      \n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData.unlockedAchievements = newUnlocked;\n      achievementData.unlockDates = {\n        ...achievementData.unlockDates,\n        [achievementId]: new Date().toISOString()\n      };\n      \n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n    }\n  }\n\n  // Check achievements based on user stats\n  checkAchievements(userStats) {\n    const newlyUnlocked = [];\n\n    allAchievements.forEach(achievement => {\n      if (!this.isUnlocked(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        }\n      }\n    });\n\n    return newlyUnlocked;\n  }\n\n  // Enhanced requirement checking\n  meetsRequirement(requirement, userStats) {\n    switch (requirement.type) {\n      // Note achievements\n      case 'note_count':\n        return (userStats.totalNotes || 0) >= requirement.target;\n      \n      case 'word_count':\n        return (userStats.totalWords || 0) >= requirement.target;\n      \n      case 'unique_tags':\n        return (userStats.uniqueTags || 0) >= requirement.target;\n      \n      case 'daily_notes':\n        // ✅ FIX: Check if user created notes TODAY\n        const today = new Date().toDateString();\n        const notesToday = (userStats.notesToday || 0);\n        console.log(`📅 Daily notes check: ${notesToday} notes today (need ${requirement.target})`);\n        return notesToday >= requirement.target;\n      \n      case 'weekend_notes':\n        return (userStats.weekendNotes || 0) >= requirement.target;\n      \n      case 'weekly_notes':\n        return (userStats.notesThisWeek || 0) >= requirement.target;\n      \n      case 'single_note_words':\n        return (userStats.maxWordsInNote || 0) >= requirement.target;\n      \n      case 'single_note_tags':\n        return (userStats.maxTagsInNote || 0) >= requirement.target;\n      \n      case 'streak':\n        return (userStats.noteStreak || 0) >= requirement.target;\n      \n      case 'note_edits':\n        return (userStats.totalEdits || userStats.totalNotes || 0) >= requirement.target;\n      \n      // Task achievements\n      case 'task_count':\n        return (userStats.totalTasks || 0) >= requirement.target;\n      \n      case 'daily_tasks':\n        return (userStats.tasksToday || 0) >= requirement.target;\n      \n      case 'weekly_tasks':\n        return (userStats.tasksThisWeek || 0) >= requirement.target;\n      \n      case 'monthly_tasks':\n        return (userStats.tasksThisMonth || 0) >= requirement.target;\n      \n      case 'high_priority_tasks':\n        return (userStats.highPriorityTasks || 0) >= requirement.target;\n      \n      case 'urgent_tasks':\n        return (userStats.urgentTasks || 0) >= requirement.target;\n      \n      case 'early_completions':\n        return (userStats.earlyCompletions || 0) >= requirement.target;\n      \n      case 'completion_streak':\n        return (userStats.taskStreak || 0) >= requirement.target;\n      \n      case 'task_categories':\n        return (userStats.taskCategories || 0) >= requirement.target;\n      \n      case 'task_creation':\n        return (userStats.tasksCreated || 0) >= requirement.target;\n      \n      case 'active_tasks':\n        return (userStats.activeTasks || 0) >= requirement.target;\n      \n      case 'completion_rate':\n        const completionRate = userStats.totalTasks > 0 ? \n          (userStats.completedTasks || 0) / userStats.totalTasks : 0;\n        return completionRate >= requirement.target;\n      \n      // Focus achievements\n      case 'session_count':\n        return (userStats.totalSessions || 0) >= requirement.target;\n      \n      case 'total_time':\n        return (userStats.totalFocusTime || 0) >= requirement.target;\n      \n      case 'single_session_duration':\n        return (userStats.maxSessionDuration || 0) >= requirement.target;\n      \n      case 'session_duration_range':\n        const rangeSessions = userStats.sessionsByDuration || {};\n        let rangeCount = 0;\n        for (let duration = requirement.minDuration; duration <= requirement.maxDuration; duration++) {\n          rangeCount += rangeSessions[duration] || 0;\n        }\n        return rangeCount >= requirement.target;\n      \n      case 'pomodoro_count':\n        const pomodoroSessions = userStats.sessionsByDuration?.[25] || 0;\n        return pomodoroSessions >= requirement.target;\n      \n      case 'daily_streak':\n        return (userStats.focusStreak || 0) >= requirement.target;\n      \n      case 'category_sessions':\n        const categorySessions = userStats.categorySessions || {};\n        return (categorySessions[requirement.category] || 0) >= requirement.target;\n      \n      case 'category_time':\n        const categoryTime = userStats.categoryTime || {};\n        return Math.max(...Object.values(categoryTime)) >= requirement.target;\n      \n      case 'all_categories_time':\n        const allCategoryTime = userStats.categoryTime || {};\n        return Object.values(allCategoryTime).every(time => time >= requirement.target);\n      \n      case 'unique_categories':\n        const uniqueCategories = Object.keys(userStats.categorySessions || {}).length;\n        return uniqueCategories >= requirement.target;\n      \n      case 'break_session':\n        const breakSessions = userStats.breakSessions || 0;\n        return breakSessions >= requirement.target;\n      \n      case 'long_sessions':\n        const longSessions = userStats.sessionsOver90Min || 0;\n        return longSessions >= requirement.target;\n      \n      case 'time_variety':\n        const sessionTimes = Object.keys(userStats.sessionsByTime || {}).length;\n        return sessionTimes >= requirement.target;\n      \n      // Combo achievements\n      case 'daily_combo':\n        const dailyActivities = userStats.dailyActivities || [];\n        return requirement.activities.every(activity => dailyActivities.includes(activity));\n      \n      case 'weekly_combo':\n        const weeklyActivities = userStats.weeklyActivities || [];\n        return requirement.activities.every(activity => weeklyActivities.includes(activity));\n      \n      case 'combo_streak':\n        return (userStats.comboStreak || 0) >= requirement.target;\n      \n      case 'activity_consistency':\n        return (userStats.activityStreak || 0) >= requirement.target;\n      \n      case 'daily_activity_count':\n        return (userStats.activitiesToday || 0) >= requirement.target;\n      \n      case 'monthly_activity_count':\n        return (userStats.activitiesThisMonth || 0) >= requirement.target;\n      \n      // Meta achievements\n      case 'player_level':\n        return (userStats.level || 1) >= requirement.target;\n      \n      case 'total_xp':\n        return (userStats.totalXP || 0) >= requirement.target;\n      \n      case 'achievement_count':\n        return this.unlockedAchievements.length >= requirement.target;\n      \n      case 'completion_percentage':\n        return (this.unlockedAchievements.length / allAchievements.length) >= requirement.target;\n      \n      case 'tier_completion':\n        const tierAchievements = allAchievements.filter(a => a.tier === requirement.tier);\n        const unlockedInTier = this.unlockedAchievements.filter(a => a.tier === requirement.tier);\n        return (unlockedInTier.length / tierAchievements.length) >= requirement.target;\n      \n      // Time-based achievements\n      case 'time_range':\n        const now = new Date();\n        const hour = now.getHours();\n        if (requirement.startHour > requirement.endHour) {\n          // Crosses midnight\n          return hour >= requirement.startHour || hour < requirement.endHour;\n        }\n        return hour >= requirement.startHour && hour < requirement.endHour;\n      \n      case 'time_before':\n        return new Date().getHours() < requirement.hour;\n      \n      case 'time_after':\n        return new Date().getHours() >= requirement.hour;\n      \n      case 'weekend_activity':\n        const dayOfWeek = new Date().getDay();\n        return (dayOfWeek === 0 || dayOfWeek === 6) && (userStats.weekendActivities || 0) >= requirement.target;\n      \n      case 'speed_writing':\n        return (userStats.fastestWordsPer5Min || 0) >= requirement.words;\n      \n      // New cases added\n      case 'tag_count':  // ✅ MISSING - needed for TAG ROOKIE\n        return (userStats.uniqueTags || 0) >= requirement.target;\n\n      case 'note_edits':  // ✅ MISSING - needed for BASIC EDITOR  \n        return (userStats.totalEdits || userStats.totalNotes || 0) >= requirement.target;\n\n      case 'duration_variety':\n        return (userStats.durationVariety || 0) >= requirement.target;\n\n      case 'monthly_sessions':\n        return (userStats.sessionsThisMonth || 0) >= requirement.target;\n\n      case 'priority_usage':\n        return (userStats.priorityUsage || 0) >= requirement.target;\n\n      case 'due_date_usage':\n        return (userStats.dueDateUsage || 0) >= requirement.target;\n\n      case 'tasks_created':\n        return (userStats.tasksCreated || 0) >= requirement.target;\n\n      case 'completion_ratio':\n        const ratio = userStats.totalTasks > 0 ? \n          (userStats.completedTasks || 0) / userStats.totalTasks : 0;\n        return ratio >= requirement.target;\n\n      case 'morning_completions':\n        return (userStats.morningCompletions || 0) >= requirement.target;\n\n      case 'evening_completions':\n        return (userStats.eveningCompletions || 0) >= requirement.target;\n\n      case 'active_lists':\n        return (userStats.activeLists || 0) >= requirement.target;\n\n      case 'ontime_rate':\n        const ontimeRate = userStats.totalTasks > 0 ? \n          (userStats.ontimeTasks || 0) / userStats.totalTasks : 0;\n        return ontimeRate >= requirement.rate;\n\n      case 'concurrent_tasks':\n        return (userStats.concurrentTasks || 0) >= requirement.target;\n\n      case 'super_combo':\n        return (userStats.superCombo || 0) >= requirement.target;\n\n      case 'late_night_activity':\n        const currentHour = new Date().getHours();\n        const isLateNight = currentHour >= 22 || currentHour <= 5; // 10 PM to 5 AM\n        return isLateNight && (userStats.notesToday || 0) >= 1;\n\n      case 'early_morning_activity':\n        return (userStats.earlyMorningActivity || 0) >= requirement.target;\n\n      case 'category_completion':\n        return (userStats.categoryCompletion || 0) >= requirement.target;\n\n      case 'daily_activity_streak':\n        return (userStats.dailyActivityStreak || 0) >= requirement.target;\n\n      case 'feature_usage':\n        return (userStats.featureUsage || 0) >= requirement.target;\n\n      case 'category_mastery':\n        return (userStats.categoryMastery || 0) >= requirement.target;\n      \n      default:\n        console.warn(`Unknown requirement type: ${requirement.type}`);\n        return false;\n    }\n  }\n\n  // Trigger achievement notification with enhanced styling\n  triggerAchievementNotification(achievement) {\n    const tier = tierInfo[achievement.tier];\n    \n    console.log(`🎉 ${tier.emoji} ${achievement.name} UNLOCKED! (+${achievement.xpReward} XP)`);\n    \n    // Dispatch custom event for UI components\n    window.dispatchEvent(new CustomEvent('achievementUnlocked', {\n      detail: {\n        achievement,\n        tier,\n        timestamp: new Date().toISOString()\n      }\n    }));\n\n    // Play achievement sound (if available)\n    this.playAchievementSound(achievement.tier);\n  }\n\n  // Play achievement sound based on tier\n  playAchievementSound(tier) {\n    try {\n      const audio = new Audio(`/sounds/achievement_${tier}.mp3`);\n      audio.volume = 0.3;\n      audio.play().catch(() => {\n        console.log(`Sound not found for tier: ${tier}`);\n      });\n    } catch (error) {\n      console.error('Error playing achievement sound:', error);\n    }\n  }\n\n  // Get achievement progress\n  getAchievementProgress(achievementId, userStats) {\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement || this.isUnlocked(achievementId)) return 1;\n\n    const req = achievement.requirement;\n    let current = 0;\n    let target = req.target || 1;\n\n    switch (req.type) {\n      case 'note_count':\n        current = userStats.totalNotes || 0;\n        break;\n      case 'word_count':\n        current = userStats.totalWords || 0;\n        break;\n      case 'task_count':\n        current = userStats.totalTasks || 0;\n        break;\n      case 'session_count':\n        current = userStats.totalSessions || 0;\n        break;\n      case 'total_time':\n        current = userStats.totalFocusTime || 0;\n        break;\n      case 'unique_tags':\n        current = userStats.uniqueTags || 0;\n        break;\n      case 'streak':\n      case 'completion_streak':\n      case 'daily_streak':\n        current = userStats[req.type === 'streak' ? 'noteStreak' : \n                            req.type === 'completion_streak' ? 'taskStreak' : 'focusStreak'] || 0;\n        break;\n      default:\n        return 0;\n    }\n\n    return Math.min(current / target, 1);\n  }\n\n  // Get user's next achievements to unlock\n  getNextAchievements(userStats, limit = 5) {\n    return allAchievements\n      .filter(achievement => !this.isUnlocked(achievement.id))\n      .map(achievement => ({\n        ...achievement,\n        progress: this.getAchievementProgress(achievement.id, userStats)\n      }))\n      .sort((a, b) => b.progress - a.progress)\n      .slice(0, limit);\n  }\n\n  // Get recently unlocked achievements\n  getRecentlyUnlocked(days = 7) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    \n    return this.unlockedAchievements\n      .filter(achievement => new Date(achievement.unlockedAt) >= cutoffDate)\n      .sort((a, b) => new Date(b.unlockedAt) - new Date(a.unlockedAt));\n  }\n\n  // Get stats summary\n  getStats() {\n    const total = allAchievements.length;\n    const unlocked = this.unlockedAchievements.length;\n    const byTier = {\n      common: this.unlockedAchievements.filter(a => a.tier === 'common').length,\n      uncommon: this.unlockedAchievements.filter(a => a.tier === 'uncommon').length,\n      rare: this.unlockedAchievements.filter(a => a.tier === 'rare').length,\n      legendary: this.unlockedAchievements.filter(a => a.tier === 'legendary').length\n    };\n\n    const totalXP = this.unlockedAchievements.reduce((sum, achievement) => sum + achievement.xpReward, 0);\n\n    return {\n      total,\n      unlocked,\n      percentage: Math.round((unlocked / total) * 100),\n      byTier,\n      totalXP,\n      recentUnlocks: this.getRecentlyUnlocked(7).length\n    };\n  }\n\n  // Force unlock an achievement (for testing)\n  forceUnlock(achievementId) {\n    console.log(`🧪 FORCE UNLOCK: ${achievementId}`);\n    \n    // Get current unlocked achievements and filter out nulls\n    const currentUnlocked = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]')\n      .filter(id => id !== null && id !== undefined);\n    \n    if (!currentUnlocked.includes(achievementId)) {\n      const newUnlocked = [...currentUnlocked, achievementId];\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n      \n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData[achievementId] = {\n        unlockedAt: new Date().toISOString(),\n        progress: 100\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      \n      console.log(`✅ Force unlocked: ${achievementId}`);\n      \n      // Sync with backend\n      this.syncAchievementWithBackend(achievementId);\n      \n      // Trigger update event\n      window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n    } else {\n      console.log(`⚠️ ${achievementId} already unlocked`);\n    }\n  }\n\n  // Reset all achievements (for testing)\n  resetAchievements() {\n    console.log('🧪 RESET: Clearing all achievements');\n    localStorage.removeItem('unlockedAchievements');\n    localStorage.removeItem('achievementData');\n    window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n  }\n\n  // Clean up localStorage (remove null values)\n  cleanupLocalStorage() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]')\n      .filter(id => id !== null && id !== undefined);\n    \n    localStorage.setItem('unlockedAchievements', JSON.stringify(unlockedIds));\n    console.log('🧹 Cleaned up localStorage, removed null values');\n  }\n\n  // Get achievement with unlock date\n  getAchievementWithUnlockDate(achievement) {\n    const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n    const unlockDates = achievementData.unlockDates || {};\n    \n    return {\n      ...achievement,\n      unlockedAt: unlockDates[achievement.id] || null\n    };\n  }\n\n  // Get unlocked achievements\n  getUnlockedAchievements() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]')\n      .filter(id => id !== null && id !== undefined); // Filter out null/undefined values\n    \n    return unlockedIds.map(id => {\n      const achievement = allAchievements.find(a => a.id === id);\n      if (!achievement) {\n        console.warn(`Achievement with id ${id} not found`);\n        return null;\n      }\n      \n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      const data = achievementData[id] || {};\n      \n      return {\n        ...achievement,\n        unlockedAt: data.unlockedAt || new Date().toISOString(),\n        progress: data.progress || 100\n      };\n    }).filter(Boolean); // Remove any null values\n  }\n}\n\nexport const achievementService = new AchievementService();\nexport default achievementService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}