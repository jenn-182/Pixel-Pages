{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport apiService from '../services/api';\nexport const useFocusTimer = username => {\n  _s();\n  const [activeSession, setActiveSession] = useState(null);\n  const [timeRemaining, setTimeRemaining] = useState(0);\n  const [isRunning, setIsRunning] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [currentPhase, setCurrentPhase] = useState('work');\n  const [currentCycle, setCurrentCycle] = useState(1);\n  const [startTime, setStartTime] = useState(null);\n  const [totalTimeSpent, setTotalTimeSpent] = useState(0);\n  const intervalRef = useRef(null);\n  const startTimeRef = useRef(null);\n\n  // Reset timer state - moved up to avoid dependency issues\n  const resetTimer = useCallback(() => {\n    clearInterval(intervalRef.current);\n    setActiveSession(null);\n    setTimeRemaining(0);\n    setIsRunning(false);\n    setIsPaused(false);\n    setCurrentPhase('work');\n    setCurrentCycle(1);\n    setStartTime(null);\n    setTotalTimeSpent(0);\n    startTimeRef.current = null;\n    console.log('🔄 Timer reset');\n  }, []);\n\n  // Handle phase completion\n  const handlePhaseComplete = useCallback(async () => {\n    if (!activeSession || !username) return;\n    try {\n      const phaseStartTime = startTimeRef.current || startTime;\n      if (!phaseStartTime) {\n        console.error('❌ No start time recorded');\n        return;\n      }\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      console.log('🎯 Phase completed:', {\n        phase: currentPhase,\n        timeSpent: timeSpentMinutes,\n        sessionId: activeSession.id,\n        startTime: phaseStartTime.toISOString(),\n        endTime: endTime.toISOString()\n      });\n\n      // Save completed phase to backend\n      if (timeSpentMinutes > 0) {\n        const entryData = {\n          sessionId: activeSession.id,\n          ownerUsername: username,\n          timeSpent: timeSpentMinutes,\n          date: new Date().toISOString().split('T')[0],\n          startTime: phaseStartTime.toISOString(),\n          endTime: endTime.toISOString(),\n          completed: true,\n          phase: currentPhase,\n          cycleNumber: currentCycle\n        };\n        console.log('💾 Saving focus entry:', entryData);\n        try {\n          await apiService.createFocusEntry(entryData);\n          console.log('✅ Focus entry saved successfully');\n        } catch (apiError) {\n          console.error('❌ API Error saving entry:', apiError);\n          console.error('Entry data that failed:', entryData);\n        }\n      }\n\n      // Update total time\n      setTotalTimeSpent(prev => prev + timeSpentMinutes);\n\n      // Determine next phase\n      if (currentPhase === 'work') {\n        if (currentCycle >= activeSession.cycles) {\n          // Session complete\n          console.log('🎉 Session completed!');\n          resetTimer();\n          return;\n        } else {\n          // Go to break\n          const nextPhase = currentCycle % 4 === 0 ? 'long_break' : 'break';\n          const nextDuration = nextPhase === 'long_break' ? 15 : activeSession.breakDuration;\n          setCurrentPhase(nextPhase);\n          setTimeRemaining(nextDuration * 60);\n          setStartTime(new Date());\n          startTimeRef.current = new Date();\n          console.log('➡️ Moving to break phase:', {\n            nextPhase,\n            nextDuration\n          });\n        }\n      } else {\n        // Break finished, go to work\n        const nextCycle = currentCycle + 1;\n        setCurrentPhase('work');\n        setCurrentCycle(nextCycle);\n        setTimeRemaining(activeSession.workDuration * 60);\n        setStartTime(new Date());\n        startTimeRef.current = new Date();\n        console.log('➡️ Moving to work phase:', {\n          nextCycle\n        });\n      }\n    } catch (err) {\n      console.error('❌ Error handling phase complete:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle, resetTimer]);\n\n  // Start session\n  const startSession = useCallback(async session => {\n    if (!session || !username) return;\n    try {\n      console.log('🚀 Starting focus session:', session.name);\n      const now = new Date();\n      setActiveSession(session);\n      setTimeRemaining(session.workDuration * 60);\n      setCurrentPhase('work');\n      setCurrentCycle(1);\n      setTotalTimeSpent(0);\n      setIsRunning(true);\n      setIsPaused(false);\n      setStartTime(now);\n      startTimeRef.current = now;\n      console.log('⏰ Timer set for:', session.workDuration, 'minutes');\n      console.log('📅 Start time:', now.toISOString());\n\n      // Start the timer\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          const newTime = prev - 1;\n          if (newTime <= 0) {\n            console.log('⏰ Time reached zero, triggering phase complete');\n            handlePhaseComplete();\n            return 0;\n          }\n          return newTime;\n        });\n      }, 1000);\n    } catch (err) {\n      console.error('❌ Error starting session:', err);\n    }\n  }, [username, handlePhaseComplete]);\n\n  // Toggle pause\n  const togglePause = useCallback(() => {\n    if (!activeSession) return;\n    if (isRunning && !isPaused) {\n      clearInterval(intervalRef.current);\n      setIsPaused(true);\n      console.log('⏸️ Timer paused');\n    } else if (isRunning && isPaused) {\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          const newTime = prev - 1;\n          if (newTime <= 0) {\n            handlePhaseComplete();\n            return 0;\n          }\n          return newTime;\n        });\n      }, 1000);\n      setIsPaused(false);\n      console.log('▶️ Timer resumed');\n    }\n  }, [activeSession, isRunning, isPaused, handlePhaseComplete]);\n\n  // Stop session and save progress\n  const stopSession = useCallback(async () => {\n    if (!activeSession || !username) return;\n    try {\n      clearInterval(intervalRef.current);\n      console.log('🛑 Stopping session...');\n      const phaseStartTime = startTimeRef.current || startTime;\n      if (!phaseStartTime) {\n        console.error('❌ No start time recorded for manual stop');\n        resetTimer();\n        return;\n      }\n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      console.log('📊 Manual stop - Time calculation:', {\n        startTime: phaseStartTime.toISOString(),\n        endTime: endTime.toISOString(),\n        minutesSpent: timeSpentMinutes\n      });\n\n      // Always save entry, even if 0 minutes (for tracking purposes)\n      const entryData = {\n        sessionId: activeSession.id,\n        ownerUsername: username,\n        timeSpent: Math.max(timeSpentMinutes, 1),\n        // Minimum 1 minute for manual stops\n        date: new Date().toISOString().split('T')[0],\n        startTime: phaseStartTime.toISOString(),\n        endTime: endTime.toISOString(),\n        completed: false,\n        // Manually stopped\n        phase: currentPhase,\n        cycleNumber: currentCycle,\n        notes: `Session stopped manually after ${Math.max(timeSpentMinutes, 1)} minutes`\n      };\n      console.log('💾 Saving manual stop entry:', entryData);\n      try {\n        await apiService.createFocusEntry(entryData);\n        console.log('✅ Manual stop entry saved successfully');\n      } catch (apiError) {\n        console.error('❌ API Error saving manual stop:', apiError);\n        console.error('Failed entry data:', entryData);\n      }\n      resetTimer();\n    } catch (err) {\n      console.error('❌ Error stopping session:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle, resetTimer]);\n\n  // Format time display\n  const formatTime = useCallback((seconds = timeRemaining) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }, [timeRemaining]);\n\n  // Calculate progress\n  const progress = activeSession && timeRemaining > 0 ? (activeSession.workDuration * 60 - timeRemaining) / (activeSession.workDuration * 60) * 100 : 0;\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n  return {\n    activeSession,\n    timeRemaining,\n    isRunning,\n    isPaused,\n    currentPhase,\n    currentCycle,\n    totalTimeSpent,\n    startSession,\n    stopSession,\n    togglePause,\n    resetTimer,\n    formatTime,\n    progress\n  };\n};\n_s(useFocusTimer, \"RXgveX7TcCGTZ4RgGEvxaIPRgVI=\");\nexport default useFocusTimer;","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","apiService","useFocusTimer","username","_s","activeSession","setActiveSession","timeRemaining","setTimeRemaining","isRunning","setIsRunning","isPaused","setIsPaused","currentPhase","setCurrentPhase","currentCycle","setCurrentCycle","startTime","setStartTime","totalTimeSpent","setTotalTimeSpent","intervalRef","startTimeRef","resetTimer","clearInterval","current","console","log","handlePhaseComplete","phaseStartTime","error","endTime","Date","timeSpentMinutes","Math","round","phase","timeSpent","sessionId","id","toISOString","entryData","ownerUsername","date","split","completed","cycleNumber","createFocusEntry","apiError","prev","cycles","nextPhase","nextDuration","breakDuration","nextCycle","workDuration","err","startSession","session","name","now","setInterval","newTime","togglePause","stopSession","minutesSpent","max","notes","formatTime","seconds","mins","floor","secs","toString","padStart","progress"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/hooks/useFocusTimer.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport apiService from '../services/api';\n\nexport const useFocusTimer = (username) => {\n  const [activeSession, setActiveSession] = useState(null);\n  const [timeRemaining, setTimeRemaining] = useState(0);\n  const [isRunning, setIsRunning] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [currentPhase, setCurrentPhase] = useState('work');\n  const [currentCycle, setCurrentCycle] = useState(1);\n  const [startTime, setStartTime] = useState(null);\n  const [totalTimeSpent, setTotalTimeSpent] = useState(0);\n  \n  const intervalRef = useRef(null);\n  const startTimeRef = useRef(null);\n\n  // Reset timer state - moved up to avoid dependency issues\n  const resetTimer = useCallback(() => {\n    clearInterval(intervalRef.current);\n    setActiveSession(null);\n    setTimeRemaining(0);\n    setIsRunning(false);\n    setIsPaused(false);\n    setCurrentPhase('work');\n    setCurrentCycle(1);\n    setStartTime(null);\n    setTotalTimeSpent(0);\n    startTimeRef.current = null;\n    console.log('🔄 Timer reset');\n  }, []);\n\n  // Handle phase completion\n  const handlePhaseComplete = useCallback(async () => {\n    if (!activeSession || !username) return;\n    \n    try {\n      const phaseStartTime = startTimeRef.current || startTime;\n      if (!phaseStartTime) {\n        console.error('❌ No start time recorded');\n        return;\n      }\n      \n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      \n      console.log('🎯 Phase completed:', {\n        phase: currentPhase,\n        timeSpent: timeSpentMinutes,\n        sessionId: activeSession.id,\n        startTime: phaseStartTime.toISOString(),\n        endTime: endTime.toISOString()\n      });\n      \n      // Save completed phase to backend\n      if (timeSpentMinutes > 0) {\n        const entryData = {\n          sessionId: activeSession.id,\n          ownerUsername: username,\n          timeSpent: timeSpentMinutes,\n          date: new Date().toISOString().split('T')[0],\n          startTime: phaseStartTime.toISOString(),\n          endTime: endTime.toISOString(),\n          completed: true,\n          phase: currentPhase,\n          cycleNumber: currentCycle\n        };\n        \n        console.log('💾 Saving focus entry:', entryData);\n        \n        try {\n          await apiService.createFocusEntry(entryData);\n          console.log('✅ Focus entry saved successfully');\n        } catch (apiError) {\n          console.error('❌ API Error saving entry:', apiError);\n          console.error('Entry data that failed:', entryData);\n        }\n      }\n      \n      // Update total time\n      setTotalTimeSpent(prev => prev + timeSpentMinutes);\n      \n      // Determine next phase\n      if (currentPhase === 'work') {\n        if (currentCycle >= activeSession.cycles) {\n          // Session complete\n          console.log('🎉 Session completed!');\n          resetTimer();\n          return;\n        } else {\n          // Go to break\n          const nextPhase = currentCycle % 4 === 0 ? 'long_break' : 'break';\n          const nextDuration = nextPhase === 'long_break' ? 15 : activeSession.breakDuration;\n          \n          setCurrentPhase(nextPhase);\n          setTimeRemaining(nextDuration * 60);\n          setStartTime(new Date());\n          startTimeRef.current = new Date();\n          \n          console.log('➡️ Moving to break phase:', { nextPhase, nextDuration });\n        }\n      } else {\n        // Break finished, go to work\n        const nextCycle = currentCycle + 1;\n        setCurrentPhase('work');\n        setCurrentCycle(nextCycle);\n        setTimeRemaining(activeSession.workDuration * 60);\n        setStartTime(new Date());\n        startTimeRef.current = new Date();\n        \n        console.log('➡️ Moving to work phase:', { nextCycle });\n      }\n      \n    } catch (err) {\n      console.error('❌ Error handling phase complete:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle, resetTimer]);\n\n  // Start session\n  const startSession = useCallback(async (session) => {\n    if (!session || !username) return;\n    \n    try {\n      console.log('🚀 Starting focus session:', session.name);\n      \n      const now = new Date();\n      setActiveSession(session);\n      setTimeRemaining(session.workDuration * 60);\n      setCurrentPhase('work');\n      setCurrentCycle(1);\n      setTotalTimeSpent(0);\n      setIsRunning(true);\n      setIsPaused(false);\n      setStartTime(now);\n      startTimeRef.current = now;\n      \n      console.log('⏰ Timer set for:', session.workDuration, 'minutes');\n      console.log('📅 Start time:', now.toISOString());\n      \n      // Start the timer\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          const newTime = prev - 1;\n          if (newTime <= 0) {\n            console.log('⏰ Time reached zero, triggering phase complete');\n            handlePhaseComplete();\n            return 0;\n          }\n          return newTime;\n        });\n      }, 1000);\n      \n    } catch (err) {\n      console.error('❌ Error starting session:', err);\n    }\n  }, [username, handlePhaseComplete]);\n\n  // Toggle pause\n  const togglePause = useCallback(() => {\n    if (!activeSession) return;\n    \n    if (isRunning && !isPaused) {\n      clearInterval(intervalRef.current);\n      setIsPaused(true);\n      console.log('⏸️ Timer paused');\n    } else if (isRunning && isPaused) {\n      intervalRef.current = setInterval(() => {\n        setTimeRemaining(prev => {\n          const newTime = prev - 1;\n          if (newTime <= 0) {\n            handlePhaseComplete();\n            return 0;\n          }\n          return newTime;\n        });\n      }, 1000);\n      setIsPaused(false);\n      console.log('▶️ Timer resumed');\n    }\n  }, [activeSession, isRunning, isPaused, handlePhaseComplete]);\n\n  // Stop session and save progress\n  const stopSession = useCallback(async () => {\n    if (!activeSession || !username) return;\n    \n    try {\n      clearInterval(intervalRef.current);\n      console.log('🛑 Stopping session...');\n      \n      const phaseStartTime = startTimeRef.current || startTime;\n      if (!phaseStartTime) {\n        console.error('❌ No start time recorded for manual stop');\n        resetTimer();\n        return;\n      }\n      \n      const endTime = new Date();\n      const timeSpentMinutes = Math.round((endTime - phaseStartTime) / 1000 / 60);\n      \n      console.log('📊 Manual stop - Time calculation:', {\n        startTime: phaseStartTime.toISOString(),\n        endTime: endTime.toISOString(),\n        minutesSpent: timeSpentMinutes\n      });\n      \n      // Always save entry, even if 0 minutes (for tracking purposes)\n      const entryData = {\n        sessionId: activeSession.id,\n        ownerUsername: username,\n        timeSpent: Math.max(timeSpentMinutes, 1), // Minimum 1 minute for manual stops\n        date: new Date().toISOString().split('T')[0],\n        startTime: phaseStartTime.toISOString(),\n        endTime: endTime.toISOString(),\n        completed: false, // Manually stopped\n        phase: currentPhase,\n        cycleNumber: currentCycle,\n        notes: `Session stopped manually after ${Math.max(timeSpentMinutes, 1)} minutes`\n      };\n      \n      console.log('💾 Saving manual stop entry:', entryData);\n      \n      try {\n        await apiService.createFocusEntry(entryData);\n        console.log('✅ Manual stop entry saved successfully');\n      } catch (apiError) {\n        console.error('❌ API Error saving manual stop:', apiError);\n        console.error('Failed entry data:', entryData);\n      }\n      \n      resetTimer();\n      \n    } catch (err) {\n      console.error('❌ Error stopping session:', err);\n    }\n  }, [activeSession, username, startTime, currentPhase, currentCycle, resetTimer]);\n\n  // Format time display\n  const formatTime = useCallback((seconds = timeRemaining) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  }, [timeRemaining]);\n\n  // Calculate progress\n  const progress = activeSession && timeRemaining > 0 ? \n    (((activeSession.workDuration * 60) - timeRemaining) / (activeSession.workDuration * 60)) * 100 : 0;\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    activeSession,\n    timeRemaining,\n    isRunning,\n    isPaused,\n    currentPhase,\n    currentCycle,\n    totalTimeSpent,\n    startSession,\n    stopSession,\n    togglePause,\n    resetTimer,\n    formatTime,\n    progress\n  };\n};\n\nexport default useFocusTimer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}