{"ast":null,"code":"import { allAchievements, tierInfo } from '../data/achievements';\nclass AchievementService {\n  constructor() {\n    this.unlockedAchievements = this.loadUnlockedAchievements();\n    this.listeners = [];\n  }\n\n  // Load unlocked achievements from localStorage\n  loadUnlockedAchievements() {\n    const saved = localStorage.getItem('unlockedAchievements');\n    return saved ? JSON.parse(saved) : [];\n  }\n\n  // Save unlocked achievements to localStorage\n  saveUnlockedAchievements() {\n    localStorage.setItem('unlockedAchievements', JSON.stringify(this.unlockedAchievements));\n  }\n\n  // Add event listener for achievement unlocks\n  addEventListener(callback) {\n    this.listeners.push(callback);\n  }\n\n  // Remove event listener\n  removeEventListener(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  // Notify listeners of achievement unlock\n  notifyListeners(achievement) {\n    this.listeners.forEach(callback => callback(achievement));\n  }\n\n  // Check if achievement is unlocked\n  isUnlocked(achievementId) {\n    return this.unlockedAchievements.some(a => a.id === achievementId);\n  }\n\n  // Unlock achievement\n  unlockAchievement(achievementId) {\n    if (this.isUnlocked(achievementId)) return false;\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement) return false;\n    const unlockedAchievement = {\n      ...achievement,\n      unlockedAt: new Date().toISOString()\n    };\n    this.unlockedAchievements.push(unlockedAchievement);\n    this.saveUnlockedAchievements();\n\n    // ✅ Sync with backend immediately\n    this.syncAchievementWithBackend(achievementId);\n\n    // Trigger achievement notification\n    this.triggerAchievementNotification(achievement);\n    this.notifyListeners(achievement);\n\n    // Track when achievements are unlocked\n    this.trackAchievementUnlock(achievementId);\n    return true;\n  }\n\n  // Sync achievement with backend\n  async syncAchievementWithBackend(achievementId) {\n    try {\n      const response = await fetch('http://localhost:8080/api/player/achievements/unlock', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          username: 'Jroc_182',\n          // Changed from 'user'\n          achievementId: achievementId\n        })\n      });\n      if (response.ok) {\n        console.log(`✅ Synced ${achievementId} with backend`);\n      } else {\n        console.warn(`⚠️ Failed to sync ${achievementId} with backend`);\n      }\n    } catch (error) {\n      console.error(`❌ Error syncing ${achievementId}:`, error);\n    }\n  }\n\n  // Track when achievements are unlocked\n  trackAchievementUnlock(achievementId) {\n    const unlockedAchievements = this.getUnlockedAchievements();\n    if (!unlockedAchievements.includes(achievementId)) {\n      const newUnlocked = [...unlockedAchievements, achievementId];\n\n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData.unlockedAchievements = newUnlocked;\n      achievementData.unlockDates = {\n        ...achievementData.unlockDates,\n        [achievementId]: new Date().toISOString()\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n    }\n  }\n\n  // Check achievements based on user stats\n  checkAchievements(userStats) {\n    const newlyUnlocked = [];\n    allAchievements.forEach(achievement => {\n      if (!this.isUnlocked(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        }\n      }\n    });\n    return newlyUnlocked;\n  }\n\n  // Enhanced requirement checking\n  meetsRequirement(requirement, userStats) {\n    switch (requirement.type) {\n      // Focus/Session requirements (existing)\n      case 'session_count':\n        return (userStats.totalSessions || 0) >= requirement.target;\n      case 'total_time':\n        return (userStats.totalFocusTime || userStats.totalFocusMinutes || 0) >= requirement.target;\n      case 'max_session':\n        return (userStats.maxSessionDuration || 0) >= requirement.target;\n      case 'category_focus':\n        const categoryTime = userStats.categoryTime || {};\n        return (categoryTime[requirement.category] || 0) >= requirement.target;\n      case 'all_categories_time':\n        const allCategoryTime = userStats.categoryTime || {};\n        const totalTimeAllCategories = Object.values(allCategoryTime).reduce((sum, time) => sum + time, 0);\n        return totalTimeAllCategories >= requirement.target;\n      case 'unique_categories':\n        return (userStats.uniqueCategories || 0) >= requirement.target;\n\n      // NOTE REQUIREMENTS (ADD THESE)\n      case 'note_count':\n        return (userStats.totalNotes || 0) >= requirement.target;\n      case 'word_count':\n        return (userStats.totalWords || 0) >= requirement.target;\n      case 'tag_count':\n      case 'unique_tags':\n        return (userStats.uniqueTags || 0) >= requirement.target;\n      case 'note_edits':\n        return (userStats.totalEdits || 0) >= requirement.target;\n      case 'single_note_edits':\n        return (userStats.maxNoteEdits || userStats.maxEditsInNote || 0) >= requirement.target;\n      case 'single_note_words':\n        return (userStats.maxWordsInNote || 0) >= requirement.target;\n      case 'single_note_tags':\n        return (userStats.maxTagsInNote || 0) >= requirement.target;\n      case 'weekend_notes':\n        return (userStats.weekendNotes || 0) >= requirement.target;\n      case 'weekly_notes':\n        return (userStats.notesThisWeek || 0) >= requirement.target;\n      case 'streak':\n        return (userStats.noteStreak || 0) >= requirement.target;\n      case 'time_range':\n        return (userStats.timeRangeNotes || 0) >= 1;\n      // Simplified for now\n\n      // TASK REQUIREMENTS (ADD THESE)\n      case 'task_count':\n        return (userStats.completedTasks || 0) >= requirement.target;\n      case 'tasks_created':\n        return (userStats.totalTasks || 0) >= requirement.target;\n      case 'daily_tasks':\n        return (userStats.tasksToday || 0) >= requirement.target;\n      case 'weekly_tasks':\n        return (userStats.tasksThisWeek || 0) >= requirement.target;\n      case 'monthly_tasks':\n        return (userStats.tasksThisMonth || 0) >= requirement.target;\n      case 'high_priority_tasks':\n        return (userStats.highPriorityTasks || 0) >= requirement.target;\n      case 'early_completions':\n        return (userStats.earlyCompletions || 0) >= requirement.target;\n      case 'completion_streak':\n        return (userStats.taskStreak || 0) >= requirement.target;\n      case 'task_categories':\n        return (userStats.taskCategories || 0) >= requirement.target;\n      case 'priority_usage':\n        return (userStats.priorityUsage || 0) >= requirement.target;\n      case 'due_date_usage':\n        return (userStats.dueDateUsage || 0) >= requirement.target;\n      case 'completion_ratio':\n        const totalTasks = userStats.totalTasks || 0;\n        const completedTasks = userStats.completedTasks || 0;\n        return totalTasks > 0 && completedTasks / totalTasks >= requirement.ratio;\n\n      // COMBO/SPECIAL REQUIREMENTS (ADD THESE)\n      case 'daily_combo':\n        return userStats.dailyCombo || false;\n      case 'weekly_combo':\n        return userStats.weeklyCombo || false;\n      case 'achievement_count':\n        return (userStats.completedAchievements || 0) >= requirement.target;\n      case 'activity_consistency':\n        return (userStats.currentStreak || 0) >= requirement.target;\n      case 'category_mastery':\n        return (userStats.categoryMastery || 0) >= requirement.target;\n      default:\n        console.warn(`Unknown requirement type: ${requirement.type}`);\n        return false;\n    }\n  }\n\n  // Trigger achievement notification with enhanced styling\n  triggerAchievementNotification(achievement) {\n    const tier = tierInfo[achievement.tier];\n    console.log(`🎉 ${tier.emoji} ${achievement.name} UNLOCKED! (+${achievement.xpReward} XP)`);\n\n    // Dispatch custom event for UI components\n    window.dispatchEvent(new CustomEvent('achievementUnlocked', {\n      detail: {\n        achievement,\n        tier,\n        timestamp: new Date().toISOString()\n      }\n    }));\n\n    // Play achievement sound (if available)\n    this.playAchievementSound(achievement.tier);\n  }\n\n  // Play achievement sound based on tier\n  playAchievementSound(tier) {\n    try {\n      const audio = new Audio(`/sounds/achievement_${tier}.mp3`);\n      audio.volume = 0.3;\n      audio.play().catch(() => {\n        console.log(`Sound not found for tier: ${tier}`);\n      });\n    } catch (error) {\n      console.error('Error playing achievement sound:', error);\n    }\n  }\n\n  // Get achievement progress\n  getAchievementProgress(achievementId, userStats) {\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement || this.isUnlocked(achievementId)) return 1;\n    const req = achievement.requirement;\n    let current = 0;\n    let target = req.target || 1;\n    switch (req.type) {\n      case 'note_count':\n        current = userStats.totalNotes || 0;\n        break;\n      case 'word_count':\n        current = userStats.totalWords || 0;\n        break;\n      case 'task_count':\n        current = userStats.totalTasks || 0;\n        break;\n      case 'session_count':\n        current = userStats.totalSessions || 0;\n        break;\n      case 'total_time':\n        current = userStats.totalFocusTime || 0;\n        break;\n      case 'unique_tags':\n        current = userStats.uniqueTags || 0;\n        break;\n      case 'streak':\n      case 'completion_streak':\n      case 'daily_streak':\n        current = userStats[req.type === 'streak' ? 'noteStreak' : req.type === 'completion_streak' ? 'taskStreak' : 'focusStreak'] || 0;\n        break;\n      default:\n        return 0;\n    }\n    return Math.min(current / target, 1);\n  }\n\n  // Get user's next achievements to unlock\n  getNextAchievements(userStats, limit = 5) {\n    return allAchievements.filter(achievement => !this.isUnlocked(achievement.id)).map(achievement => ({\n      ...achievement,\n      progress: this.getAchievementProgress(achievement.id, userStats)\n    })).sort((a, b) => b.progress - a.progress).slice(0, limit);\n  }\n\n  // Get recently unlocked achievements\n  getRecentlyUnlocked(days = 7) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    return this.unlockedAchievements.filter(achievement => new Date(achievement.unlockedAt) >= cutoffDate).sort((a, b) => new Date(b.unlockedAt) - new Date(a.unlockedAt));\n  }\n\n  // Get stats summary\n  getStats() {\n    const total = allAchievements.length;\n    const unlocked = this.unlockedAchievements.length;\n    const byTier = {\n      common: this.unlockedAchievements.filter(a => a.tier === 'common').length,\n      uncommon: this.unlockedAchievements.filter(a => a.tier === 'uncommon').length,\n      rare: this.unlockedAchievements.filter(a => a.tier === 'rare').length,\n      legendary: this.unlockedAchievements.filter(a => a.tier === 'legendary').length\n    };\n    const totalXP = this.unlockedAchievements.reduce((sum, achievement) => sum + achievement.xpReward, 0);\n    return {\n      total,\n      unlocked,\n      percentage: Math.round(unlocked / total * 100),\n      byTier,\n      totalXP,\n      recentUnlocks: this.getRecentlyUnlocked(7).length\n    };\n  }\n\n  // Force unlock an achievement (for testing)\n  forceUnlock(achievementId) {\n    console.log(`🧪 FORCE UNLOCK: ${achievementId}`);\n\n    // Get current unlocked achievements and filter out nulls\n    const currentUnlocked = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]').filter(id => id !== null && id !== undefined);\n    if (!currentUnlocked.includes(achievementId)) {\n      const newUnlocked = [...currentUnlocked, achievementId];\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n\n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData[achievementId] = {\n        unlockedAt: new Date().toISOString(),\n        progress: 100\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      console.log(`✅ Force unlocked: ${achievementId}`);\n\n      // Sync with backend\n      this.syncAchievementWithBackend(achievementId);\n\n      // Trigger update event\n      window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n    } else {\n      console.log(`⚠️ ${achievementId} already unlocked`);\n    }\n  }\n\n  // Reset all achievements (for testing)\n  resetAchievements() {\n    console.log('🧪 RESET: Clearing all achievements');\n    localStorage.removeItem('unlockedAchievements');\n    localStorage.removeItem('achievementData');\n    window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n  }\n\n  // Clean up localStorage (remove null values)\n  cleanupLocalStorage() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]').filter(id => id !== null && id !== undefined);\n    localStorage.setItem('unlockedAchievements', JSON.stringify(unlockedIds));\n    console.log('🧹 Cleaned up localStorage, removed null values');\n  }\n\n  // Get achievement with unlock date\n  getAchievementWithUnlockDate(achievement) {\n    const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n    const unlockDates = achievementData.unlockDates || {};\n    return {\n      ...achievement,\n      unlockedAt: unlockDates[achievement.id] || null\n    };\n  }\n\n  // Get unlocked achievements\n  getUnlockedAchievements() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]').filter(id => id !== null && id !== undefined);\n    return unlockedIds.map(id => {\n      const achievement = allAchievements.find(a => a.id === id);\n      if (!achievement) {\n        console.warn(`⚠️ Achievement with id ${id} not found`);\n        return null;\n      }\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      const data = achievementData[id] || {};\n      return {\n        ...achievement,\n        unlockedAt: data.unlockedAt || new Date().toISOString(),\n        progress: data.progress || 100\n      };\n    }).filter(Boolean);\n  }\n\n  // Recalculate and unlock all achievements based on current user stats\n  async recalculateAchievements(userStats) {\n    console.log('🔄 RECALCULATING ACHIEVEMENTS based on current stats:', userStats);\n    const previouslyUnlocked = this.getUnlockedAchievements().map(a => a.id);\n    const newlyUnlocked = [];\n\n    // Check every achievement against current stats\n    allAchievements.forEach(achievement => {\n      if (!previouslyUnlocked.includes(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          console.log(`🏆 Should unlock: ${achievement.id} - ${achievement.name}`);\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        } else {\n          // Show progress for close achievements\n          const progress = this.getAchievementProgress(achievement.id, userStats);\n          if (progress > 0.5) {\n            console.log(`📈 Close to unlocking: ${achievement.id} - ${Math.round(progress * 100)}%`);\n          }\n        }\n      }\n    });\n    console.log(`✅ Recalculation complete! Unlocked ${newlyUnlocked.length} new achievements:`, newlyUnlocked.map(a => a.name));\n    return newlyUnlocked;\n  }\n\n  // Enhanced data gathering that checks multiple possible storage keys\n  async getCurrentUserStats() {\n    console.log('📊 GATHERING USER STATS FROM ALL SOURCES...');\n\n    // Check multiple possible storage keys (in case data was stored differently)\n    const possibleNoteKeys = ['notes', 'userNotes', 'pixelNotes', 'journalEntries'];\n    const possibleTaskKeys = ['tasks', 'userTasks', 'todoItems', 'missions'];\n    const possibleFocusKeys = ['focusSessions', 'timerSessions', 'pomodoroSessions'];\n    let notes = [];\n    let tasks = [];\n    let focusSessions = [];\n\n    // Try to find notes data\n    for (const key of possibleNoteKeys) {\n      const data = localStorage.getItem(key);\n      if (data) {\n        try {\n          const parsed = JSON.parse(data);\n          if (Array.isArray(parsed) && parsed.length > 0) {\n            notes = parsed;\n            console.log(`📝 Found notes data in '${key}': ${notes.length} notes`);\n            break;\n          }\n        } catch (e) {\n          console.warn(`Failed to parse ${key}:`, e);\n        }\n      }\n    }\n\n    // Try to find tasks data\n    for (const key of possibleTaskKeys) {\n      const data = localStorage.getItem(key);\n      if (data) {\n        try {\n          const parsed = JSON.parse(data);\n          if (Array.isArray(parsed) && parsed.length > 0) {\n            tasks = parsed;\n            console.log(`✅ Found tasks data in '${key}': ${tasks.length} tasks`);\n            break;\n          }\n        } catch (e) {\n          console.warn(`Failed to parse ${key}:`, e);\n        }\n      }\n    }\n\n    // Try to find focus sessions data\n    for (const key of possibleFocusKeys) {\n      const data = localStorage.getItem(key);\n      if (data) {\n        try {\n          const parsed = JSON.parse(data);\n          if (Array.isArray(parsed) && parsed.length > 0) {\n            focusSessions = parsed;\n            console.log(`⏱️ Found focus sessions data in '${key}': ${focusSessions.length} sessions`);\n            break;\n          }\n        } catch (e) {\n          console.warn(`Failed to parse ${key}:`, e);\n        }\n      }\n    }\n\n    // Calculate comprehensive stats\n    const stats = {\n      // Notes stats\n      totalNotes: notes.length,\n      totalWords: this.calculateTotalWords(notes),\n      uniqueTags: this.calculateUniqueTags(notes),\n      notesToday: this.calculateNotesToday(notes),\n      noteStreak: this.calculateNoteStreak(notes),\n      maxWordsInNote: this.calculateMaxWords(notes),\n      maxTagsInNote: this.calculateMaxTags(notes),\n      maxNoteEdits: this.calculateMaxEditsInNote(notes),\n      totalEdits: this.calculateTotalEdits(notes),\n      notesThisWeek: this.calculateNotesThisWeek(notes),\n      weekendNotes: this.calculateWeekendNotes(notes),\n      // Tasks stats\n      totalTasks: tasks.length,\n      completedTasks: this.calculateCompletedTasks(tasks),\n      tasksToday: this.calculateTasksToday(tasks),\n      taskStreak: this.calculateTaskStreak(tasks),\n      highPriorityTasks: this.calculateHighPriorityTasks(tasks),\n      earlyCompletions: this.calculateEarlyCompletions(tasks),\n      tasksThisWeek: this.calculateTasksThisWeek(tasks),\n      tasksThisMonth: this.calculateTasksThisMonth(tasks),\n      taskCategories: this.calculateTaskCategories(tasks),\n      priorityUsage: this.calculatePriorityUsage(tasks),\n      dueDateUsage: this.calculateDueDateUsage(tasks),\n      // Focus stats\n      totalSessions: focusSessions.length,\n      totalFocusTime: this.calculateTotalFocusTime(focusSessions),\n      totalFocusMinutes: this.calculateTotalFocusMinutes(focusSessions),\n      maxSessionDuration: this.calculateMaxSessionDuration(focusSessions),\n      focusStreak: this.calculateFocusStreak(focusSessions),\n      averageSessionLength: this.calculateAverageSessionLength(focusSessions),\n      categoryTime: this.calculateCategoryTime(focusSessions),\n      categorySessions: this.calculateCategorySessions(focusSessions),\n      uniqueCategories: this.calculateUniqueCategories(focusSessions),\n      // Combined stats\n      daysActive: this.calculateDaysActive(notes, tasks, focusSessions),\n      currentStreak: this.calculateCurrentStreak(notes, tasks, focusSessions)\n    };\n    console.log('📊 CALCULATED STATS:', stats);\n    return stats;\n  }\n\n  // Helper calculation methods\n  calculateTotalWords(notes) {\n    return notes.reduce((total, note) => {\n      const content = note.content || note.text || note.body || '';\n      const words = content.split(/\\s+/).filter(word => word.length > 0);\n      return total + words.length;\n    }, 0);\n  }\n  calculateUniqueTags(notes) {\n    const allTags = new Set();\n    notes.forEach(note => {\n      const tags = note.tags || note.categories || [];\n      if (Array.isArray(tags)) {\n        tags.forEach(tag => allTags.add(tag));\n      }\n    });\n    return allTags.size;\n  }\n  calculateNotesToday(notes) {\n    const today = new Date().toDateString();\n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date).toDateString() === today;\n    }).length;\n  }\n  calculateNoteStreak(notes) {\n    if (notes.length === 0) return 0;\n    const notesByDate = {};\n    notes.forEach(note => {\n      const date = note.createdAt || note.created || note.date;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        notesByDate[dateStr] = true;\n      }\n    });\n    const sortedDates = Object.keys(notesByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    for (let i = 0; i < sortedDates.length; i++) {\n      const noteDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - noteDate) / (1000 * 60 * 60 * 24));\n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    return streak;\n  }\n  calculateMaxWords(notes) {\n    return Math.max(...notes.map(note => {\n      const content = note.content || note.text || note.body || '';\n      return content.split(/\\s+/).filter(word => word.length > 0).length;\n    }), 0);\n  }\n  calculateMaxTags(notes) {\n    return Math.max(...notes.map(note => {\n      const tags = note.tags || note.categories || [];\n      return Array.isArray(tags) ? tags.length : 0;\n    }), 0);\n  }\n  calculateMaxEditsInNote(notes) {\n    return Math.max(...notes.map(note => {\n      return note.editCount || note.edits || 1;\n    }), 0);\n  }\n  calculateTotalEdits(notes) {\n    return notes.reduce((total, note) => {\n      return total + (note.editCount || note.edits || 1);\n    }, 0);\n  }\n  calculateNotesThisWeek(notes) {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date) >= oneWeekAgo;\n    }).length;\n  }\n  calculateWeekendNotes(notes) {\n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date).getDay() === 0; // 0 = Sunday\n    }).length;\n  }\n  calculateCompletedTasks(tasks) {\n    return tasks.filter(task => task.completed || task.status === 'completed' || task.status === 'done' || task.isDone).length;\n  }\n  calculateTasksToday(tasks) {\n    const today = new Date().toDateString();\n    return tasks.filter(task => {\n      const completedDate = task.completedAt || task.completed_at || task.doneAt;\n      const createdDate = task.createdAt || task.created || task.date;\n      return completedDate && new Date(completedDate).toDateString() === today || createdDate && new Date(createdDate).toDateString() === today;\n    }).length;\n  }\n  calculateTaskStreak(tasks) {\n    // Simplified task streak calculation\n    const completedTasks = tasks.filter(task => task.completed || task.status === 'completed');\n    const tasksByDate = {};\n    completedTasks.forEach(task => {\n      const date = task.completedAt || task.completed_at || task.doneAt;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        tasksByDate[dateStr] = true;\n      }\n    });\n    const sortedDates = Object.keys(tasksByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    for (let i = 0; i < sortedDates.length; i++) {\n      const taskDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - taskDate) / (1000 * 60 * 60 * 24));\n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    return streak;\n  }\n  calculateHighPriorityTasks(tasks) {\n    return tasks.filter(task => {\n      const priority = task.priority || task.importance;\n      const isCompleted = task.completed || task.status === 'completed';\n      return isCompleted && (priority === 'high' || priority === 'urgent' || priority === 1);\n    }).length;\n  }\n  calculateEarlyCompletions(tasks) {\n    return tasks.filter(task => {\n      const completedAt = task.completedAt || task.completed_at;\n      const dueDate = task.dueDate || task.due || task.deadline;\n      const isCompleted = task.completed || task.status === 'completed';\n      return isCompleted && completedAt && dueDate && new Date(completedAt) < new Date(dueDate);\n    }).length;\n  }\n  calculateTasksThisWeek(tasks) {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created;\n      return date && new Date(date) >= oneWeekAgo;\n    }).length;\n  }\n  calculateTasksThisMonth(tasks) {\n    const oneMonthAgo = new Date();\n    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);\n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created;\n      return date && new Date(date) >= oneMonthAgo;\n    }).length;\n  }\n  calculateTaskCategories(tasks) {\n    const categories = new Set();\n    tasks.forEach(task => {\n      const category = task.category || task.taskCategory || 'uncategorized';\n      if (category) {\n        categories.add(category);\n      }\n    });\n    return categories.size;\n  }\n  calculatePriorityUsage(tasks) {\n    const priorities = new Set();\n    tasks.forEach(task => {\n      const priority = task.priority || task.importance;\n      if (priority) {\n        priorities.add(priority);\n      }\n    });\n    return priorities.size;\n  }\n  calculateDueDateUsage(tasks) {\n    return tasks.filter(task => task.dueDate || task.due || task.deadline).length;\n  }\n  calculateTotalFocusTime(sessions) {\n    return sessions.reduce((total, session) => {\n      return total + (session.timeSpent || session.duration || session.time || 0);\n    }, 0);\n  }\n  calculateMaxSessionDuration(sessions) {\n    return Math.max(...sessions.map(session => session.timeSpent || session.duration || session.time || 0), 0);\n  }\n  calculateFocusStreak(sessions) {\n    if (sessions.length === 0) return 0;\n    const sessionsByDate = {};\n    sessions.forEach(session => {\n      const date = session.createdAt || session.date || session.timestamp;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        sessionsByDate[dateStr] = true;\n      }\n    });\n    const sortedDates = Object.keys(sessionsByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    for (let i = 0; i < sortedDates.length; i++) {\n      const sessionDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - sessionDate) / (1000 * 60 * 60 * 24));\n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    return streak;\n  }\n  calculateAverageSessionLength(sessions) {\n    if (sessions.length === 0) return 0;\n    const totalTime = this.calculateTotalFocusTime(sessions);\n    return Math.round(totalTime / sessions.length);\n  }\n  calculateTotalFocusMinutes(sessions) {\n    return sessions.reduce((total, session) => {\n      const duration = session.duration || session.time || session.minutes || 0;\n      // Convert to minutes if it's in seconds\n      return total + (duration > 300 ? Math.round(duration / 60) : duration);\n    }, 0);\n  }\n  calculateCategoryTime(sessions) {\n    const categoryTime = {};\n    sessions.forEach(session => {\n      const category = session.category || 'general';\n      const time = session.timeSpent || session.duration || session.time || 0;\n      categoryTime[category] = (categoryTime[category] || 0) + time;\n    });\n    return categoryTime;\n  }\n  calculateCategorySessions(sessions) {\n    const categorySessions = {};\n    sessions.forEach(session => {\n      const category = session.category || 'general';\n      categorySessions[category] = (categorySessions[category] || 0) + 1;\n    });\n    return categorySessions;\n  }\n  calculateUniqueCategories(sessions) {\n    const categories = new Set();\n    sessions.forEach(session => {\n      if (session.category) {\n        categories.add(session.category);\n      }\n    });\n    return categories.size;\n  }\n  calculateSessionsByDuration(sessions) {\n    const sessionsByDuration = {};\n    sessions.forEach(session => {\n      const duration = session.timeSpent || session.duration || session.time || 0;\n      sessionsByDuration[duration] = (sessionsByDuration[duration] || 0) + 1;\n    });\n    return sessionsByDuration;\n  }\n\n  // Override the total focus time calculation for your data structure\n  calculateTotalFocusTime(sessions) {\n    return sessions.reduce((total, session) => {\n      return total + (session.timeSpent || session.duration || session.time || session.minutes || 0);\n    }, 0);\n  }\n\n  // Override max session duration for your data structure\n  calculateMaxSessionDuration(sessions) {\n    return Math.max(...sessions.map(session => session.timeSpent || session.duration || session.time || session.minutes || 0), 0);\n  }\n  calculateDaysActive(notes, tasks, sessions) {\n    const allDates = new Set();\n    [...notes, ...tasks, ...sessions].forEach(item => {\n      const date = item.createdAt || item.created || item.date || item.timestamp;\n      if (date) {\n        allDates.add(new Date(date).toDateString());\n      }\n    });\n    return allDates.size;\n  }\n  calculateCurrentStreak(notes, tasks, sessions) {\n    // Combined activity streak\n    const allDates = new Set();\n    [...notes, ...tasks, ...sessions].forEach(item => {\n      const date = item.createdAt || item.created || item.date || item.timestamp;\n      if (date) {\n        allDates.add(new Date(date).toDateString());\n      }\n    });\n    const sortedDates = Array.from(allDates).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    for (let i = 0; i < sortedDates.length; i++) {\n      const activityDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - activityDate) / (1000 * 60 * 60 * 24));\n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    return streak;\n  }\n}\nexport const achievementService = new AchievementService();\nexport default achievementService;","map":{"version":3,"names":["allAchievements","tierInfo","AchievementService","constructor","unlockedAchievements","loadUnlockedAchievements","listeners","saved","localStorage","getItem","JSON","parse","saveUnlockedAchievements","setItem","stringify","addEventListener","callback","push","removeEventListener","filter","listener","notifyListeners","achievement","forEach","isUnlocked","achievementId","some","a","id","unlockAchievement","find","unlockedAchievement","unlockedAt","Date","toISOString","syncAchievementWithBackend","triggerAchievementNotification","trackAchievementUnlock","response","fetch","method","headers","body","username","ok","console","log","warn","error","getUnlockedAchievements","includes","newUnlocked","achievementData","unlockDates","checkAchievements","userStats","newlyUnlocked","meetsRequirement","requirement","type","totalSessions","target","totalFocusTime","totalFocusMinutes","maxSessionDuration","categoryTime","category","allCategoryTime","totalTimeAllCategories","Object","values","reduce","sum","time","uniqueCategories","totalNotes","totalWords","uniqueTags","totalEdits","maxNoteEdits","maxEditsInNote","maxWordsInNote","maxTagsInNote","weekendNotes","notesThisWeek","noteStreak","timeRangeNotes","completedTasks","totalTasks","tasksToday","tasksThisWeek","tasksThisMonth","highPriorityTasks","earlyCompletions","taskStreak","taskCategories","priorityUsage","dueDateUsage","ratio","dailyCombo","weeklyCombo","completedAchievements","currentStreak","categoryMastery","tier","emoji","name","xpReward","window","dispatchEvent","CustomEvent","detail","timestamp","playAchievementSound","audio","Audio","volume","play","catch","getAchievementProgress","req","current","Math","min","getNextAchievements","limit","map","progress","sort","b","slice","getRecentlyUnlocked","days","cutoffDate","setDate","getDate","getStats","total","length","unlocked","byTier","common","uncommon","rare","legendary","totalXP","percentage","round","recentUnlocks","forceUnlock","currentUnlocked","undefined","resetAchievements","removeItem","cleanupLocalStorage","unlockedIds","getAchievementWithUnlockDate","data","Boolean","recalculateAchievements","previouslyUnlocked","getCurrentUserStats","possibleNoteKeys","possibleTaskKeys","possibleFocusKeys","notes","tasks","focusSessions","key","parsed","Array","isArray","e","stats","calculateTotalWords","calculateUniqueTags","notesToday","calculateNotesToday","calculateNoteStreak","calculateMaxWords","calculateMaxTags","calculateMaxEditsInNote","calculateTotalEdits","calculateNotesThisWeek","calculateWeekendNotes","calculateCompletedTasks","calculateTasksToday","calculateTaskStreak","calculateHighPriorityTasks","calculateEarlyCompletions","calculateTasksThisWeek","calculateTasksThisMonth","calculateTaskCategories","calculatePriorityUsage","calculateDueDateUsage","calculateTotalFocusTime","calculateTotalFocusMinutes","calculateMaxSessionDuration","focusStreak","calculateFocusStreak","averageSessionLength","calculateAverageSessionLength","calculateCategoryTime","categorySessions","calculateCategorySessions","calculateUniqueCategories","daysActive","calculateDaysActive","calculateCurrentStreak","note","content","text","words","split","word","allTags","Set","tags","categories","tag","add","size","today","toDateString","date","createdAt","created","notesByDate","dateStr","sortedDates","keys","streak","currentDate","i","noteDate","diffDays","floor","max","editCount","edits","oneWeekAgo","getDay","task","completed","status","isDone","completedDate","completedAt","completed_at","doneAt","createdDate","tasksByDate","taskDate","priority","importance","isCompleted","dueDate","due","deadline","oneMonthAgo","setMonth","getMonth","taskCategory","priorities","sessions","session","timeSpent","duration","sessionsByDate","sessionDate","totalTime","minutes","calculateSessionsByDuration","sessionsByDuration","allDates","item","from","activityDate","achievementService"],"sources":["/Users/jenn/Projects/Pixel-Pages/frontend/src/services/achievementService.js"],"sourcesContent":["import { allAchievements, tierInfo } from '../data/achievements';\n\nclass AchievementService {\n  constructor() {\n    this.unlockedAchievements = this.loadUnlockedAchievements();\n    this.listeners = [];\n  }\n\n  // Load unlocked achievements from localStorage\n  loadUnlockedAchievements() {\n    const saved = localStorage.getItem('unlockedAchievements');\n    return saved ? JSON.parse(saved) : [];\n  }\n\n  // Save unlocked achievements to localStorage\n  saveUnlockedAchievements() {\n    localStorage.setItem('unlockedAchievements', JSON.stringify(this.unlockedAchievements));\n  }\n\n  // Add event listener for achievement unlocks\n  addEventListener(callback) {\n    this.listeners.push(callback);\n  }\n\n  // Remove event listener\n  removeEventListener(callback) {\n    this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n\n  // Notify listeners of achievement unlock\n  notifyListeners(achievement) {\n    this.listeners.forEach(callback => callback(achievement));\n  }\n\n  // Check if achievement is unlocked\n  isUnlocked(achievementId) {\n    return this.unlockedAchievements.some(a => a.id === achievementId);\n  }\n\n  // Unlock achievement\n  unlockAchievement(achievementId) {\n    if (this.isUnlocked(achievementId)) return false;\n    \n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement) return false;\n\n    const unlockedAchievement = {\n      ...achievement,\n      unlockedAt: new Date().toISOString()\n    };\n\n    this.unlockedAchievements.push(unlockedAchievement);\n    this.saveUnlockedAchievements();\n    \n    // ✅ Sync with backend immediately\n    this.syncAchievementWithBackend(achievementId);\n    \n    // Trigger achievement notification\n    this.triggerAchievementNotification(achievement);\n    this.notifyListeners(achievement);\n    \n    // Track when achievements are unlocked\n    this.trackAchievementUnlock(achievementId);\n    \n    return true;\n  }\n\n  // Sync achievement with backend\n  async syncAchievementWithBackend(achievementId) {\n    try {\n      const response = await fetch('http://localhost:8080/api/player/achievements/unlock', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          username: 'Jroc_182', // Changed from 'user'\n          achievementId: achievementId\n        }),\n      });\n      \n      if (response.ok) {\n        console.log(`✅ Synced ${achievementId} with backend`);\n      } else {\n        console.warn(`⚠️ Failed to sync ${achievementId} with backend`);\n      }\n    } catch (error) {\n      console.error(`❌ Error syncing ${achievementId}:`, error);\n    }\n  }\n\n  // Track when achievements are unlocked\n  trackAchievementUnlock(achievementId) {\n    const unlockedAchievements = this.getUnlockedAchievements();\n    \n    if (!unlockedAchievements.includes(achievementId)) {\n      const newUnlocked = [...unlockedAchievements, achievementId];\n      \n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData.unlockedAchievements = newUnlocked;\n      achievementData.unlockDates = {\n        ...achievementData.unlockDates,\n        [achievementId]: new Date().toISOString()\n      };\n      \n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n    }\n  }\n\n  // Check achievements based on user stats\n  checkAchievements(userStats) {\n    const newlyUnlocked = [];\n\n    allAchievements.forEach(achievement => {\n      if (!this.isUnlocked(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        }\n      }\n    });\n\n    return newlyUnlocked;\n  }\n\n  // Enhanced requirement checking\n  meetsRequirement(requirement, userStats) {\n    switch (requirement.type) {\n      // Focus/Session requirements (existing)\n      case 'session_count':\n        return (userStats.totalSessions || 0) >= requirement.target;\n      \n      case 'total_time':\n        return (userStats.totalFocusTime || userStats.totalFocusMinutes || 0) >= requirement.target;\n      \n      case 'max_session':\n        return (userStats.maxSessionDuration || 0) >= requirement.target;\n      \n      case 'category_focus':\n        const categoryTime = userStats.categoryTime || {};\n        return (categoryTime[requirement.category] || 0) >= requirement.target;\n      \n      case 'all_categories_time':\n        const allCategoryTime = userStats.categoryTime || {};\n        const totalTimeAllCategories = Object.values(allCategoryTime).reduce((sum, time) => sum + time, 0);\n        return totalTimeAllCategories >= requirement.target;\n      \n      case 'unique_categories':\n        return (userStats.uniqueCategories || 0) >= requirement.target;\n\n      // NOTE REQUIREMENTS (ADD THESE)\n      case 'note_count':\n        return (userStats.totalNotes || 0) >= requirement.target;\n      \n      case 'word_count':\n        return (userStats.totalWords || 0) >= requirement.target;\n      \n      case 'tag_count':\n      case 'unique_tags':\n        return (userStats.uniqueTags || 0) >= requirement.target;\n      \n      case 'note_edits':\n        return (userStats.totalEdits || 0) >= requirement.target;\n      \n      case 'single_note_edits':\n        return (userStats.maxNoteEdits || userStats.maxEditsInNote || 0) >= requirement.target;\n      \n      case 'single_note_words':\n        return (userStats.maxWordsInNote || 0) >= requirement.target;\n      \n      case 'single_note_tags':\n        return (userStats.maxTagsInNote || 0) >= requirement.target;\n      \n      case 'weekend_notes':\n        return (userStats.weekendNotes || 0) >= requirement.target;\n      \n      case 'weekly_notes':\n        return (userStats.notesThisWeek || 0) >= requirement.target;\n      \n      case 'streak':\n        return (userStats.noteStreak || 0) >= requirement.target;\n      \n      case 'time_range':\n        return (userStats.timeRangeNotes || 0) >= 1; // Simplified for now\n\n      // TASK REQUIREMENTS (ADD THESE)\n      case 'task_count':\n        return (userStats.completedTasks || 0) >= requirement.target;\n      \n      case 'tasks_created':\n        return (userStats.totalTasks || 0) >= requirement.target;\n      \n      case 'daily_tasks':\n        return (userStats.tasksToday || 0) >= requirement.target;\n      \n      case 'weekly_tasks':\n        return (userStats.tasksThisWeek || 0) >= requirement.target;\n      \n      case 'monthly_tasks':\n        return (userStats.tasksThisMonth || 0) >= requirement.target;\n      \n      case 'high_priority_tasks':\n        return (userStats.highPriorityTasks || 0) >= requirement.target;\n      \n      case 'early_completions':\n        return (userStats.earlyCompletions || 0) >= requirement.target;\n      \n      case 'completion_streak':\n        return (userStats.taskStreak || 0) >= requirement.target;\n      \n      case 'task_categories':\n        return (userStats.taskCategories || 0) >= requirement.target;\n      \n      case 'priority_usage':\n        return (userStats.priorityUsage || 0) >= requirement.target;\n      \n      case 'due_date_usage':\n        return (userStats.dueDateUsage || 0) >= requirement.target;\n      \n      case 'completion_ratio':\n        const totalTasks = userStats.totalTasks || 0;\n        const completedTasks = userStats.completedTasks || 0;\n        return totalTasks > 0 && (completedTasks / totalTasks) >= requirement.ratio;\n\n      // COMBO/SPECIAL REQUIREMENTS (ADD THESE)\n      case 'daily_combo':\n        return (userStats.dailyCombo || false);\n      \n      case 'weekly_combo':\n        return (userStats.weeklyCombo || false);\n      \n      case 'achievement_count':\n        return (userStats.completedAchievements || 0) >= requirement.target;\n      \n      case 'activity_consistency':\n        return (userStats.currentStreak || 0) >= requirement.target;\n\n      case 'category_mastery':\n        return (userStats.categoryMastery || 0) >= requirement.target;\n      \n      default:\n        console.warn(`Unknown requirement type: ${requirement.type}`);\n        return false;\n    }\n  }\n\n  // Trigger achievement notification with enhanced styling\n  triggerAchievementNotification(achievement) {\n    const tier = tierInfo[achievement.tier];\n    \n    console.log(`🎉 ${tier.emoji} ${achievement.name} UNLOCKED! (+${achievement.xpReward} XP)`);\n    \n    // Dispatch custom event for UI components\n    window.dispatchEvent(new CustomEvent('achievementUnlocked', {\n      detail: {\n        achievement,\n        tier,\n        timestamp: new Date().toISOString()\n      }\n    }));\n\n    // Play achievement sound (if available)\n    this.playAchievementSound(achievement.tier);\n  }\n\n  // Play achievement sound based on tier\n  playAchievementSound(tier) {\n    try {\n      const audio = new Audio(`/sounds/achievement_${tier}.mp3`);\n      audio.volume = 0.3;\n      audio.play().catch(() => {\n        console.log(`Sound not found for tier: ${tier}`);\n      });\n    } catch (error) {\n      console.error('Error playing achievement sound:', error);\n    }\n  }\n\n  // Get achievement progress\n  getAchievementProgress(achievementId, userStats) {\n    const achievement = allAchievements.find(a => a.id === achievementId);\n    if (!achievement || this.isUnlocked(achievementId)) return 1;\n\n    const req = achievement.requirement;\n    let current = 0;\n    let target = req.target || 1;\n\n    switch (req.type) {\n      case 'note_count':\n        current = userStats.totalNotes || 0;\n        break;\n      case 'word_count':\n        current = userStats.totalWords || 0;\n        break;\n      case 'task_count':\n        current = userStats.totalTasks || 0;\n        break;\n      case 'session_count':\n        current = userStats.totalSessions || 0;\n        break;\n      case 'total_time':\n        current = userStats.totalFocusTime || 0;\n        break;\n      case 'unique_tags':\n        current = userStats.uniqueTags || 0;\n        break;\n      case 'streak':\n      case 'completion_streak':\n      case 'daily_streak':\n        current = userStats[req.type === 'streak' ? 'noteStreak' : \n                            req.type === 'completion_streak' ? 'taskStreak' : 'focusStreak'] || 0;\n        break;\n      default:\n        return 0;\n    }\n\n    return Math.min(current / target, 1);\n  }\n\n  // Get user's next achievements to unlock\n  getNextAchievements(userStats, limit = 5) {\n    return allAchievements\n      .filter(achievement => !this.isUnlocked(achievement.id))\n      .map(achievement => ({\n        ...achievement,\n        progress: this.getAchievementProgress(achievement.id, userStats)\n      }))\n      .sort((a, b) => b.progress - a.progress)\n      .slice(0, limit);\n  }\n\n  // Get recently unlocked achievements\n  getRecentlyUnlocked(days = 7) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    \n    return this.unlockedAchievements\n      .filter(achievement => new Date(achievement.unlockedAt) >= cutoffDate)\n      .sort((a, b) => new Date(b.unlockedAt) - new Date(a.unlockedAt));\n  }\n\n  // Get stats summary\n  getStats() {\n    const total = allAchievements.length;\n    const unlocked = this.unlockedAchievements.length;\n    const byTier = {\n      common: this.unlockedAchievements.filter(a => a.tier === 'common').length,\n      uncommon: this.unlockedAchievements.filter(a => a.tier === 'uncommon').length,\n      rare: this.unlockedAchievements.filter(a => a.tier === 'rare').length,\n      legendary: this.unlockedAchievements.filter(a => a.tier === 'legendary').length\n    };\n\n    const totalXP = this.unlockedAchievements.reduce((sum, achievement) => sum + achievement.xpReward, 0);\n\n    return {\n      total,\n      unlocked,\n      percentage: Math.round((unlocked / total) * 100),\n      byTier,\n      totalXP,\n      recentUnlocks: this.getRecentlyUnlocked(7).length\n    };\n  }\n\n  // Force unlock an achievement (for testing)\n  forceUnlock(achievementId) {\n    console.log(`🧪 FORCE UNLOCK: ${achievementId}`);\n    \n    // Get current unlocked achievements and filter out nulls\n    const currentUnlocked = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]')\n      .filter(id => id !== null && id !== undefined);\n    \n    if (!currentUnlocked.includes(achievementId)) {\n      const newUnlocked = [...currentUnlocked, achievementId];\n      localStorage.setItem('unlockedAchievements', JSON.stringify(newUnlocked));\n      \n      // Store with timestamp\n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      achievementData[achievementId] = {\n        unlockedAt: new Date().toISOString(),\n        progress: 100\n      };\n      localStorage.setItem('achievementData', JSON.stringify(achievementData));\n      \n      console.log(`✅ Force unlocked: ${achievementId}`);\n      \n      // Sync with backend\n      this.syncAchievementWithBackend(achievementId);\n      \n      // Trigger update event\n      window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n    } else {\n      console.log(`⚠️ ${achievementId} already unlocked`);\n    }\n  }\n\n  // Reset all achievements (for testing)\n  resetAchievements() {\n    console.log('🧪 RESET: Clearing all achievements');\n    localStorage.removeItem('unlockedAchievements');\n    localStorage.removeItem('achievementData');\n    window.dispatchEvent(new CustomEvent('achievementsUpdated'));\n  }\n\n  // Clean up localStorage (remove null values)\n  cleanupLocalStorage() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]')\n      .filter(id => id !== null && id !== undefined);\n    \n    localStorage.setItem('unlockedAchievements', JSON.stringify(unlockedIds));\n    console.log('🧹 Cleaned up localStorage, removed null values');\n  }\n\n  // Get achievement with unlock date\n  getAchievementWithUnlockDate(achievement) {\n    const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n    const unlockDates = achievementData.unlockDates || {};\n    \n    return {\n      ...achievement,\n      unlockedAt: unlockDates[achievement.id] || null\n    };\n  }\n\n  // Get unlocked achievements\n  getUnlockedAchievements() {\n    const unlockedIds = JSON.parse(localStorage.getItem('unlockedAchievements') || '[]')\n      .filter(id => id !== null && id !== undefined);\n    \n    return unlockedIds.map(id => {\n      const achievement = allAchievements.find(a => a.id === id);\n      if (!achievement) {\n        console.warn(`⚠️ Achievement with id ${id} not found`);\n        return null;\n      }\n      \n      const achievementData = JSON.parse(localStorage.getItem('achievementData') || '{}');\n      const data = achievementData[id] || {};\n      \n      return {\n        ...achievement,\n        unlockedAt: data.unlockedAt || new Date().toISOString(),\n        progress: data.progress || 100\n      };\n    }).filter(Boolean);\n  }\n\n  // Recalculate and unlock all achievements based on current user stats\n  async recalculateAchievements(userStats) {\n    console.log('🔄 RECALCULATING ACHIEVEMENTS based on current stats:', userStats);\n    \n    const previouslyUnlocked = this.getUnlockedAchievements().map(a => a.id);\n    const newlyUnlocked = [];\n    \n    // Check every achievement against current stats\n    allAchievements.forEach(achievement => {\n      if (!previouslyUnlocked.includes(achievement.id)) {\n        if (this.meetsRequirement(achievement.requirement, userStats)) {\n          console.log(`🏆 Should unlock: ${achievement.id} - ${achievement.name}`);\n          if (this.unlockAchievement(achievement.id)) {\n            newlyUnlocked.push(achievement);\n          }\n        } else {\n          // Show progress for close achievements\n          const progress = this.getAchievementProgress(achievement.id, userStats);\n          if (progress > 0.5) {\n            console.log(`📈 Close to unlocking: ${achievement.id} - ${Math.round(progress * 100)}%`);\n          }\n        }\n      }\n    });\n    \n    console.log(`✅ Recalculation complete! Unlocked ${newlyUnlocked.length} new achievements:`, \n      newlyUnlocked.map(a => a.name));\n    \n    return newlyUnlocked;\n  }\n\n  // Enhanced data gathering that checks multiple possible storage keys\n  async getCurrentUserStats() {\n    console.log('📊 GATHERING USER STATS FROM ALL SOURCES...');\n    \n    // Check multiple possible storage keys (in case data was stored differently)\n    const possibleNoteKeys = ['notes', 'userNotes', 'pixelNotes', 'journalEntries'];\n    const possibleTaskKeys = ['tasks', 'userTasks', 'todoItems', 'missions'];\n    const possibleFocusKeys = ['focusSessions', 'timerSessions', 'pomodoroSessions'];\n    \n    let notes = [];\n    let tasks = [];\n    let focusSessions = [];\n    \n    // Try to find notes data\n    for (const key of possibleNoteKeys) {\n      const data = localStorage.getItem(key);\n      if (data) {\n        try {\n          const parsed = JSON.parse(data);\n          if (Array.isArray(parsed) && parsed.length > 0) {\n            notes = parsed;\n            console.log(`📝 Found notes data in '${key}': ${notes.length} notes`);\n            break;\n          }\n        } catch (e) {\n          console.warn(`Failed to parse ${key}:`, e);\n        }\n      }\n    }\n    \n    // Try to find tasks data\n    for (const key of possibleTaskKeys) {\n      const data = localStorage.getItem(key);\n      if (data) {\n        try {\n          const parsed = JSON.parse(data);\n          if (Array.isArray(parsed) && parsed.length > 0) {\n            tasks = parsed;\n            console.log(`✅ Found tasks data in '${key}': ${tasks.length} tasks`);\n            break;\n          }\n        } catch (e) {\n          console.warn(`Failed to parse ${key}:`, e);\n        }\n      }\n    }\n    \n    // Try to find focus sessions data\n    for (const key of possibleFocusKeys) {\n      const data = localStorage.getItem(key);\n      if (data) {\n        try {\n          const parsed = JSON.parse(data);\n          if (Array.isArray(parsed) && parsed.length > 0) {\n            focusSessions = parsed;\n            console.log(`⏱️ Found focus sessions data in '${key}': ${focusSessions.length} sessions`);\n            break;\n          }\n        } catch (e) {\n          console.warn(`Failed to parse ${key}:`, e);\n        }\n      }\n    }\n    \n    // Calculate comprehensive stats\n    const stats = {\n      // Notes stats\n      totalNotes: notes.length,\n      totalWords: this.calculateTotalWords(notes),\n      uniqueTags: this.calculateUniqueTags(notes),\n      notesToday: this.calculateNotesToday(notes),\n      noteStreak: this.calculateNoteStreak(notes),\n      maxWordsInNote: this.calculateMaxWords(notes),\n      maxTagsInNote: this.calculateMaxTags(notes),\n      maxNoteEdits: this.calculateMaxEditsInNote(notes),\n      totalEdits: this.calculateTotalEdits(notes),\n      notesThisWeek: this.calculateNotesThisWeek(notes),\n      weekendNotes: this.calculateWeekendNotes(notes),\n      \n      // Tasks stats\n      totalTasks: tasks.length,\n      completedTasks: this.calculateCompletedTasks(tasks),\n      tasksToday: this.calculateTasksToday(tasks),\n      taskStreak: this.calculateTaskStreak(tasks),\n      highPriorityTasks: this.calculateHighPriorityTasks(tasks),\n      earlyCompletions: this.calculateEarlyCompletions(tasks),\n      tasksThisWeek: this.calculateTasksThisWeek(tasks),\n      tasksThisMonth: this.calculateTasksThisMonth(tasks),\n      taskCategories: this.calculateTaskCategories(tasks),\n      priorityUsage: this.calculatePriorityUsage(tasks),\n      dueDateUsage: this.calculateDueDateUsage(tasks),\n      \n      // Focus stats\n      totalSessions: focusSessions.length,\n      totalFocusTime: this.calculateTotalFocusTime(focusSessions),\n      totalFocusMinutes: this.calculateTotalFocusMinutes(focusSessions),\n      maxSessionDuration: this.calculateMaxSessionDuration(focusSessions),\n      focusStreak: this.calculateFocusStreak(focusSessions),\n      averageSessionLength: this.calculateAverageSessionLength(focusSessions),\n      categoryTime: this.calculateCategoryTime(focusSessions),\n      categorySessions: this.calculateCategorySessions(focusSessions),\n      uniqueCategories: this.calculateUniqueCategories(focusSessions),\n      \n      // Combined stats\n      daysActive: this.calculateDaysActive(notes, tasks, focusSessions),\n      currentStreak: this.calculateCurrentStreak(notes, tasks, focusSessions),\n    };\n    \n    console.log('📊 CALCULATED STATS:', stats);\n    return stats;\n  }\n\n  // Helper calculation methods\n  calculateTotalWords(notes) {\n    return notes.reduce((total, note) => {\n      const content = note.content || note.text || note.body || '';\n      const words = content.split(/\\s+/).filter(word => word.length > 0);\n      return total + words.length;\n    }, 0);\n  }\n\n  calculateUniqueTags(notes) {\n    const allTags = new Set();\n    notes.forEach(note => {\n      const tags = note.tags || note.categories || [];\n      if (Array.isArray(tags)) {\n        tags.forEach(tag => allTags.add(tag));\n      }\n    });\n    return allTags.size;\n  }\n\n  calculateNotesToday(notes) {\n    const today = new Date().toDateString();\n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date).toDateString() === today;\n    }).length;\n  }\n\n  calculateNoteStreak(notes) {\n    if (notes.length === 0) return 0;\n    \n    const notesByDate = {};\n    notes.forEach(note => {\n      const date = note.createdAt || note.created || note.date;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        notesByDate[dateStr] = true;\n      }\n    });\n    \n    const sortedDates = Object.keys(notesByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    \n    for (let i = 0; i < sortedDates.length; i++) {\n      const noteDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - noteDate) / (1000 * 60 * 60 * 24));\n      \n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    \n    return streak;\n  }\n\n  calculateMaxWords(notes) {\n    return Math.max(...notes.map(note => {\n      const content = note.content || note.text || note.body || '';\n      return content.split(/\\s+/).filter(word => word.length > 0).length;\n    }), 0);\n  }\n\n  calculateMaxTags(notes) {\n    return Math.max(...notes.map(note => {\n      const tags = note.tags || note.categories || [];\n      return Array.isArray(tags) ? tags.length : 0;\n    }), 0);\n  }\n\n  calculateMaxEditsInNote(notes) {\n    return Math.max(...notes.map(note => {\n      return note.editCount || note.edits || 1;\n    }), 0);\n  }\n\n  calculateTotalEdits(notes) {\n    return notes.reduce((total, note) => {\n      return total + (note.editCount || note.edits || 1);\n    }, 0);\n  }\n\n  calculateNotesThisWeek(notes) {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    \n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date) >= oneWeekAgo;\n    }).length;\n  }\n\n  calculateWeekendNotes(notes) {\n    return notes.filter(note => {\n      const date = note.createdAt || note.created || note.date;\n      return date && new Date(date).getDay() === 0; // 0 = Sunday\n    }).length;\n  }\n\n  calculateCompletedTasks(tasks) {\n    return tasks.filter(task => \n      task.completed || \n      task.status === 'completed' || \n      task.status === 'done' ||\n      task.isDone\n    ).length;\n  }\n\n  calculateTasksToday(tasks) {\n    const today = new Date().toDateString();\n    return tasks.filter(task => {\n      const completedDate = task.completedAt || task.completed_at || task.doneAt;\n      const createdDate = task.createdAt || task.created || task.date;\n      \n      return (completedDate && new Date(completedDate).toDateString() === today) ||\n             (createdDate && new Date(createdDate).toDateString() === today);\n    }).length;\n  }\n\n  calculateTaskStreak(tasks) {\n    // Simplified task streak calculation\n    const completedTasks = tasks.filter(task => \n      task.completed || task.status === 'completed'\n    );\n    \n    const tasksByDate = {};\n    completedTasks.forEach(task => {\n      const date = task.completedAt || task.completed_at || task.doneAt;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        tasksByDate[dateStr] = true;\n      }\n    });\n    \n    const sortedDates = Object.keys(tasksByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    \n    for (let i = 0; i < sortedDates.length; i++) {\n      const taskDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - taskDate) / (1000 * 60 * 60 * 24));\n      \n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    \n    return streak;\n  }\n\n  calculateHighPriorityTasks(tasks) {\n    return tasks.filter(task => {\n      const priority = task.priority || task.importance;\n      const isCompleted = task.completed || task.status === 'completed';\n      return isCompleted && (priority === 'high' || priority === 'urgent' || priority === 1);\n    }).length;\n  }\n\n  calculateEarlyCompletions(tasks) {\n    return tasks.filter(task => {\n      const completedAt = task.completedAt || task.completed_at;\n      const dueDate = task.dueDate || task.due || task.deadline;\n      const isCompleted = task.completed || task.status === 'completed';\n      \n      return isCompleted && completedAt && dueDate && \n             new Date(completedAt) < new Date(dueDate);\n    }).length;\n  }\n\n  calculateTasksThisWeek(tasks) {\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n    \n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created;\n      return date && new Date(date) >= oneWeekAgo;\n    }).length;\n  }\n\n  calculateTasksThisMonth(tasks) {\n    const oneMonthAgo = new Date();\n    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);\n    \n    return tasks.filter(task => {\n      const date = task.completedAt || task.createdAt || task.created;\n      return date && new Date(date) >= oneMonthAgo;\n    }).length;\n  }\n\n  calculateTaskCategories(tasks) {\n    const categories = new Set();\n    tasks.forEach(task => {\n      const category = task.category || task.taskCategory || 'uncategorized';\n      if (category) {\n        categories.add(category);\n      }\n    });\n    return categories.size;\n  }\n\n  calculatePriorityUsage(tasks) {\n    const priorities = new Set();\n    tasks.forEach(task => {\n      const priority = task.priority || task.importance;\n      if (priority) {\n        priorities.add(priority);\n      }\n    });\n    return priorities.size;\n  }\n\n  calculateDueDateUsage(tasks) {\n    return tasks.filter(task => task.dueDate || task.due || task.deadline).length;\n  }\n\n  calculateTotalFocusTime(sessions) {\n    return sessions.reduce((total, session) => {\n      return total + (session.timeSpent || session.duration || session.time || 0);\n    }, 0);\n  }\n\n  calculateMaxSessionDuration(sessions) {\n    return Math.max(...sessions.map(session => \n      session.timeSpent || session.duration || session.time || 0\n    ), 0);\n  }\n\n  calculateFocusStreak(sessions) {\n    if (sessions.length === 0) return 0;\n    \n    const sessionsByDate = {};\n    sessions.forEach(session => {\n      const date = session.createdAt || session.date || session.timestamp;\n      if (date) {\n        const dateStr = new Date(date).toDateString();\n        sessionsByDate[dateStr] = true;\n      }\n    });\n    \n    const sortedDates = Object.keys(sessionsByDate).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    \n    for (let i = 0; i < sortedDates.length; i++) {\n      const sessionDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - sessionDate) / (1000 * 60 * 60 * 24));\n      \n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    \n    return streak;\n  }\n\n  calculateAverageSessionLength(sessions) {\n    if (sessions.length === 0) return 0;\n    const totalTime = this.calculateTotalFocusTime(sessions);\n    return Math.round(totalTime / sessions.length);\n  }\n\n  calculateTotalFocusMinutes(sessions) {\n    return sessions.reduce((total, session) => {\n      const duration = session.duration || session.time || session.minutes || 0;\n      // Convert to minutes if it's in seconds\n      return total + (duration > 300 ? Math.round(duration / 60) : duration);\n    }, 0);\n  }\n\n  calculateCategoryTime(sessions) {\n    const categoryTime = {};\n    sessions.forEach(session => {\n      const category = session.category || 'general';\n      const time = session.timeSpent || session.duration || session.time || 0;\n      categoryTime[category] = (categoryTime[category] || 0) + time;\n    });\n    return categoryTime;\n  }\n\n  calculateCategorySessions(sessions) {\n    const categorySessions = {};\n    sessions.forEach(session => {\n      const category = session.category || 'general';\n      categorySessions[category] = (categorySessions[category] || 0) + 1;\n    });\n    return categorySessions;\n  }\n\n  calculateUniqueCategories(sessions) {\n    const categories = new Set();\n    sessions.forEach(session => {\n      if (session.category) {\n        categories.add(session.category);\n      }\n    });\n    return categories.size;\n  }\n\n  calculateSessionsByDuration(sessions) {\n    const sessionsByDuration = {};\n    sessions.forEach(session => {\n      const duration = session.timeSpent || session.duration || session.time || 0;\n      sessionsByDuration[duration] = (sessionsByDuration[duration] || 0) + 1;\n    });\n    return sessionsByDuration;\n  }\n\n  // Override the total focus time calculation for your data structure\n  calculateTotalFocusTime(sessions) {\n    return sessions.reduce((total, session) => {\n      return total + (session.timeSpent || session.duration || session.time || session.minutes || 0);\n    }, 0);\n  }\n\n  // Override max session duration for your data structure\n  calculateMaxSessionDuration(sessions) {\n    return Math.max(...sessions.map(session => \n      session.timeSpent || session.duration || session.time || session.minutes || 0\n    ), 0);\n  }\n\n  calculateDaysActive(notes, tasks, sessions) {\n    const allDates = new Set();\n    \n    [...notes, ...tasks, ...sessions].forEach(item => {\n      const date = item.createdAt || item.created || item.date || item.timestamp;\n      if (date) {\n        allDates.add(new Date(date).toDateString());\n      }\n    });\n    \n    return allDates.size;\n  }\n\n  calculateCurrentStreak(notes, tasks, sessions) {\n    // Combined activity streak\n    const allDates = new Set();\n    \n    [...notes, ...tasks, ...sessions].forEach(item => {\n      const date = item.createdAt || item.created || item.date || item.timestamp;\n      if (date) {\n        allDates.add(new Date(date).toDateString());\n      }\n    });\n    \n    const sortedDates = Array.from(allDates).sort((a, b) => new Date(b) - new Date(a));\n    let streak = 0;\n    let currentDate = new Date();\n    \n    for (let i = 0; i < sortedDates.length; i++) {\n      const activityDate = new Date(sortedDates[i]);\n      const diffDays = Math.floor((currentDate - activityDate) / (1000 * 60 * 60 * 24));\n      \n      if (diffDays === i) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n    \n    return streak;\n  }\n}\n\nexport const achievementService = new AchievementService();\nexport default achievementService;"],"mappings":"AAAA,SAASA,eAAe,EAAEC,QAAQ,QAAQ,sBAAsB;AAEhE,MAAMC,kBAAkB,CAAC;EACvBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,oBAAoB,GAAG,IAAI,CAACC,wBAAwB,CAAC,CAAC;IAC3D,IAAI,CAACC,SAAS,GAAG,EAAE;EACrB;;EAEA;EACAD,wBAAwBA,CAAA,EAAG;IACzB,MAAME,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,sBAAsB,CAAC;IAC1D,OAAOF,KAAK,GAAGG,IAAI,CAACC,KAAK,CAACJ,KAAK,CAAC,GAAG,EAAE;EACvC;;EAEA;EACAK,wBAAwBA,CAAA,EAAG;IACzBJ,YAAY,CAACK,OAAO,CAAC,sBAAsB,EAAEH,IAAI,CAACI,SAAS,CAAC,IAAI,CAACV,oBAAoB,CAAC,CAAC;EACzF;;EAEA;EACAW,gBAAgBA,CAACC,QAAQ,EAAE;IACzB,IAAI,CAACV,SAAS,CAACW,IAAI,CAACD,QAAQ,CAAC;EAC/B;;EAEA;EACAE,mBAAmBA,CAACF,QAAQ,EAAE;IAC5B,IAAI,CAACV,SAAS,GAAG,IAAI,CAACA,SAAS,CAACa,MAAM,CAACC,QAAQ,IAAIA,QAAQ,KAAKJ,QAAQ,CAAC;EAC3E;;EAEA;EACAK,eAAeA,CAACC,WAAW,EAAE;IAC3B,IAAI,CAAChB,SAAS,CAACiB,OAAO,CAACP,QAAQ,IAAIA,QAAQ,CAACM,WAAW,CAAC,CAAC;EAC3D;;EAEA;EACAE,UAAUA,CAACC,aAAa,EAAE;IACxB,OAAO,IAAI,CAACrB,oBAAoB,CAACsB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKH,aAAa,CAAC;EACpE;;EAEA;EACAI,iBAAiBA,CAACJ,aAAa,EAAE;IAC/B,IAAI,IAAI,CAACD,UAAU,CAACC,aAAa,CAAC,EAAE,OAAO,KAAK;IAEhD,MAAMH,WAAW,GAAGtB,eAAe,CAAC8B,IAAI,CAACH,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKH,aAAa,CAAC;IACrE,IAAI,CAACH,WAAW,EAAE,OAAO,KAAK;IAE9B,MAAMS,mBAAmB,GAAG;MAC1B,GAAGT,WAAW;MACdU,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;IACrC,CAAC;IAED,IAAI,CAAC9B,oBAAoB,CAACa,IAAI,CAACc,mBAAmB,CAAC;IACnD,IAAI,CAACnB,wBAAwB,CAAC,CAAC;;IAE/B;IACA,IAAI,CAACuB,0BAA0B,CAACV,aAAa,CAAC;;IAE9C;IACA,IAAI,CAACW,8BAA8B,CAACd,WAAW,CAAC;IAChD,IAAI,CAACD,eAAe,CAACC,WAAW,CAAC;;IAEjC;IACA,IAAI,CAACe,sBAAsB,CAACZ,aAAa,CAAC;IAE1C,OAAO,IAAI;EACb;;EAEA;EACA,MAAMU,0BAA0BA,CAACV,aAAa,EAAE;IAC9C,IAAI;MACF,MAAMa,QAAQ,GAAG,MAAMC,KAAK,CAAC,sDAAsD,EAAE;QACnFC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB,CAAC;QACDC,IAAI,EAAEhC,IAAI,CAACI,SAAS,CAAC;UACnB6B,QAAQ,EAAE,UAAU;UAAE;UACtBlB,aAAa,EAAEA;QACjB,CAAC;MACH,CAAC,CAAC;MAEF,IAAIa,QAAQ,CAACM,EAAE,EAAE;QACfC,OAAO,CAACC,GAAG,CAAC,YAAYrB,aAAa,eAAe,CAAC;MACvD,CAAC,MAAM;QACLoB,OAAO,CAACE,IAAI,CAAC,qBAAqBtB,aAAa,eAAe,CAAC;MACjE;IACF,CAAC,CAAC,OAAOuB,KAAK,EAAE;MACdH,OAAO,CAACG,KAAK,CAAC,mBAAmBvB,aAAa,GAAG,EAAEuB,KAAK,CAAC;IAC3D;EACF;;EAEA;EACAX,sBAAsBA,CAACZ,aAAa,EAAE;IACpC,MAAMrB,oBAAoB,GAAG,IAAI,CAAC6C,uBAAuB,CAAC,CAAC;IAE3D,IAAI,CAAC7C,oBAAoB,CAAC8C,QAAQ,CAACzB,aAAa,CAAC,EAAE;MACjD,MAAM0B,WAAW,GAAG,CAAC,GAAG/C,oBAAoB,EAAEqB,aAAa,CAAC;;MAE5D;MACA,MAAM2B,eAAe,GAAG1C,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC,IAAI,IAAI,CAAC;MACnF2C,eAAe,CAAChD,oBAAoB,GAAG+C,WAAW;MAClDC,eAAe,CAACC,WAAW,GAAG;QAC5B,GAAGD,eAAe,CAACC,WAAW;QAC9B,CAAC5B,aAAa,GAAG,IAAIQ,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MAC1C,CAAC;MAED1B,YAAY,CAACK,OAAO,CAAC,iBAAiB,EAAEH,IAAI,CAACI,SAAS,CAACsC,eAAe,CAAC,CAAC;MACxE5C,YAAY,CAACK,OAAO,CAAC,sBAAsB,EAAEH,IAAI,CAACI,SAAS,CAACqC,WAAW,CAAC,CAAC;IAC3E;EACF;;EAEA;EACAG,iBAAiBA,CAACC,SAAS,EAAE;IAC3B,MAAMC,aAAa,GAAG,EAAE;IAExBxD,eAAe,CAACuB,OAAO,CAACD,WAAW,IAAI;MACrC,IAAI,CAAC,IAAI,CAACE,UAAU,CAACF,WAAW,CAACM,EAAE,CAAC,EAAE;QACpC,IAAI,IAAI,CAAC6B,gBAAgB,CAACnC,WAAW,CAACoC,WAAW,EAAEH,SAAS,CAAC,EAAE;UAC7D,IAAI,IAAI,CAAC1B,iBAAiB,CAACP,WAAW,CAACM,EAAE,CAAC,EAAE;YAC1C4B,aAAa,CAACvC,IAAI,CAACK,WAAW,CAAC;UACjC;QACF;MACF;IACF,CAAC,CAAC;IAEF,OAAOkC,aAAa;EACtB;;EAEA;EACAC,gBAAgBA,CAACC,WAAW,EAAEH,SAAS,EAAE;IACvC,QAAQG,WAAW,CAACC,IAAI;MACtB;MACA,KAAK,eAAe;QAClB,OAAO,CAACJ,SAAS,CAACK,aAAa,IAAI,CAAC,KAAKF,WAAW,CAACG,MAAM;MAE7D,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAACO,cAAc,IAAIP,SAAS,CAACQ,iBAAiB,IAAI,CAAC,KAAKL,WAAW,CAACG,MAAM;MAE7F,KAAK,aAAa;QAChB,OAAO,CAACN,SAAS,CAACS,kBAAkB,IAAI,CAAC,KAAKN,WAAW,CAACG,MAAM;MAElE,KAAK,gBAAgB;QACnB,MAAMI,YAAY,GAAGV,SAAS,CAACU,YAAY,IAAI,CAAC,CAAC;QACjD,OAAO,CAACA,YAAY,CAACP,WAAW,CAACQ,QAAQ,CAAC,IAAI,CAAC,KAAKR,WAAW,CAACG,MAAM;MAExE,KAAK,qBAAqB;QACxB,MAAMM,eAAe,GAAGZ,SAAS,CAACU,YAAY,IAAI,CAAC,CAAC;QACpD,MAAMG,sBAAsB,GAAGC,MAAM,CAACC,MAAM,CAACH,eAAe,CAAC,CAACI,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAKD,GAAG,GAAGC,IAAI,EAAE,CAAC,CAAC;QAClG,OAAOL,sBAAsB,IAAIV,WAAW,CAACG,MAAM;MAErD,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAACmB,gBAAgB,IAAI,CAAC,KAAKhB,WAAW,CAACG,MAAM;;MAEhE;MACA,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAACoB,UAAU,IAAI,CAAC,KAAKjB,WAAW,CAACG,MAAM;MAE1D,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAACqB,UAAU,IAAI,CAAC,KAAKlB,WAAW,CAACG,MAAM;MAE1D,KAAK,WAAW;MAChB,KAAK,aAAa;QAChB,OAAO,CAACN,SAAS,CAACsB,UAAU,IAAI,CAAC,KAAKnB,WAAW,CAACG,MAAM;MAE1D,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAACuB,UAAU,IAAI,CAAC,KAAKpB,WAAW,CAACG,MAAM;MAE1D,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAACwB,YAAY,IAAIxB,SAAS,CAACyB,cAAc,IAAI,CAAC,KAAKtB,WAAW,CAACG,MAAM;MAExF,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAAC0B,cAAc,IAAI,CAAC,KAAKvB,WAAW,CAACG,MAAM;MAE9D,KAAK,kBAAkB;QACrB,OAAO,CAACN,SAAS,CAAC2B,aAAa,IAAI,CAAC,KAAKxB,WAAW,CAACG,MAAM;MAE7D,KAAK,eAAe;QAClB,OAAO,CAACN,SAAS,CAAC4B,YAAY,IAAI,CAAC,KAAKzB,WAAW,CAACG,MAAM;MAE5D,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAAC6B,aAAa,IAAI,CAAC,KAAK1B,WAAW,CAACG,MAAM;MAE7D,KAAK,QAAQ;QACX,OAAO,CAACN,SAAS,CAAC8B,UAAU,IAAI,CAAC,KAAK3B,WAAW,CAACG,MAAM;MAE1D,KAAK,YAAY;QACf,OAAO,CAACN,SAAS,CAAC+B,cAAc,IAAI,CAAC,KAAK,CAAC;MAAE;;MAE/C;MACA,KAAK,YAAY;QACf,OAAO,CAAC/B,SAAS,CAACgC,cAAc,IAAI,CAAC,KAAK7B,WAAW,CAACG,MAAM;MAE9D,KAAK,eAAe;QAClB,OAAO,CAACN,SAAS,CAACiC,UAAU,IAAI,CAAC,KAAK9B,WAAW,CAACG,MAAM;MAE1D,KAAK,aAAa;QAChB,OAAO,CAACN,SAAS,CAACkC,UAAU,IAAI,CAAC,KAAK/B,WAAW,CAACG,MAAM;MAE1D,KAAK,cAAc;QACjB,OAAO,CAACN,SAAS,CAACmC,aAAa,IAAI,CAAC,KAAKhC,WAAW,CAACG,MAAM;MAE7D,KAAK,eAAe;QAClB,OAAO,CAACN,SAAS,CAACoC,cAAc,IAAI,CAAC,KAAKjC,WAAW,CAACG,MAAM;MAE9D,KAAK,qBAAqB;QACxB,OAAO,CAACN,SAAS,CAACqC,iBAAiB,IAAI,CAAC,KAAKlC,WAAW,CAACG,MAAM;MAEjE,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAACsC,gBAAgB,IAAI,CAAC,KAAKnC,WAAW,CAACG,MAAM;MAEhE,KAAK,mBAAmB;QACtB,OAAO,CAACN,SAAS,CAACuC,UAAU,IAAI,CAAC,KAAKpC,WAAW,CAACG,MAAM;MAE1D,KAAK,iBAAiB;QACpB,OAAO,CAACN,SAAS,CAACwC,cAAc,IAAI,CAAC,KAAKrC,WAAW,CAACG,MAAM;MAE9D,KAAK,gBAAgB;QACnB,OAAO,CAACN,SAAS,CAACyC,aAAa,IAAI,CAAC,KAAKtC,WAAW,CAACG,MAAM;MAE7D,KAAK,gBAAgB;QACnB,OAAO,CAACN,SAAS,CAAC0C,YAAY,IAAI,CAAC,KAAKvC,WAAW,CAACG,MAAM;MAE5D,KAAK,kBAAkB;QACrB,MAAM2B,UAAU,GAAGjC,SAAS,CAACiC,UAAU,IAAI,CAAC;QAC5C,MAAMD,cAAc,GAAGhC,SAAS,CAACgC,cAAc,IAAI,CAAC;QACpD,OAAOC,UAAU,GAAG,CAAC,IAAKD,cAAc,GAAGC,UAAU,IAAK9B,WAAW,CAACwC,KAAK;;MAE7E;MACA,KAAK,aAAa;QAChB,OAAQ3C,SAAS,CAAC4C,UAAU,IAAI,KAAK;MAEvC,KAAK,cAAc;QACjB,OAAQ5C,SAAS,CAAC6C,WAAW,IAAI,KAAK;MAExC,KAAK,mBAAmB;QACtB,OAAO,CAAC7C,SAAS,CAAC8C,qBAAqB,IAAI,CAAC,KAAK3C,WAAW,CAACG,MAAM;MAErE,KAAK,sBAAsB;QACzB,OAAO,CAACN,SAAS,CAAC+C,aAAa,IAAI,CAAC,KAAK5C,WAAW,CAACG,MAAM;MAE7D,KAAK,kBAAkB;QACrB,OAAO,CAACN,SAAS,CAACgD,eAAe,IAAI,CAAC,KAAK7C,WAAW,CAACG,MAAM;MAE/D;QACEhB,OAAO,CAACE,IAAI,CAAC,6BAA6BW,WAAW,CAACC,IAAI,EAAE,CAAC;QAC7D,OAAO,KAAK;IAChB;EACF;;EAEA;EACAvB,8BAA8BA,CAACd,WAAW,EAAE;IAC1C,MAAMkF,IAAI,GAAGvG,QAAQ,CAACqB,WAAW,CAACkF,IAAI,CAAC;IAEvC3D,OAAO,CAACC,GAAG,CAAC,MAAM0D,IAAI,CAACC,KAAK,IAAInF,WAAW,CAACoF,IAAI,gBAAgBpF,WAAW,CAACqF,QAAQ,MAAM,CAAC;;IAE3F;IACAC,MAAM,CAACC,aAAa,CAAC,IAAIC,WAAW,CAAC,qBAAqB,EAAE;MAC1DC,MAAM,EAAE;QACNzF,WAAW;QACXkF,IAAI;QACJQ,SAAS,EAAE,IAAI/E,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;MACpC;IACF,CAAC,CAAC,CAAC;;IAEH;IACA,IAAI,CAAC+E,oBAAoB,CAAC3F,WAAW,CAACkF,IAAI,CAAC;EAC7C;;EAEA;EACAS,oBAAoBA,CAACT,IAAI,EAAE;IACzB,IAAI;MACF,MAAMU,KAAK,GAAG,IAAIC,KAAK,CAAC,uBAAuBX,IAAI,MAAM,CAAC;MAC1DU,KAAK,CAACE,MAAM,GAAG,GAAG;MAClBF,KAAK,CAACG,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,MAAM;QACvBzE,OAAO,CAACC,GAAG,CAAC,6BAA6B0D,IAAI,EAAE,CAAC;MAClD,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOxD,KAAK,EAAE;MACdH,OAAO,CAACG,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;IAC1D;EACF;;EAEA;EACAuE,sBAAsBA,CAAC9F,aAAa,EAAE8B,SAAS,EAAE;IAC/C,MAAMjC,WAAW,GAAGtB,eAAe,CAAC8B,IAAI,CAACH,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKH,aAAa,CAAC;IACrE,IAAI,CAACH,WAAW,IAAI,IAAI,CAACE,UAAU,CAACC,aAAa,CAAC,EAAE,OAAO,CAAC;IAE5D,MAAM+F,GAAG,GAAGlG,WAAW,CAACoC,WAAW;IACnC,IAAI+D,OAAO,GAAG,CAAC;IACf,IAAI5D,MAAM,GAAG2D,GAAG,CAAC3D,MAAM,IAAI,CAAC;IAE5B,QAAQ2D,GAAG,CAAC7D,IAAI;MACd,KAAK,YAAY;QACf8D,OAAO,GAAGlE,SAAS,CAACoB,UAAU,IAAI,CAAC;QACnC;MACF,KAAK,YAAY;QACf8C,OAAO,GAAGlE,SAAS,CAACqB,UAAU,IAAI,CAAC;QACnC;MACF,KAAK,YAAY;QACf6C,OAAO,GAAGlE,SAAS,CAACiC,UAAU,IAAI,CAAC;QACnC;MACF,KAAK,eAAe;QAClBiC,OAAO,GAAGlE,SAAS,CAACK,aAAa,IAAI,CAAC;QACtC;MACF,KAAK,YAAY;QACf6D,OAAO,GAAGlE,SAAS,CAACO,cAAc,IAAI,CAAC;QACvC;MACF,KAAK,aAAa;QAChB2D,OAAO,GAAGlE,SAAS,CAACsB,UAAU,IAAI,CAAC;QACnC;MACF,KAAK,QAAQ;MACb,KAAK,mBAAmB;MACxB,KAAK,cAAc;QACjB4C,OAAO,GAAGlE,SAAS,CAACiE,GAAG,CAAC7D,IAAI,KAAK,QAAQ,GAAG,YAAY,GACpC6D,GAAG,CAAC7D,IAAI,KAAK,mBAAmB,GAAG,YAAY,GAAG,aAAa,CAAC,IAAI,CAAC;QACzF;MACF;QACE,OAAO,CAAC;IACZ;IAEA,OAAO+D,IAAI,CAACC,GAAG,CAACF,OAAO,GAAG5D,MAAM,EAAE,CAAC,CAAC;EACtC;;EAEA;EACA+D,mBAAmBA,CAACrE,SAAS,EAAEsE,KAAK,GAAG,CAAC,EAAE;IACxC,OAAO7H,eAAe,CACnBmB,MAAM,CAACG,WAAW,IAAI,CAAC,IAAI,CAACE,UAAU,CAACF,WAAW,CAACM,EAAE,CAAC,CAAC,CACvDkG,GAAG,CAACxG,WAAW,KAAK;MACnB,GAAGA,WAAW;MACdyG,QAAQ,EAAE,IAAI,CAACR,sBAAsB,CAACjG,WAAW,CAACM,EAAE,EAAE2B,SAAS;IACjE,CAAC,CAAC,CAAC,CACFyE,IAAI,CAAC,CAACrG,CAAC,EAAEsG,CAAC,KAAKA,CAAC,CAACF,QAAQ,GAAGpG,CAAC,CAACoG,QAAQ,CAAC,CACvCG,KAAK,CAAC,CAAC,EAAEL,KAAK,CAAC;EACpB;;EAEA;EACAM,mBAAmBA,CAACC,IAAI,GAAG,CAAC,EAAE;IAC5B,MAAMC,UAAU,GAAG,IAAIpG,IAAI,CAAC,CAAC;IAC7BoG,UAAU,CAACC,OAAO,CAACD,UAAU,CAACE,OAAO,CAAC,CAAC,GAAGH,IAAI,CAAC;IAE/C,OAAO,IAAI,CAAChI,oBAAoB,CAC7Be,MAAM,CAACG,WAAW,IAAI,IAAIW,IAAI,CAACX,WAAW,CAACU,UAAU,CAAC,IAAIqG,UAAU,CAAC,CACrEL,IAAI,CAAC,CAACrG,CAAC,EAAEsG,CAAC,KAAK,IAAIhG,IAAI,CAACgG,CAAC,CAACjG,UAAU,CAAC,GAAG,IAAIC,IAAI,CAACN,CAAC,CAACK,UAAU,CAAC,CAAC;EACpE;;EAEA;EACAwG,QAAQA,CAAA,EAAG;IACT,MAAMC,KAAK,GAAGzI,eAAe,CAAC0I,MAAM;IACpC,MAAMC,QAAQ,GAAG,IAAI,CAACvI,oBAAoB,CAACsI,MAAM;IACjD,MAAME,MAAM,GAAG;MACbC,MAAM,EAAE,IAAI,CAACzI,oBAAoB,CAACe,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAAC6E,IAAI,KAAK,QAAQ,CAAC,CAACkC,MAAM;MACzEI,QAAQ,EAAE,IAAI,CAAC1I,oBAAoB,CAACe,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAAC6E,IAAI,KAAK,UAAU,CAAC,CAACkC,MAAM;MAC7EK,IAAI,EAAE,IAAI,CAAC3I,oBAAoB,CAACe,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAAC6E,IAAI,KAAK,MAAM,CAAC,CAACkC,MAAM;MACrEM,SAAS,EAAE,IAAI,CAAC5I,oBAAoB,CAACe,MAAM,CAACQ,CAAC,IAAIA,CAAC,CAAC6E,IAAI,KAAK,WAAW,CAAC,CAACkC;IAC3E,CAAC;IAED,MAAMO,OAAO,GAAG,IAAI,CAAC7I,oBAAoB,CAACmE,MAAM,CAAC,CAACC,GAAG,EAAElD,WAAW,KAAKkD,GAAG,GAAGlD,WAAW,CAACqF,QAAQ,EAAE,CAAC,CAAC;IAErG,OAAO;MACL8B,KAAK;MACLE,QAAQ;MACRO,UAAU,EAAExB,IAAI,CAACyB,KAAK,CAAER,QAAQ,GAAGF,KAAK,GAAI,GAAG,CAAC;MAChDG,MAAM;MACNK,OAAO;MACPG,aAAa,EAAE,IAAI,CAACjB,mBAAmB,CAAC,CAAC,CAAC,CAACO;IAC7C,CAAC;EACH;;EAEA;EACAW,WAAWA,CAAC5H,aAAa,EAAE;IACzBoB,OAAO,CAACC,GAAG,CAAC,oBAAoBrB,aAAa,EAAE,CAAC;;IAEhD;IACA,MAAM6H,eAAe,GAAG5I,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,sBAAsB,CAAC,IAAI,IAAI,CAAC,CACrFU,MAAM,CAACS,EAAE,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK2H,SAAS,CAAC;IAEhD,IAAI,CAACD,eAAe,CAACpG,QAAQ,CAACzB,aAAa,CAAC,EAAE;MAC5C,MAAM0B,WAAW,GAAG,CAAC,GAAGmG,eAAe,EAAE7H,aAAa,CAAC;MACvDjB,YAAY,CAACK,OAAO,CAAC,sBAAsB,EAAEH,IAAI,CAACI,SAAS,CAACqC,WAAW,CAAC,CAAC;;MAEzE;MACA,MAAMC,eAAe,GAAG1C,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC,IAAI,IAAI,CAAC;MACnF2C,eAAe,CAAC3B,aAAa,CAAC,GAAG;QAC/BO,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACpC6F,QAAQ,EAAE;MACZ,CAAC;MACDvH,YAAY,CAACK,OAAO,CAAC,iBAAiB,EAAEH,IAAI,CAACI,SAAS,CAACsC,eAAe,CAAC,CAAC;MAExEP,OAAO,CAACC,GAAG,CAAC,qBAAqBrB,aAAa,EAAE,CAAC;;MAEjD;MACA,IAAI,CAACU,0BAA0B,CAACV,aAAa,CAAC;;MAE9C;MACAmF,MAAM,CAACC,aAAa,CAAC,IAAIC,WAAW,CAAC,qBAAqB,CAAC,CAAC;IAC9D,CAAC,MAAM;MACLjE,OAAO,CAACC,GAAG,CAAC,MAAMrB,aAAa,mBAAmB,CAAC;IACrD;EACF;;EAEA;EACA+H,iBAAiBA,CAAA,EAAG;IAClB3G,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;IAClDtC,YAAY,CAACiJ,UAAU,CAAC,sBAAsB,CAAC;IAC/CjJ,YAAY,CAACiJ,UAAU,CAAC,iBAAiB,CAAC;IAC1C7C,MAAM,CAACC,aAAa,CAAC,IAAIC,WAAW,CAAC,qBAAqB,CAAC,CAAC;EAC9D;;EAEA;EACA4C,mBAAmBA,CAAA,EAAG;IACpB,MAAMC,WAAW,GAAGjJ,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,sBAAsB,CAAC,IAAI,IAAI,CAAC,CACjFU,MAAM,CAACS,EAAE,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK2H,SAAS,CAAC;IAEhD/I,YAAY,CAACK,OAAO,CAAC,sBAAsB,EAAEH,IAAI,CAACI,SAAS,CAAC6I,WAAW,CAAC,CAAC;IACzE9G,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;EAChE;;EAEA;EACA8G,4BAA4BA,CAACtI,WAAW,EAAE;IACxC,MAAM8B,eAAe,GAAG1C,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC,IAAI,IAAI,CAAC;IACnF,MAAM4C,WAAW,GAAGD,eAAe,CAACC,WAAW,IAAI,CAAC,CAAC;IAErD,OAAO;MACL,GAAG/B,WAAW;MACdU,UAAU,EAAEqB,WAAW,CAAC/B,WAAW,CAACM,EAAE,CAAC,IAAI;IAC7C,CAAC;EACH;;EAEA;EACAqB,uBAAuBA,CAAA,EAAG;IACxB,MAAM0G,WAAW,GAAGjJ,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,sBAAsB,CAAC,IAAI,IAAI,CAAC,CACjFU,MAAM,CAACS,EAAE,IAAIA,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK2H,SAAS,CAAC;IAEhD,OAAOI,WAAW,CAAC7B,GAAG,CAAClG,EAAE,IAAI;MAC3B,MAAMN,WAAW,GAAGtB,eAAe,CAAC8B,IAAI,CAACH,CAAC,IAAIA,CAAC,CAACC,EAAE,KAAKA,EAAE,CAAC;MAC1D,IAAI,CAACN,WAAW,EAAE;QAChBuB,OAAO,CAACE,IAAI,CAAC,0BAA0BnB,EAAE,YAAY,CAAC;QACtD,OAAO,IAAI;MACb;MAEA,MAAMwB,eAAe,GAAG1C,IAAI,CAACC,KAAK,CAACH,YAAY,CAACC,OAAO,CAAC,iBAAiB,CAAC,IAAI,IAAI,CAAC;MACnF,MAAMoJ,IAAI,GAAGzG,eAAe,CAACxB,EAAE,CAAC,IAAI,CAAC,CAAC;MAEtC,OAAO;QACL,GAAGN,WAAW;QACdU,UAAU,EAAE6H,IAAI,CAAC7H,UAAU,IAAI,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;QACvD6F,QAAQ,EAAE8B,IAAI,CAAC9B,QAAQ,IAAI;MAC7B,CAAC;IACH,CAAC,CAAC,CAAC5G,MAAM,CAAC2I,OAAO,CAAC;EACpB;;EAEA;EACA,MAAMC,uBAAuBA,CAACxG,SAAS,EAAE;IACvCV,OAAO,CAACC,GAAG,CAAC,uDAAuD,EAAES,SAAS,CAAC;IAE/E,MAAMyG,kBAAkB,GAAG,IAAI,CAAC/G,uBAAuB,CAAC,CAAC,CAAC6E,GAAG,CAACnG,CAAC,IAAIA,CAAC,CAACC,EAAE,CAAC;IACxE,MAAM4B,aAAa,GAAG,EAAE;;IAExB;IACAxD,eAAe,CAACuB,OAAO,CAACD,WAAW,IAAI;MACrC,IAAI,CAAC0I,kBAAkB,CAAC9G,QAAQ,CAAC5B,WAAW,CAACM,EAAE,CAAC,EAAE;QAChD,IAAI,IAAI,CAAC6B,gBAAgB,CAACnC,WAAW,CAACoC,WAAW,EAAEH,SAAS,CAAC,EAAE;UAC7DV,OAAO,CAACC,GAAG,CAAC,qBAAqBxB,WAAW,CAACM,EAAE,MAAMN,WAAW,CAACoF,IAAI,EAAE,CAAC;UACxE,IAAI,IAAI,CAAC7E,iBAAiB,CAACP,WAAW,CAACM,EAAE,CAAC,EAAE;YAC1C4B,aAAa,CAACvC,IAAI,CAACK,WAAW,CAAC;UACjC;QACF,CAAC,MAAM;UACL;UACA,MAAMyG,QAAQ,GAAG,IAAI,CAACR,sBAAsB,CAACjG,WAAW,CAACM,EAAE,EAAE2B,SAAS,CAAC;UACvE,IAAIwE,QAAQ,GAAG,GAAG,EAAE;YAClBlF,OAAO,CAACC,GAAG,CAAC,0BAA0BxB,WAAW,CAACM,EAAE,MAAM8F,IAAI,CAACyB,KAAK,CAACpB,QAAQ,GAAG,GAAG,CAAC,GAAG,CAAC;UAC1F;QACF;MACF;IACF,CAAC,CAAC;IAEFlF,OAAO,CAACC,GAAG,CAAC,sCAAsCU,aAAa,CAACkF,MAAM,oBAAoB,EACxFlF,aAAa,CAACsE,GAAG,CAACnG,CAAC,IAAIA,CAAC,CAAC+E,IAAI,CAAC,CAAC;IAEjC,OAAOlD,aAAa;EACtB;;EAEA;EACA,MAAMyG,mBAAmBA,CAAA,EAAG;IAC1BpH,OAAO,CAACC,GAAG,CAAC,6CAA6C,CAAC;;IAE1D;IACA,MAAMoH,gBAAgB,GAAG,CAAC,OAAO,EAAE,WAAW,EAAE,YAAY,EAAE,gBAAgB,CAAC;IAC/E,MAAMC,gBAAgB,GAAG,CAAC,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,UAAU,CAAC;IACxE,MAAMC,iBAAiB,GAAG,CAAC,eAAe,EAAE,eAAe,EAAE,kBAAkB,CAAC;IAEhF,IAAIC,KAAK,GAAG,EAAE;IACd,IAAIC,KAAK,GAAG,EAAE;IACd,IAAIC,aAAa,GAAG,EAAE;;IAEtB;IACA,KAAK,MAAMC,GAAG,IAAIN,gBAAgB,EAAE;MAClC,MAAML,IAAI,GAAGrJ,YAAY,CAACC,OAAO,CAAC+J,GAAG,CAAC;MACtC,IAAIX,IAAI,EAAE;QACR,IAAI;UACF,MAAMY,MAAM,GAAG/J,IAAI,CAACC,KAAK,CAACkJ,IAAI,CAAC;UAC/B,IAAIa,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,IAAIA,MAAM,CAAC/B,MAAM,GAAG,CAAC,EAAE;YAC9C2B,KAAK,GAAGI,MAAM;YACd5H,OAAO,CAACC,GAAG,CAAC,2BAA2B0H,GAAG,MAAMH,KAAK,CAAC3B,MAAM,QAAQ,CAAC;YACrE;UACF;QACF,CAAC,CAAC,OAAOkC,CAAC,EAAE;UACV/H,OAAO,CAACE,IAAI,CAAC,mBAAmByH,GAAG,GAAG,EAAEI,CAAC,CAAC;QAC5C;MACF;IACF;;IAEA;IACA,KAAK,MAAMJ,GAAG,IAAIL,gBAAgB,EAAE;MAClC,MAAMN,IAAI,GAAGrJ,YAAY,CAACC,OAAO,CAAC+J,GAAG,CAAC;MACtC,IAAIX,IAAI,EAAE;QACR,IAAI;UACF,MAAMY,MAAM,GAAG/J,IAAI,CAACC,KAAK,CAACkJ,IAAI,CAAC;UAC/B,IAAIa,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,IAAIA,MAAM,CAAC/B,MAAM,GAAG,CAAC,EAAE;YAC9C4B,KAAK,GAAGG,MAAM;YACd5H,OAAO,CAACC,GAAG,CAAC,0BAA0B0H,GAAG,MAAMF,KAAK,CAAC5B,MAAM,QAAQ,CAAC;YACpE;UACF;QACF,CAAC,CAAC,OAAOkC,CAAC,EAAE;UACV/H,OAAO,CAACE,IAAI,CAAC,mBAAmByH,GAAG,GAAG,EAAEI,CAAC,CAAC;QAC5C;MACF;IACF;;IAEA;IACA,KAAK,MAAMJ,GAAG,IAAIJ,iBAAiB,EAAE;MACnC,MAAMP,IAAI,GAAGrJ,YAAY,CAACC,OAAO,CAAC+J,GAAG,CAAC;MACtC,IAAIX,IAAI,EAAE;QACR,IAAI;UACF,MAAMY,MAAM,GAAG/J,IAAI,CAACC,KAAK,CAACkJ,IAAI,CAAC;UAC/B,IAAIa,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,IAAIA,MAAM,CAAC/B,MAAM,GAAG,CAAC,EAAE;YAC9C6B,aAAa,GAAGE,MAAM;YACtB5H,OAAO,CAACC,GAAG,CAAC,oCAAoC0H,GAAG,MAAMD,aAAa,CAAC7B,MAAM,WAAW,CAAC;YACzF;UACF;QACF,CAAC,CAAC,OAAOkC,CAAC,EAAE;UACV/H,OAAO,CAACE,IAAI,CAAC,mBAAmByH,GAAG,GAAG,EAAEI,CAAC,CAAC;QAC5C;MACF;IACF;;IAEA;IACA,MAAMC,KAAK,GAAG;MACZ;MACAlG,UAAU,EAAE0F,KAAK,CAAC3B,MAAM;MACxB9D,UAAU,EAAE,IAAI,CAACkG,mBAAmB,CAACT,KAAK,CAAC;MAC3CxF,UAAU,EAAE,IAAI,CAACkG,mBAAmB,CAACV,KAAK,CAAC;MAC3CW,UAAU,EAAE,IAAI,CAACC,mBAAmB,CAACZ,KAAK,CAAC;MAC3ChF,UAAU,EAAE,IAAI,CAAC6F,mBAAmB,CAACb,KAAK,CAAC;MAC3CpF,cAAc,EAAE,IAAI,CAACkG,iBAAiB,CAACd,KAAK,CAAC;MAC7CnF,aAAa,EAAE,IAAI,CAACkG,gBAAgB,CAACf,KAAK,CAAC;MAC3CtF,YAAY,EAAE,IAAI,CAACsG,uBAAuB,CAAChB,KAAK,CAAC;MACjDvF,UAAU,EAAE,IAAI,CAACwG,mBAAmB,CAACjB,KAAK,CAAC;MAC3CjF,aAAa,EAAE,IAAI,CAACmG,sBAAsB,CAAClB,KAAK,CAAC;MACjDlF,YAAY,EAAE,IAAI,CAACqG,qBAAqB,CAACnB,KAAK,CAAC;MAE/C;MACA7E,UAAU,EAAE8E,KAAK,CAAC5B,MAAM;MACxBnD,cAAc,EAAE,IAAI,CAACkG,uBAAuB,CAACnB,KAAK,CAAC;MACnD7E,UAAU,EAAE,IAAI,CAACiG,mBAAmB,CAACpB,KAAK,CAAC;MAC3CxE,UAAU,EAAE,IAAI,CAAC6F,mBAAmB,CAACrB,KAAK,CAAC;MAC3C1E,iBAAiB,EAAE,IAAI,CAACgG,0BAA0B,CAACtB,KAAK,CAAC;MACzDzE,gBAAgB,EAAE,IAAI,CAACgG,yBAAyB,CAACvB,KAAK,CAAC;MACvD5E,aAAa,EAAE,IAAI,CAACoG,sBAAsB,CAACxB,KAAK,CAAC;MACjD3E,cAAc,EAAE,IAAI,CAACoG,uBAAuB,CAACzB,KAAK,CAAC;MACnDvE,cAAc,EAAE,IAAI,CAACiG,uBAAuB,CAAC1B,KAAK,CAAC;MACnDtE,aAAa,EAAE,IAAI,CAACiG,sBAAsB,CAAC3B,KAAK,CAAC;MACjDrE,YAAY,EAAE,IAAI,CAACiG,qBAAqB,CAAC5B,KAAK,CAAC;MAE/C;MACA1G,aAAa,EAAE2G,aAAa,CAAC7B,MAAM;MACnC5E,cAAc,EAAE,IAAI,CAACqI,uBAAuB,CAAC5B,aAAa,CAAC;MAC3DxG,iBAAiB,EAAE,IAAI,CAACqI,0BAA0B,CAAC7B,aAAa,CAAC;MACjEvG,kBAAkB,EAAE,IAAI,CAACqI,2BAA2B,CAAC9B,aAAa,CAAC;MACnE+B,WAAW,EAAE,IAAI,CAACC,oBAAoB,CAAChC,aAAa,CAAC;MACrDiC,oBAAoB,EAAE,IAAI,CAACC,6BAA6B,CAAClC,aAAa,CAAC;MACvEtG,YAAY,EAAE,IAAI,CAACyI,qBAAqB,CAACnC,aAAa,CAAC;MACvDoC,gBAAgB,EAAE,IAAI,CAACC,yBAAyB,CAACrC,aAAa,CAAC;MAC/D7F,gBAAgB,EAAE,IAAI,CAACmI,yBAAyB,CAACtC,aAAa,CAAC;MAE/D;MACAuC,UAAU,EAAE,IAAI,CAACC,mBAAmB,CAAC1C,KAAK,EAAEC,KAAK,EAAEC,aAAa,CAAC;MACjEjE,aAAa,EAAE,IAAI,CAAC0G,sBAAsB,CAAC3C,KAAK,EAAEC,KAAK,EAAEC,aAAa;IACxE,CAAC;IAED1H,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAE+H,KAAK,CAAC;IAC1C,OAAOA,KAAK;EACd;;EAEA;EACAC,mBAAmBA,CAACT,KAAK,EAAE;IACzB,OAAOA,KAAK,CAAC9F,MAAM,CAAC,CAACkE,KAAK,EAAEwE,IAAI,KAAK;MACnC,MAAMC,OAAO,GAAGD,IAAI,CAACC,OAAO,IAAID,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACvK,IAAI,IAAI,EAAE;MAC5D,MAAM0K,KAAK,GAAGF,OAAO,CAACG,KAAK,CAAC,KAAK,CAAC,CAAClM,MAAM,CAACmM,IAAI,IAAIA,IAAI,CAAC5E,MAAM,GAAG,CAAC,CAAC;MAClE,OAAOD,KAAK,GAAG2E,KAAK,CAAC1E,MAAM;IAC7B,CAAC,EAAE,CAAC,CAAC;EACP;EAEAqC,mBAAmBA,CAACV,KAAK,EAAE;IACzB,MAAMkD,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;IACzBnD,KAAK,CAAC9I,OAAO,CAAC0L,IAAI,IAAI;MACpB,MAAMQ,IAAI,GAAGR,IAAI,CAACQ,IAAI,IAAIR,IAAI,CAACS,UAAU,IAAI,EAAE;MAC/C,IAAIhD,KAAK,CAACC,OAAO,CAAC8C,IAAI,CAAC,EAAE;QACvBA,IAAI,CAAClM,OAAO,CAACoM,GAAG,IAAIJ,OAAO,CAACK,GAAG,CAACD,GAAG,CAAC,CAAC;MACvC;IACF,CAAC,CAAC;IACF,OAAOJ,OAAO,CAACM,IAAI;EACrB;EAEA5C,mBAAmBA,CAACZ,KAAK,EAAE;IACzB,MAAMyD,KAAK,GAAG,IAAI7L,IAAI,CAAC,CAAC,CAAC8L,YAAY,CAAC,CAAC;IACvC,OAAO1D,KAAK,CAAClJ,MAAM,CAAC8L,IAAI,IAAI;MAC1B,MAAMe,IAAI,GAAGf,IAAI,CAACgB,SAAS,IAAIhB,IAAI,CAACiB,OAAO,IAAIjB,IAAI,CAACe,IAAI;MACxD,OAAOA,IAAI,IAAI,IAAI/L,IAAI,CAAC+L,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC,KAAKD,KAAK;IACxD,CAAC,CAAC,CAACpF,MAAM;EACX;EAEAwC,mBAAmBA,CAACb,KAAK,EAAE;IACzB,IAAIA,KAAK,CAAC3B,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC;IAEhC,MAAMyF,WAAW,GAAG,CAAC,CAAC;IACtB9D,KAAK,CAAC9I,OAAO,CAAC0L,IAAI,IAAI;MACpB,MAAMe,IAAI,GAAGf,IAAI,CAACgB,SAAS,IAAIhB,IAAI,CAACiB,OAAO,IAAIjB,IAAI,CAACe,IAAI;MACxD,IAAIA,IAAI,EAAE;QACR,MAAMI,OAAO,GAAG,IAAInM,IAAI,CAAC+L,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC;QAC7CI,WAAW,CAACC,OAAO,CAAC,GAAG,IAAI;MAC7B;IACF,CAAC,CAAC;IAEF,MAAMC,WAAW,GAAGhK,MAAM,CAACiK,IAAI,CAACH,WAAW,CAAC,CAACnG,IAAI,CAAC,CAACrG,CAAC,EAAEsG,CAAC,KAAK,IAAIhG,IAAI,CAACgG,CAAC,CAAC,GAAG,IAAIhG,IAAI,CAACN,CAAC,CAAC,CAAC;IACtF,IAAI4M,MAAM,GAAG,CAAC;IACd,IAAIC,WAAW,GAAG,IAAIvM,IAAI,CAAC,CAAC;IAE5B,KAAK,IAAIwM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAAC3F,MAAM,EAAE+F,CAAC,EAAE,EAAE;MAC3C,MAAMC,QAAQ,GAAG,IAAIzM,IAAI,CAACoM,WAAW,CAACI,CAAC,CAAC,CAAC;MACzC,MAAME,QAAQ,GAAGjH,IAAI,CAACkH,KAAK,CAAC,CAACJ,WAAW,GAAGE,QAAQ,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;MAE7E,IAAIC,QAAQ,KAAKF,CAAC,EAAE;QAClBF,MAAM,EAAE;MACV,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOA,MAAM;EACf;EAEApD,iBAAiBA,CAACd,KAAK,EAAE;IACvB,OAAO3C,IAAI,CAACmH,GAAG,CAAC,GAAGxE,KAAK,CAACvC,GAAG,CAACmF,IAAI,IAAI;MACnC,MAAMC,OAAO,GAAGD,IAAI,CAACC,OAAO,IAAID,IAAI,CAACE,IAAI,IAAIF,IAAI,CAACvK,IAAI,IAAI,EAAE;MAC5D,OAAOwK,OAAO,CAACG,KAAK,CAAC,KAAK,CAAC,CAAClM,MAAM,CAACmM,IAAI,IAAIA,IAAI,CAAC5E,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM;IACpE,CAAC,CAAC,EAAE,CAAC,CAAC;EACR;EAEA0C,gBAAgBA,CAACf,KAAK,EAAE;IACtB,OAAO3C,IAAI,CAACmH,GAAG,CAAC,GAAGxE,KAAK,CAACvC,GAAG,CAACmF,IAAI,IAAI;MACnC,MAAMQ,IAAI,GAAGR,IAAI,CAACQ,IAAI,IAAIR,IAAI,CAACS,UAAU,IAAI,EAAE;MAC/C,OAAOhD,KAAK,CAACC,OAAO,CAAC8C,IAAI,CAAC,GAAGA,IAAI,CAAC/E,MAAM,GAAG,CAAC;IAC9C,CAAC,CAAC,EAAE,CAAC,CAAC;EACR;EAEA2C,uBAAuBA,CAAChB,KAAK,EAAE;IAC7B,OAAO3C,IAAI,CAACmH,GAAG,CAAC,GAAGxE,KAAK,CAACvC,GAAG,CAACmF,IAAI,IAAI;MACnC,OAAOA,IAAI,CAAC6B,SAAS,IAAI7B,IAAI,CAAC8B,KAAK,IAAI,CAAC;IAC1C,CAAC,CAAC,EAAE,CAAC,CAAC;EACR;EAEAzD,mBAAmBA,CAACjB,KAAK,EAAE;IACzB,OAAOA,KAAK,CAAC9F,MAAM,CAAC,CAACkE,KAAK,EAAEwE,IAAI,KAAK;MACnC,OAAOxE,KAAK,IAAIwE,IAAI,CAAC6B,SAAS,IAAI7B,IAAI,CAAC8B,KAAK,IAAI,CAAC,CAAC;IACpD,CAAC,EAAE,CAAC,CAAC;EACP;EAEAxD,sBAAsBA,CAAClB,KAAK,EAAE;IAC5B,MAAM2E,UAAU,GAAG,IAAI/M,IAAI,CAAC,CAAC;IAC7B+M,UAAU,CAAC1G,OAAO,CAAC0G,UAAU,CAACzG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;IAE5C,OAAO8B,KAAK,CAAClJ,MAAM,CAAC8L,IAAI,IAAI;MAC1B,MAAMe,IAAI,GAAGf,IAAI,CAACgB,SAAS,IAAIhB,IAAI,CAACiB,OAAO,IAAIjB,IAAI,CAACe,IAAI;MACxD,OAAOA,IAAI,IAAI,IAAI/L,IAAI,CAAC+L,IAAI,CAAC,IAAIgB,UAAU;IAC7C,CAAC,CAAC,CAACtG,MAAM;EACX;EAEA8C,qBAAqBA,CAACnB,KAAK,EAAE;IAC3B,OAAOA,KAAK,CAAClJ,MAAM,CAAC8L,IAAI,IAAI;MAC1B,MAAMe,IAAI,GAAGf,IAAI,CAACgB,SAAS,IAAIhB,IAAI,CAACiB,OAAO,IAAIjB,IAAI,CAACe,IAAI;MACxD,OAAOA,IAAI,IAAI,IAAI/L,IAAI,CAAC+L,IAAI,CAAC,CAACiB,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IAChD,CAAC,CAAC,CAACvG,MAAM;EACX;EAEA+C,uBAAuBA,CAACnB,KAAK,EAAE;IAC7B,OAAOA,KAAK,CAACnJ,MAAM,CAAC+N,IAAI,IACtBA,IAAI,CAACC,SAAS,IACdD,IAAI,CAACE,MAAM,KAAK,WAAW,IAC3BF,IAAI,CAACE,MAAM,KAAK,MAAM,IACtBF,IAAI,CAACG,MACP,CAAC,CAAC3G,MAAM;EACV;EAEAgD,mBAAmBA,CAACpB,KAAK,EAAE;IACzB,MAAMwD,KAAK,GAAG,IAAI7L,IAAI,CAAC,CAAC,CAAC8L,YAAY,CAAC,CAAC;IACvC,OAAOzD,KAAK,CAACnJ,MAAM,CAAC+N,IAAI,IAAI;MAC1B,MAAMI,aAAa,GAAGJ,IAAI,CAACK,WAAW,IAAIL,IAAI,CAACM,YAAY,IAAIN,IAAI,CAACO,MAAM;MAC1E,MAAMC,WAAW,GAAGR,IAAI,CAACjB,SAAS,IAAIiB,IAAI,CAAChB,OAAO,IAAIgB,IAAI,CAAClB,IAAI;MAE/D,OAAQsB,aAAa,IAAI,IAAIrN,IAAI,CAACqN,aAAa,CAAC,CAACvB,YAAY,CAAC,CAAC,KAAKD,KAAK,IACjE4B,WAAW,IAAI,IAAIzN,IAAI,CAACyN,WAAW,CAAC,CAAC3B,YAAY,CAAC,CAAC,KAAKD,KAAM;IACxE,CAAC,CAAC,CAACpF,MAAM;EACX;EAEAiD,mBAAmBA,CAACrB,KAAK,EAAE;IACzB;IACA,MAAM/E,cAAc,GAAG+E,KAAK,CAACnJ,MAAM,CAAC+N,IAAI,IACtCA,IAAI,CAACC,SAAS,IAAID,IAAI,CAACE,MAAM,KAAK,WACpC,CAAC;IAED,MAAMO,WAAW,GAAG,CAAC,CAAC;IACtBpK,cAAc,CAAChE,OAAO,CAAC2N,IAAI,IAAI;MAC7B,MAAMlB,IAAI,GAAGkB,IAAI,CAACK,WAAW,IAAIL,IAAI,CAACM,YAAY,IAAIN,IAAI,CAACO,MAAM;MACjE,IAAIzB,IAAI,EAAE;QACR,MAAMI,OAAO,GAAG,IAAInM,IAAI,CAAC+L,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC;QAC7C4B,WAAW,CAACvB,OAAO,CAAC,GAAG,IAAI;MAC7B;IACF,CAAC,CAAC;IAEF,MAAMC,WAAW,GAAGhK,MAAM,CAACiK,IAAI,CAACqB,WAAW,CAAC,CAAC3H,IAAI,CAAC,CAACrG,CAAC,EAAEsG,CAAC,KAAK,IAAIhG,IAAI,CAACgG,CAAC,CAAC,GAAG,IAAIhG,IAAI,CAACN,CAAC,CAAC,CAAC;IACtF,IAAI4M,MAAM,GAAG,CAAC;IACd,IAAIC,WAAW,GAAG,IAAIvM,IAAI,CAAC,CAAC;IAE5B,KAAK,IAAIwM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAAC3F,MAAM,EAAE+F,CAAC,EAAE,EAAE;MAC3C,MAAMmB,QAAQ,GAAG,IAAI3N,IAAI,CAACoM,WAAW,CAACI,CAAC,CAAC,CAAC;MACzC,MAAME,QAAQ,GAAGjH,IAAI,CAACkH,KAAK,CAAC,CAACJ,WAAW,GAAGoB,QAAQ,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;MAE7E,IAAIjB,QAAQ,KAAKF,CAAC,EAAE;QAClBF,MAAM,EAAE;MACV,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOA,MAAM;EACf;EAEA3C,0BAA0BA,CAACtB,KAAK,EAAE;IAChC,OAAOA,KAAK,CAACnJ,MAAM,CAAC+N,IAAI,IAAI;MAC1B,MAAMW,QAAQ,GAAGX,IAAI,CAACW,QAAQ,IAAIX,IAAI,CAACY,UAAU;MACjD,MAAMC,WAAW,GAAGb,IAAI,CAACC,SAAS,IAAID,IAAI,CAACE,MAAM,KAAK,WAAW;MACjE,OAAOW,WAAW,KAAKF,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,CAAC,CAAC;IACxF,CAAC,CAAC,CAACnH,MAAM;EACX;EAEAmD,yBAAyBA,CAACvB,KAAK,EAAE;IAC/B,OAAOA,KAAK,CAACnJ,MAAM,CAAC+N,IAAI,IAAI;MAC1B,MAAMK,WAAW,GAAGL,IAAI,CAACK,WAAW,IAAIL,IAAI,CAACM,YAAY;MACzD,MAAMQ,OAAO,GAAGd,IAAI,CAACc,OAAO,IAAId,IAAI,CAACe,GAAG,IAAIf,IAAI,CAACgB,QAAQ;MACzD,MAAMH,WAAW,GAAGb,IAAI,CAACC,SAAS,IAAID,IAAI,CAACE,MAAM,KAAK,WAAW;MAEjE,OAAOW,WAAW,IAAIR,WAAW,IAAIS,OAAO,IACrC,IAAI/N,IAAI,CAACsN,WAAW,CAAC,GAAG,IAAItN,IAAI,CAAC+N,OAAO,CAAC;IAClD,CAAC,CAAC,CAACtH,MAAM;EACX;EAEAoD,sBAAsBA,CAACxB,KAAK,EAAE;IAC5B,MAAM0E,UAAU,GAAG,IAAI/M,IAAI,CAAC,CAAC;IAC7B+M,UAAU,CAAC1G,OAAO,CAAC0G,UAAU,CAACzG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;IAE5C,OAAO+B,KAAK,CAACnJ,MAAM,CAAC+N,IAAI,IAAI;MAC1B,MAAMlB,IAAI,GAAGkB,IAAI,CAACK,WAAW,IAAIL,IAAI,CAACjB,SAAS,IAAIiB,IAAI,CAAChB,OAAO;MAC/D,OAAOF,IAAI,IAAI,IAAI/L,IAAI,CAAC+L,IAAI,CAAC,IAAIgB,UAAU;IAC7C,CAAC,CAAC,CAACtG,MAAM;EACX;EAEAqD,uBAAuBA,CAACzB,KAAK,EAAE;IAC7B,MAAM6F,WAAW,GAAG,IAAIlO,IAAI,CAAC,CAAC;IAC9BkO,WAAW,CAACC,QAAQ,CAACD,WAAW,CAACE,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;IAEhD,OAAO/F,KAAK,CAACnJ,MAAM,CAAC+N,IAAI,IAAI;MAC1B,MAAMlB,IAAI,GAAGkB,IAAI,CAACK,WAAW,IAAIL,IAAI,CAACjB,SAAS,IAAIiB,IAAI,CAAChB,OAAO;MAC/D,OAAOF,IAAI,IAAI,IAAI/L,IAAI,CAAC+L,IAAI,CAAC,IAAImC,WAAW;IAC9C,CAAC,CAAC,CAACzH,MAAM;EACX;EAEAsD,uBAAuBA,CAAC1B,KAAK,EAAE;IAC7B,MAAMoD,UAAU,GAAG,IAAIF,GAAG,CAAC,CAAC;IAC5BlD,KAAK,CAAC/I,OAAO,CAAC2N,IAAI,IAAI;MACpB,MAAMhL,QAAQ,GAAGgL,IAAI,CAAChL,QAAQ,IAAIgL,IAAI,CAACoB,YAAY,IAAI,eAAe;MACtE,IAAIpM,QAAQ,EAAE;QACZwJ,UAAU,CAACE,GAAG,CAAC1J,QAAQ,CAAC;MAC1B;IACF,CAAC,CAAC;IACF,OAAOwJ,UAAU,CAACG,IAAI;EACxB;EAEA5B,sBAAsBA,CAAC3B,KAAK,EAAE;IAC5B,MAAMiG,UAAU,GAAG,IAAI/C,GAAG,CAAC,CAAC;IAC5BlD,KAAK,CAAC/I,OAAO,CAAC2N,IAAI,IAAI;MACpB,MAAMW,QAAQ,GAAGX,IAAI,CAACW,QAAQ,IAAIX,IAAI,CAACY,UAAU;MACjD,IAAID,QAAQ,EAAE;QACZU,UAAU,CAAC3C,GAAG,CAACiC,QAAQ,CAAC;MAC1B;IACF,CAAC,CAAC;IACF,OAAOU,UAAU,CAAC1C,IAAI;EACxB;EAEA3B,qBAAqBA,CAAC5B,KAAK,EAAE;IAC3B,OAAOA,KAAK,CAACnJ,MAAM,CAAC+N,IAAI,IAAIA,IAAI,CAACc,OAAO,IAAId,IAAI,CAACe,GAAG,IAAIf,IAAI,CAACgB,QAAQ,CAAC,CAACxH,MAAM;EAC/E;EAEAyD,uBAAuBA,CAACqE,QAAQ,EAAE;IAChC,OAAOA,QAAQ,CAACjM,MAAM,CAAC,CAACkE,KAAK,EAAEgI,OAAO,KAAK;MACzC,OAAOhI,KAAK,IAAIgI,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAChM,IAAI,IAAI,CAAC,CAAC;IAC7E,CAAC,EAAE,CAAC,CAAC;EACP;EAEA4H,2BAA2BA,CAACmE,QAAQ,EAAE;IACpC,OAAO9I,IAAI,CAACmH,GAAG,CAAC,GAAG2B,QAAQ,CAAC1I,GAAG,CAAC2I,OAAO,IACrCA,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAChM,IAAI,IAAI,CAC3D,CAAC,EAAE,CAAC,CAAC;EACP;EAEA8H,oBAAoBA,CAACiE,QAAQ,EAAE;IAC7B,IAAIA,QAAQ,CAAC9H,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC;IAEnC,MAAMkI,cAAc,GAAG,CAAC,CAAC;IACzBJ,QAAQ,CAACjP,OAAO,CAACkP,OAAO,IAAI;MAC1B,MAAMzC,IAAI,GAAGyC,OAAO,CAACxC,SAAS,IAAIwC,OAAO,CAACzC,IAAI,IAAIyC,OAAO,CAACzJ,SAAS;MACnE,IAAIgH,IAAI,EAAE;QACR,MAAMI,OAAO,GAAG,IAAInM,IAAI,CAAC+L,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC;QAC7C6C,cAAc,CAACxC,OAAO,CAAC,GAAG,IAAI;MAChC;IACF,CAAC,CAAC;IAEF,MAAMC,WAAW,GAAGhK,MAAM,CAACiK,IAAI,CAACsC,cAAc,CAAC,CAAC5I,IAAI,CAAC,CAACrG,CAAC,EAAEsG,CAAC,KAAK,IAAIhG,IAAI,CAACgG,CAAC,CAAC,GAAG,IAAIhG,IAAI,CAACN,CAAC,CAAC,CAAC;IACzF,IAAI4M,MAAM,GAAG,CAAC;IACd,IAAIC,WAAW,GAAG,IAAIvM,IAAI,CAAC,CAAC;IAE5B,KAAK,IAAIwM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAAC3F,MAAM,EAAE+F,CAAC,EAAE,EAAE;MAC3C,MAAMoC,WAAW,GAAG,IAAI5O,IAAI,CAACoM,WAAW,CAACI,CAAC,CAAC,CAAC;MAC5C,MAAME,QAAQ,GAAGjH,IAAI,CAACkH,KAAK,CAAC,CAACJ,WAAW,GAAGqC,WAAW,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;MAEhF,IAAIlC,QAAQ,KAAKF,CAAC,EAAE;QAClBF,MAAM,EAAE;MACV,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOA,MAAM;EACf;EAEA9B,6BAA6BA,CAAC+D,QAAQ,EAAE;IACtC,IAAIA,QAAQ,CAAC9H,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC;IACnC,MAAMoI,SAAS,GAAG,IAAI,CAAC3E,uBAAuB,CAACqE,QAAQ,CAAC;IACxD,OAAO9I,IAAI,CAACyB,KAAK,CAAC2H,SAAS,GAAGN,QAAQ,CAAC9H,MAAM,CAAC;EAChD;EAEA0D,0BAA0BA,CAACoE,QAAQ,EAAE;IACnC,OAAOA,QAAQ,CAACjM,MAAM,CAAC,CAACkE,KAAK,EAAEgI,OAAO,KAAK;MACzC,MAAME,QAAQ,GAAGF,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAChM,IAAI,IAAIgM,OAAO,CAACM,OAAO,IAAI,CAAC;MACzE;MACA,OAAOtI,KAAK,IAAIkI,QAAQ,GAAG,GAAG,GAAGjJ,IAAI,CAACyB,KAAK,CAACwH,QAAQ,GAAG,EAAE,CAAC,GAAGA,QAAQ,CAAC;IACxE,CAAC,EAAE,CAAC,CAAC;EACP;EAEAjE,qBAAqBA,CAAC8D,QAAQ,EAAE;IAC9B,MAAMvM,YAAY,GAAG,CAAC,CAAC;IACvBuM,QAAQ,CAACjP,OAAO,CAACkP,OAAO,IAAI;MAC1B,MAAMvM,QAAQ,GAAGuM,OAAO,CAACvM,QAAQ,IAAI,SAAS;MAC9C,MAAMO,IAAI,GAAGgM,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAChM,IAAI,IAAI,CAAC;MACvER,YAAY,CAACC,QAAQ,CAAC,GAAG,CAACD,YAAY,CAACC,QAAQ,CAAC,IAAI,CAAC,IAAIO,IAAI;IAC/D,CAAC,CAAC;IACF,OAAOR,YAAY;EACrB;EAEA2I,yBAAyBA,CAAC4D,QAAQ,EAAE;IAClC,MAAM7D,gBAAgB,GAAG,CAAC,CAAC;IAC3B6D,QAAQ,CAACjP,OAAO,CAACkP,OAAO,IAAI;MAC1B,MAAMvM,QAAQ,GAAGuM,OAAO,CAACvM,QAAQ,IAAI,SAAS;MAC9CyI,gBAAgB,CAACzI,QAAQ,CAAC,GAAG,CAACyI,gBAAgB,CAACzI,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;IACpE,CAAC,CAAC;IACF,OAAOyI,gBAAgB;EACzB;EAEAE,yBAAyBA,CAAC2D,QAAQ,EAAE;IAClC,MAAM9C,UAAU,GAAG,IAAIF,GAAG,CAAC,CAAC;IAC5BgD,QAAQ,CAACjP,OAAO,CAACkP,OAAO,IAAI;MAC1B,IAAIA,OAAO,CAACvM,QAAQ,EAAE;QACpBwJ,UAAU,CAACE,GAAG,CAAC6C,OAAO,CAACvM,QAAQ,CAAC;MAClC;IACF,CAAC,CAAC;IACF,OAAOwJ,UAAU,CAACG,IAAI;EACxB;EAEAmD,2BAA2BA,CAACR,QAAQ,EAAE;IACpC,MAAMS,kBAAkB,GAAG,CAAC,CAAC;IAC7BT,QAAQ,CAACjP,OAAO,CAACkP,OAAO,IAAI;MAC1B,MAAME,QAAQ,GAAGF,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAChM,IAAI,IAAI,CAAC;MAC3EwM,kBAAkB,CAACN,QAAQ,CAAC,GAAG,CAACM,kBAAkB,CAACN,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;IACxE,CAAC,CAAC;IACF,OAAOM,kBAAkB;EAC3B;;EAEA;EACA9E,uBAAuBA,CAACqE,QAAQ,EAAE;IAChC,OAAOA,QAAQ,CAACjM,MAAM,CAAC,CAACkE,KAAK,EAAEgI,OAAO,KAAK;MACzC,OAAOhI,KAAK,IAAIgI,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAChM,IAAI,IAAIgM,OAAO,CAACM,OAAO,IAAI,CAAC,CAAC;IAChG,CAAC,EAAE,CAAC,CAAC;EACP;;EAEA;EACA1E,2BAA2BA,CAACmE,QAAQ,EAAE;IACpC,OAAO9I,IAAI,CAACmH,GAAG,CAAC,GAAG2B,QAAQ,CAAC1I,GAAG,CAAC2I,OAAO,IACrCA,OAAO,CAACC,SAAS,IAAID,OAAO,CAACE,QAAQ,IAAIF,OAAO,CAAChM,IAAI,IAAIgM,OAAO,CAACM,OAAO,IAAI,CAC9E,CAAC,EAAE,CAAC,CAAC;EACP;EAEAhE,mBAAmBA,CAAC1C,KAAK,EAAEC,KAAK,EAAEkG,QAAQ,EAAE;IAC1C,MAAMU,QAAQ,GAAG,IAAI1D,GAAG,CAAC,CAAC;IAE1B,CAAC,GAAGnD,KAAK,EAAE,GAAGC,KAAK,EAAE,GAAGkG,QAAQ,CAAC,CAACjP,OAAO,CAAC4P,IAAI,IAAI;MAChD,MAAMnD,IAAI,GAAGmD,IAAI,CAAClD,SAAS,IAAIkD,IAAI,CAACjD,OAAO,IAAIiD,IAAI,CAACnD,IAAI,IAAImD,IAAI,CAACnK,SAAS;MAC1E,IAAIgH,IAAI,EAAE;QACRkD,QAAQ,CAACtD,GAAG,CAAC,IAAI3L,IAAI,CAAC+L,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC,CAAC;MAC7C;IACF,CAAC,CAAC;IAEF,OAAOmD,QAAQ,CAACrD,IAAI;EACtB;EAEAb,sBAAsBA,CAAC3C,KAAK,EAAEC,KAAK,EAAEkG,QAAQ,EAAE;IAC7C;IACA,MAAMU,QAAQ,GAAG,IAAI1D,GAAG,CAAC,CAAC;IAE1B,CAAC,GAAGnD,KAAK,EAAE,GAAGC,KAAK,EAAE,GAAGkG,QAAQ,CAAC,CAACjP,OAAO,CAAC4P,IAAI,IAAI;MAChD,MAAMnD,IAAI,GAAGmD,IAAI,CAAClD,SAAS,IAAIkD,IAAI,CAACjD,OAAO,IAAIiD,IAAI,CAACnD,IAAI,IAAImD,IAAI,CAACnK,SAAS;MAC1E,IAAIgH,IAAI,EAAE;QACRkD,QAAQ,CAACtD,GAAG,CAAC,IAAI3L,IAAI,CAAC+L,IAAI,CAAC,CAACD,YAAY,CAAC,CAAC,CAAC;MAC7C;IACF,CAAC,CAAC;IAEF,MAAMM,WAAW,GAAG3D,KAAK,CAAC0G,IAAI,CAACF,QAAQ,CAAC,CAAClJ,IAAI,CAAC,CAACrG,CAAC,EAAEsG,CAAC,KAAK,IAAIhG,IAAI,CAACgG,CAAC,CAAC,GAAG,IAAIhG,IAAI,CAACN,CAAC,CAAC,CAAC;IAClF,IAAI4M,MAAM,GAAG,CAAC;IACd,IAAIC,WAAW,GAAG,IAAIvM,IAAI,CAAC,CAAC;IAE5B,KAAK,IAAIwM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAAC3F,MAAM,EAAE+F,CAAC,EAAE,EAAE;MAC3C,MAAM4C,YAAY,GAAG,IAAIpP,IAAI,CAACoM,WAAW,CAACI,CAAC,CAAC,CAAC;MAC7C,MAAME,QAAQ,GAAGjH,IAAI,CAACkH,KAAK,CAAC,CAACJ,WAAW,GAAG6C,YAAY,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;MAEjF,IAAI1C,QAAQ,KAAKF,CAAC,EAAE;QAClBF,MAAM,EAAE;MACV,CAAC,MAAM;QACL;MACF;IACF;IAEA,OAAOA,MAAM;EACf;AACF;AAEA,OAAO,MAAM+C,kBAAkB,GAAG,IAAIpR,kBAAkB,CAAC,CAAC;AAC1D,eAAeoR,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}